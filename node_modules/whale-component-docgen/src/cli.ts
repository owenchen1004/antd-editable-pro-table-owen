#! /usr/bin/env node

import { program } from 'commander';
import * as fs from 'fs-extra';
import * as path from 'path';
import * as pkgUp from 'pkg-up';
import { whaleDocgen, whaleParse } from './index';
import { WhaleParseOptions } from './types';

const packageJSON = fs.readJSONSync(path.resolve(__dirname, '../package.json'));

program
  .arguments('[files...]')
  .option('-o, --output <output>', '写入文件')
  .option('-f, --format <format>', '格式化类型, json | md', 'md')
  .option('--filterReact', '是否过滤来自react/rax的属性，仅tsx', true)
  .option('--typeLevel', '类型下钻深度，仅tsx', '2')
  .version(packageJSON.version)
  .action((files: string[], { output, format, filterReact, typeLevel }) => {
    const sources = files.length === 0 ? [pkgUp.sync()] : files;
    let content: string;
    const options: WhaleParseOptions = {
      ingoreFileNames: filterReact
        ? ['@types/react', '@types/rax', 'typescript/lib']
        : [],
      typeLevel: Number.isNaN(+typeLevel) ? 2 : +typeLevel,
    };
    if (format === 'json') {
      const docs =
        sources.length === 0
          ? whaleParse(sources[0], options) || []
          : sources.map((vo) => ({
              file: vo,
              compoents: whaleParse(vo, options) || [],
            }));
      content = JSON.stringify(docs, null, 2);
    } else {
      content = sources.map((vo) => whaleDocgen(vo, options)).join('\n');
    }

    if (output) {
      fs.writeFileSync(output, content);
      process.stdout.write(
        `${
          sources.length > 1 ? `${sources.length} files` : sources[0]
        } -> ${output}`
      );
    } else {
      process.stdout.write(content);
    }
  });

program.parse(process.argv);
