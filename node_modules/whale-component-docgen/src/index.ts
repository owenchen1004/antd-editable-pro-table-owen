import * as path from 'path';
import * as vfile from 'to-vfile';
import * as remark from 'remark';
import * as reactDocgenTypescript from 'remark-react-docgen-typescript';
import * as emoji from 'remark-emoji';
import { root } from 'mdast-builder';
import * as stringWidth from 'string-width';
import {
  parseTSComponent,
  defaultParserOptions,
  isExportDefault,
} from './utils/parseTSComponent';
import { parseJSComponent } from './utils/parseJSComponent';
import { MaterialPackageJSON, WhaleParseOptions } from './types';
import * as fs from 'fs-extra';
import { getMainPath } from './utils/getMainPath';
import { renderPackageJSON } from './render/renderPackageJSON';
import {
  withDefaultConfig,
  WmComponentDoc,
  WmParserOptions,
} from 'whale-docgen-ts';

import { renderComponentDocs } from './render/renderComponentDoc';

export * from './utils/parseTSComponent';
export * from './utils/parseJSComponent';
export * from './types';

/**
 * 解析文件返回组件属性描述JSON
 */
export const whaleParse = (
  source: string,
  options?: WhaleParseOptions
): WmComponentDoc[] | null => {
  const extname = path.extname(source);
  if (extname === '.json') {
    const componentPath = getMainPath(source);
    const packageJSON = fs.readJSONSync(source) as MaterialPackageJSON;
    return whaleParse(componentPath, {
      defaultComponentName: packageJSON.componentConfig?.name,
      ...options,
    });
  } else if (extname === '.tsx' || extname === '.ts') {
    const typeFilter: WmParserOptions['typeFilter'] = options?.ingoreFileNames
      ? (prop) => {
          const fileName = prop?.parent?.fileName;
          if (!fileName) {
            return true;
          }
          return !options.ingoreFileNames.some((vo) => fileName.includes(vo));
        }
      : undefined;
    return parseTSComponent(source, {
      typeFilter,
      propFilter: typeFilter,
      typeLevel: options?.typeLevel,
      componentNameResolver: (exp) => {
        if (options?.defaultComponentName && isExportDefault(exp.getName())) {
          return options.defaultComponentName;
        }
        return undefined;
      },
    });
  } else if (extname === '.jsx' || extname === '.js') {
    return parseJSComponent(source);
  }
  return null;
};

/**
 * 解析文件返回组件markdown文档
 */
export const whaleDocgen = (source: string, options?: WhaleParseOptions) => {
  const extname = path.extname(source);
  const baseProcessor = remark()
    .use(emoji)
    .use({
      settings: { stringLength: stringWidth },
    });
  if (extname === '.json') {
    const packageJSON = fs.readJSONSync(source) as MaterialPackageJSON;
    const docs = whaleParse(source, {
      ...options,
      typeLevel: 0,
    });
    return baseProcessor.stringify(
      root([
        ...renderPackageJSON(packageJSON, source),
        ...(docs ? renderComponentDocs(docs) : []),
      ])
    );
  } else if (extname === '.md') {
    return baseProcessor
      .use(reactDocgenTypescript, {
        fileParser: withDefaultConfig(defaultParserOptions),
        render: (docs) => root(renderComponentDocs(docs as WmComponentDoc[])),
      })
      .processSync(vfile.readSync(source))
      .contents.toString();
  }
  const docs = whaleParse(source, {
    ...options,
    typeLevel: 1,
  });
  if (docs) {
    return baseProcessor.stringify(root(renderComponentDocs(docs)));
  }

  throw new Error('extname of source is not allowed.');
};

export * from 'whale-docgen-ts';
