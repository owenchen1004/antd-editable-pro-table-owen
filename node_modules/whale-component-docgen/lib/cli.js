#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const fs = require("fs-extra");
const path = require("path");
const pkgUp = require("pkg-up");
const index_1 = require("./index");
const packageJSON = fs.readJSONSync(path.resolve(__dirname, '../package.json'));
commander_1.program
    .arguments('[files...]')
    .option('-o, --output <output>', '写入文件')
    .option('-f, --format <format>', '格式化类型, json | md', 'md')
    .option('--filterReact', '是否过滤来自react/rax的属性，仅tsx', true)
    .option('--typeLevel', '类型下钻深度，仅tsx', '2')
    .version(packageJSON.version)
    .action((files, { output, format, filterReact, typeLevel }) => {
    const sources = files.length === 0 ? [pkgUp.sync()] : files;
    let content;
    const options = {
        ingoreFileNames: filterReact
            ? ['@types/react', '@types/rax', 'typescript/lib']
            : [],
        typeLevel: Number.isNaN(+typeLevel) ? 2 : +typeLevel,
    };
    if (format === 'json') {
        const docs = sources.length === 0
            ? index_1.whaleParse(sources[0], options) || []
            : sources.map((vo) => ({
                file: vo,
                compoents: index_1.whaleParse(vo, options) || [],
            }));
        content = JSON.stringify(docs, null, 2);
    }
    else {
        content = sources.map((vo) => index_1.whaleDocgen(vo, options)).join('\n');
    }
    if (output) {
        fs.writeFileSync(output, content);
        process.stdout.write(`${sources.length > 1 ? `${sources.length} files` : sources[0]} -> ${output}`);
    }
    else {
        process.stdout.write(content);
    }
});
commander_1.program.parse(process.argv);
//# sourceMappingURL=cli.js.map