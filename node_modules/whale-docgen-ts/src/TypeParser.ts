import * as ts from 'typescript';
import {
  isOptionalSymbol,
  isTupleType,
  typeHasFlag,
  isFunctionType,
} from './utils/flags';
import { isObjectProp, isWhiteObjectType } from './utils/isObjectProp';
import { createWmPlainPropItemType } from './utils/propItemType';
import { findDocComment } from './utils/findDocComment';
import {
  WmArrayPropItemType,
  WmParentType,
  WmParserOptions,
  WmProps,
  WmPropItem,
  WmPropItemType,
  WmUnionPropItemType,
  WmObjectPropItemType,
  WmFunctionPropItemType,
} from './types';
import { getCurrentDirectoryName } from './utils/currentDirectoryPath';

export class TypePaser {
  parserOptions: WmParserOptions;

  checker: ts.TypeChecker;
  currentDirectoryName: string;

  constructor(checker: ts.TypeChecker, parserOptions: WmParserOptions) {
    this.checker = checker;
    this.parserOptions = parserOptions;
    this.currentDirectoryName = getCurrentDirectoryName(parserOptions.cwd);
  }

  getTypeDoc(
    propType: ts.Type,
    isRequired: boolean,
    level: number
  ): WmPropItemType {
    const raw = getPropTypeString(this.checker, propType, isRequired);

    if (
      propType.isUnion() &&
      !typeHasFlag(propType, ts.TypeFlags.Boolean) &&
      !isWhiteObjectType(propType)
    ) {
      const typeDoc: WmUnionPropItemType = {
        name: 'union',
        raw,
        value: propType.types.map((prop) =>
          this.getTypeDoc(prop, false, level)
        ),
      };
      return typeDoc;
    }
    if (level > 0) {
      if (isTupleType(propType)) {
        const targetTupleType = propType.target;
        const items = propType.typeArguments.map((elType) =>
          this.getTypeDoc(elType as any, false, level)
        );
        let additionalItems;
        if (targetTupleType.hasRestElement) {
          additionalItems = items[items.length - 1];
          items.splice(items.length - 1, 1);
        }
        // tuple
        const typeDoc: WmArrayPropItemType = {
          name: 'array',
          raw,
          value: items,
          additionalItems,
        };
        return typeDoc;
      }
      if (isFunctionType(propType)) {
        const typeDoc: WmFunctionPropItemType = {
          name: 'function',
          raw,
        };
        return typeDoc;
      }
      if (propType.isIntersection() || isObjectProp(propType)) {
        const typeDoc: WmObjectPropItemType = {
          name: 'object',
          raw,
          value: this.getObjectDoc(propType, level),
        };
        return typeDoc;
      }
    }
    return createWmPlainPropItemType(raw);
  }

  getAttributeDoc(
    prop: ts.Symbol,
    baseProps: ts.Symbol[] = [],
    level
  ): WmPropItem {
    const propName = prop.getName();

    // Find type of prop by looking in context of the props object itself.
    const propType = this.checker.getTypeOfSymbolAtLocation(
      prop,
      getValueDeclaration(prop)
    );

    const jsDocComment = findDocComment(this.checker, prop);

    let defaultValue: { value: string };

    if (jsDocComment.tags.default) {
      defaultValue = { value: jsDocComment.tags.default };
    }
    if (!defaultValue && jsDocComment.tags.defaultValue) {
      defaultValue = { value: jsDocComment.tags.defaultValue };
    }
    const parent = getParentType(prop, this.currentDirectoryName);
    const declarations = prop.declarations || [];
    const baseProp = baseProps.find((p) => p.getName() === propName);

    const required =
      !isOptionalSymbol(prop) &&
      // If in a intersection or union check original declaration for "?"
      // @ts-ignore
      declarations.every((d) => !d.questionToken) &&
      (!baseProp || !isOptionalSymbol(baseProp));

    const type: WmPropItemType = this.getTypeDoc(propType, required, level);

    return {
      defaultValue,
      description: jsDocComment.fullComment,
      name: propName,
      parent,
      required,
      type,
    };
  }

  getObjectDoc(propsType: ts.Type, level = 2): WmProps {
    const baseProps = propsType.getProperties();
    let propertiesOfProps = baseProps;

    if (propsType.isIntersection()) {
      const { types } = propsType;
      // @ts-ignore
      propertiesOfProps = this.checker.getAllPossiblePropertiesOfTypes(types);
    }

    const result: WmProps = {};

    propertiesOfProps.forEach((prop) => {
      const propInfo = this.getAttributeDoc(prop, baseProps, level - 1);
      result[propInfo.name] = propInfo;
    });
    const { typeFilter } = this.parserOptions;
    if (typeFilter) {
      Object.keys(result).forEach((typeName) => {
        const prop = result[typeName];
        if (!typeFilter(prop)) {
          delete result[typeName];
        }
      });
    }
    return result;
  }
}

function getParentType(
  prop: ts.Symbol,
  currentDirectoryName: string
): WmParentType | undefined {
  const valueDeclaration = getValueDeclaration(prop);

  if (!valueDeclaration) {
    /* istanbul ignore next */
    return undefined;
  }
  // Props can be declared only in one place
  const { parent } = valueDeclaration;

  if (!isInterfaceOrTypeAliasDeclaration(parent)) {
    return undefined;
  }

  const parentName = parent.name.text;
  const sourceFile = parent.getSourceFile();
  const { fileName } = sourceFile;

  const fileNameParts = fileName.split('/');
  const trimmedFileNameParts = fileNameParts.slice();
  while (trimmedFileNameParts.length) {
    if (trimmedFileNameParts[0] === currentDirectoryName) {
      break;
    }
    trimmedFileNameParts.splice(0, 1);
  }
  let trimmedFileName;
  if (trimmedFileNameParts.length) {
    trimmedFileName = trimmedFileNameParts.join('/');
  } else {
    trimmedFileName = fileName;
  }

  // const { line, character } = sourceFile.getLineAndCharacterOfPosition(
  //   valueDeclaration.pos
  // );

  return {
    fileName: trimmedFileName,
    name: parentName,
    // line,
    // character,
    // pos: valueDeclaration.pos,
  };
}

const getPropTypeString = (
  checker: ts.TypeChecker,
  propType: ts.Type,
  isRequired: boolean
) => {
  // const valueDeclaration = getValueDeclaration(propType.getSymbol());
  const propTypeString = checker.typeToString(propType);

  if (!isRequired) {
    return propTypeString.replace(' | undefined', '');
  }
  return propTypeString;
};
export const getValueDeclaration = (symbol: ts.Symbol) => {
  if (!symbol) {
    return undefined;
  }
  const declarations = symbol.getDeclarations();
  return symbol.valueDeclaration || (declarations && declarations[0]);
};

const isInterfaceOrTypeAliasDeclaration = (
  node: ts.Node
): node is ts.InterfaceDeclaration | ts.TypeAliasDeclaration =>
  node.kind === ts.SyntaxKind.InterfaceDeclaration ||
  node.kind === ts.SyntaxKind.TypeAliasDeclaration;
