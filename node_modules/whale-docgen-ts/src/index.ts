import * as ts from 'typescript';
import { WmParser } from './WmParser';
import { WmComponentDoc, WmParserOptions } from './types';
import { getValueDeclaration } from './TypeParser';

export * from './utils/propItemType';
export * from './types';
export * from './WmParser';

const defaultParserOpts: WmParserOptions = {};

export const defaultOptions = {
  jsx: ts.JsxEmit.React,
  module: ts.ModuleKind.CommonJS,
  target: ts.ScriptTarget.Latest,
};
/**
 * Parses a file with default TS options
 * @param filePath component file that should be parsed
 */
export function parse(
  filePathOrPaths: string | string[],
  parserOpts: WmParserOptions = defaultParserOpts
) {
  return withCompilerOptions(defaultOptions, parserOpts).parse(filePathOrPaths);
}

/**
 * Constructs a parser for a default configuration.
 */
export function withDefaultConfig(
  parserOpts: WmParserOptions = defaultParserOpts
) {
  return withCompilerOptions(defaultOptions, parserOpts);
}

/**
 * Constructs a parser for a specified set of TS compiler options.
 */
export function withCompilerOptions(
  compilerOptions: ts.CompilerOptions,
  parserOpts: WmParserOptions = defaultParserOpts
) {
  const parseFn = (filePathOrPaths: string | string[]) =>
    parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts);

  const parseWithProgramProviderFn = (
    filePathOrPaths: string | string[],
    programProvider?: (
      rootNames: readonly string[],
      compilerOptions: ts.CompilerOptions
    ) => ts.Program
  ) =>
    parseWithProgramProvider(
      filePathOrPaths,
      compilerOptions,
      parserOpts,
      programProvider
    );
  return {
    parse: parseFn,
    parseWithProgramProvider: parseWithProgramProviderFn,
  };
}

function parseWithProgramProvider(
  filePathOrPaths: string | string[],
  compilerOptions: ts.CompilerOptions,
  parserOpts: WmParserOptions,
  programProvider?: (
    rootNames: readonly string[],
    compilerOptions: ts.CompilerOptions
  ) => ts.Program
): WmComponentDoc[] {
  const filePaths = Array.isArray(filePathOrPaths)
    ? filePathOrPaths
    : [filePathOrPaths];
  const program = programProvider
    ? programProvider(filePaths, compilerOptions)
    : ts.createProgram(filePaths, compilerOptions);

  const checker = program.getTypeChecker();

  const parser = new WmParser(program, parserOpts);

  return filePaths
    .map((filePath) => program.getSourceFile(filePath))
    .filter((sourceFile) => sourceFile)
    .reduce<WmComponentDoc[]>((docs, sourceFile) => {
      const moduleSymbol = checker.getSymbolAtLocation(sourceFile);

      if (moduleSymbol) {
        // 遍历导出的组件
        checker.getExportsOfModule(moduleSymbol).forEach((exp) => {
          const doc = parser.getWmComponentDoc(exp, sourceFile);
          if (doc) {
            docs.push(doc);
          }
          /**
           * 子组件文档，如
           *
           * class Button extends React.Component {
           *  static Group = ButtonGroup;
           * }
           * export default Object.assign(Button, {
           *  Group2: ButtonGroup;
           * });
           */
          docs.push(
            ...checker
              .getTypeOfSymbolAtLocation(exp, getValueDeclaration(exp))
              .getProperties()
              .map((symbol) =>
                parser.getSubWmComponentDoc(exp, symbol, sourceFile)
              )
              .filter((vo) => vo)
          );
        });
      }

      return docs;
    }, []);
}
