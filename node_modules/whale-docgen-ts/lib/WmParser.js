"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WmParser = void 0;
const tslib_1 = require("tslib");
const parser_1 = require("./TsParser/parser");
const TypeParser_1 = require("./TypeParser");
const isNormalFuction_1 = require("./utils/isNormalFuction");
const isNumber = (n) => typeof n === 'number' && !Number.isNaN(n);
class WmParser extends parser_1.Parser {
    constructor(program, opts) {
        super(program, opts);
        this.parserOptions = Object.assign(Object.assign({}, opts), { typeLevel: Math.max(0, isNumber(opts.typeLevel) ? opts.typeLevel : 2) });
        // @ts-ignore
        const { checker } = this;
        this.typePaser = new TypeParser_1.TypePaser(checker, opts);
    }
    isComponent(symbol) {
        var _a;
        if (!(symbol.valueDeclaration || ((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]))) {
            return false;
        }
        // @ts-ignore
        const { checker } = this;
        // 判断是否是普通函数
        if (isNormalFuction_1.isNormalFuction(checker, symbol)) {
            return false;
        }
        // @ts-ignore
        const rootExp = this.getComponentFromExpression(symbol);
        const declaration = rootExp.valueDeclaration || rootExp.declarations[0];
        const type = checker.getTypeOfSymbolAtLocation(rootExp, declaration);
        // 获取代表props的type
        const propsType = this.extractPropsFromTypeIfStatelessComponent(type) ||
            this.extractPropsFromTypeIfStatefulComponent(type);
        return !!propsType;
    }
    getWmComponentDoc(symbol, source) {
        if (!this.isComponent(symbol)) {
            return null;
        }
        const doc = this.getComponentInfo(symbol, source, this.parserOptions.componentNameResolver);
        if (!doc) {
            return null;
        }
        const { tags } = doc, others = tslib_1.__rest(doc, ["tags"]);
        return Object.assign(Object.assign({}, others), { meta: {
                exportName: symbol.getName(),
            } });
    }
    getSubWmComponentDoc(parentSymbol, symbol, source) {
        if (!this.isComponent(symbol)) {
            return null;
        }
        const doc = this.getComponentInfo(symbol, source, this.parserOptions.componentNameResolver);
        if (!doc) {
            return null;
        }
        const { tags } = doc, others = tslib_1.__rest(doc, ["tags"]);
        return Object.assign(Object.assign({}, others), { displayName: `${parentSymbol.getName()}.${doc.displayName}`, meta: {
                exportName: parentSymbol.getName(),
                subName: symbol.getName(),
            } });
    }
    getPropsInfo(propsObj, defaultProps = {}) {
        if (!propsObj.valueDeclaration) {
            return {};
        }
        // @ts-ignore
        const { checker } = this;
        const propsType = checker.getTypeOfSymbolAtLocation(propsObj, propsObj.valueDeclaration);
        const props = this.typePaser.getObjectDoc(propsType, this.parserOptions.typeLevel + 1);
        Object.keys(defaultProps)
            .filter((vo) => defaultProps[vo] !== undefined && vo in props)
            .forEach((vo) => {
            props[vo].required = false;
            props[vo].defaultValue = { value: defaultProps[vo] };
        });
        return props;
    }
}
exports.WmParser = WmParser;
//# sourceMappingURL=WmParser.js.map