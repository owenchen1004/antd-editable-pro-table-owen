"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValueDeclaration = exports.TypePaser = void 0;
const ts = require("typescript");
const flags_1 = require("./utils/flags");
const isObjectProp_1 = require("./utils/isObjectProp");
const propItemType_1 = require("./utils/propItemType");
const findDocComment_1 = require("./utils/findDocComment");
const currentDirectoryPath_1 = require("./utils/currentDirectoryPath");
class TypePaser {
    constructor(checker, parserOptions) {
        this.checker = checker;
        this.parserOptions = parserOptions;
        this.currentDirectoryName = currentDirectoryPath_1.getCurrentDirectoryName(parserOptions.cwd);
    }
    getTypeDoc(propType, isRequired, level) {
        const raw = getPropTypeString(this.checker, propType, isRequired);
        if (propType.isUnion() &&
            !flags_1.typeHasFlag(propType, ts.TypeFlags.Boolean) &&
            !isObjectProp_1.isWhiteObjectType(propType)) {
            const typeDoc = {
                name: 'union',
                raw,
                value: propType.types.map((prop) => this.getTypeDoc(prop, false, level)),
            };
            return typeDoc;
        }
        if (level > 0) {
            if (flags_1.isTupleType(propType)) {
                const targetTupleType = propType.target;
                const items = propType.typeArguments.map((elType) => this.getTypeDoc(elType, false, level));
                let additionalItems;
                if (targetTupleType.hasRestElement) {
                    additionalItems = items[items.length - 1];
                    items.splice(items.length - 1, 1);
                }
                // tuple
                const typeDoc = {
                    name: 'array',
                    raw,
                    value: items,
                    additionalItems,
                };
                return typeDoc;
            }
            if (flags_1.isFunctionType(propType)) {
                const typeDoc = {
                    name: 'function',
                    raw,
                };
                return typeDoc;
            }
            if (propType.isIntersection() || isObjectProp_1.isObjectProp(propType)) {
                const typeDoc = {
                    name: 'object',
                    raw,
                    value: this.getObjectDoc(propType, level),
                };
                return typeDoc;
            }
        }
        return propItemType_1.createWmPlainPropItemType(raw);
    }
    getAttributeDoc(prop, baseProps = [], level) {
        const propName = prop.getName();
        // Find type of prop by looking in context of the props object itself.
        const propType = this.checker.getTypeOfSymbolAtLocation(prop, exports.getValueDeclaration(prop));
        const jsDocComment = findDocComment_1.findDocComment(this.checker, prop);
        let defaultValue;
        if (jsDocComment.tags.default) {
            defaultValue = { value: jsDocComment.tags.default };
        }
        if (!defaultValue && jsDocComment.tags.defaultValue) {
            defaultValue = { value: jsDocComment.tags.defaultValue };
        }
        const parent = getParentType(prop, this.currentDirectoryName);
        const declarations = prop.declarations || [];
        const baseProp = baseProps.find((p) => p.getName() === propName);
        const required = !flags_1.isOptionalSymbol(prop) &&
            // If in a intersection or union check original declaration for "?"
            // @ts-ignore
            declarations.every((d) => !d.questionToken) &&
            (!baseProp || !flags_1.isOptionalSymbol(baseProp));
        const type = this.getTypeDoc(propType, required, level);
        return {
            defaultValue,
            description: jsDocComment.fullComment,
            name: propName,
            parent,
            required,
            type,
        };
    }
    getObjectDoc(propsType, level = 2) {
        const baseProps = propsType.getProperties();
        let propertiesOfProps = baseProps;
        if (propsType.isIntersection()) {
            const { types } = propsType;
            // @ts-ignore
            propertiesOfProps = this.checker.getAllPossiblePropertiesOfTypes(types);
        }
        const result = {};
        propertiesOfProps.forEach((prop) => {
            const propInfo = this.getAttributeDoc(prop, baseProps, level - 1);
            result[propInfo.name] = propInfo;
        });
        const { typeFilter } = this.parserOptions;
        if (typeFilter) {
            Object.keys(result).forEach((typeName) => {
                const prop = result[typeName];
                if (!typeFilter(prop)) {
                    delete result[typeName];
                }
            });
        }
        return result;
    }
}
exports.TypePaser = TypePaser;
function getParentType(prop, currentDirectoryName) {
    const valueDeclaration = exports.getValueDeclaration(prop);
    if (!valueDeclaration) {
        /* istanbul ignore next */
        return undefined;
    }
    // Props can be declared only in one place
    const { parent } = valueDeclaration;
    if (!isInterfaceOrTypeAliasDeclaration(parent)) {
        return undefined;
    }
    const parentName = parent.name.text;
    const sourceFile = parent.getSourceFile();
    const { fileName } = sourceFile;
    const fileNameParts = fileName.split('/');
    const trimmedFileNameParts = fileNameParts.slice();
    while (trimmedFileNameParts.length) {
        if (trimmedFileNameParts[0] === currentDirectoryName) {
            break;
        }
        trimmedFileNameParts.splice(0, 1);
    }
    let trimmedFileName;
    if (trimmedFileNameParts.length) {
        trimmedFileName = trimmedFileNameParts.join('/');
    }
    else {
        trimmedFileName = fileName;
    }
    // const { line, character } = sourceFile.getLineAndCharacterOfPosition(
    //   valueDeclaration.pos
    // );
    return {
        fileName: trimmedFileName,
        name: parentName,
        // line,
        // character,
        // pos: valueDeclaration.pos,
    };
}
const getPropTypeString = (checker, propType, isRequired) => {
    // const valueDeclaration = getValueDeclaration(propType.getSymbol());
    const propTypeString = checker.typeToString(propType);
    if (!isRequired) {
        return propTypeString.replace(' | undefined', '');
    }
    return propTypeString;
};
const getValueDeclaration = (symbol) => {
    if (!symbol) {
        return undefined;
    }
    const declarations = symbol.getDeclarations();
    return symbol.valueDeclaration || (declarations && declarations[0]);
};
exports.getValueDeclaration = getValueDeclaration;
const isInterfaceOrTypeAliasDeclaration = (node) => node.kind === ts.SyntaxKind.InterfaceDeclaration ||
    node.kind === ts.SyntaxKind.TypeAliasDeclaration;
//# sourceMappingURL=TypeParser.js.map