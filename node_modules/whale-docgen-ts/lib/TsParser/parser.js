"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultExportForFile = exports.Parser = void 0;
const path = require("path");
const ts = require("typescript");
const buildFilter_1 = require("./buildFilter");
const findDocComment_1 = require("../utils/findDocComment");
class Parser {
    constructor(program, opts) {
        const { savePropValueAsString } = opts;
        this.checker = program.getTypeChecker();
        this.propFilter = buildFilter_1.buildFilter(opts);
        this.savePropValueAsString = Boolean(savePropValueAsString);
    }
    getPropsInfo(propsObj, defaultProps = {}) {
        console.log(propsObj, defaultProps);
        return {};
    }
    getComponentInfo(exp, source, componentNameResolver = () => undefined) {
        if (!!exp.declarations && exp.declarations.length === 0) {
            return null;
        }
        let rootExp = this.getComponentFromExpression(exp);
        const declaration = rootExp.valueDeclaration || rootExp.declarations[0];
        const type = this.checker.getTypeOfSymbolAtLocation(rootExp, declaration);
        let commentSource = rootExp;
        const typeSymbol = type.symbol || type.aliasSymbol;
        const originalName = rootExp.getName();
        if (!rootExp.valueDeclaration) {
            if (originalName === 'default' &&
                !typeSymbol &&
                (rootExp.flags & ts.SymbolFlags.Alias) !== 0) {
                commentSource = this.checker.getAliasedSymbol(commentSource);
            }
            else if (!typeSymbol) {
                return null;
            }
            else {
                rootExp = typeSymbol;
                const expName = rootExp.getName();
                if (expName === '__function' ||
                    expName === 'StatelessComponent' ||
                    expName === 'Stateless' ||
                    expName === 'StyledComponentClass' ||
                    expName === 'StyledComponent' ||
                    expName === 'FunctionComponent' ||
                    expName === 'ForwardRefExoticComponent') {
                    commentSource = this.checker.getAliasedSymbol(commentSource);
                }
                else {
                    commentSource = rootExp;
                }
            }
        }
        else if (type.symbol &&
            (ts.isPropertyAccessExpression(declaration) ||
                ts.isPropertyDeclaration(declaration))) {
            commentSource = type.symbol;
        }
        // Skip over PropTypes that are exported
        if (typeSymbol &&
            (typeSymbol.getEscapedName() === 'Requireable' ||
                typeSymbol.getEscapedName() === 'Validator')) {
            return null;
        }
        const propsType = this.extractPropsFromTypeIfStatelessComponent(type) ||
            this.extractPropsFromTypeIfStatefulComponent(type);
        const nameSource = originalName === 'default' ? rootExp : commentSource;
        const resolvedComponentName = componentNameResolver(nameSource, source);
        const { description, tags } = findDocComment_1.findDocComment(this.checker, commentSource);
        const displayName = resolvedComponentName ||
            tags.visibleName ||
            computeComponentName(nameSource, source);
        const methods = this.getMethodsInfo(type);
        if (propsType) {
            if (!commentSource.valueDeclaration) {
                return null;
            }
            const defaultProps = this.extractDefaultPropsFromComponent(commentSource, commentSource.valueDeclaration.getSourceFile());
            const props = this.getPropsInfo(propsType, defaultProps);
            for (const propName of Object.keys(props)) {
                const prop = props[propName];
                const component = { name: displayName };
                if (!this.propFilter(prop, component)) {
                    delete props[propName];
                }
            }
            return {
                tags,
                description,
                displayName,
                methods,
                props,
            };
        }
        else if (description && displayName) {
            return {
                tags,
                description,
                displayName,
                methods,
                props: {},
            };
        }
        return null;
    }
    extractPropsFromTypeIfStatelessComponent(type) {
        const callSignatures = type.getCallSignatures();
        if (callSignatures.length) {
            // Could be a stateless component.  Is a function, so the props object we're interested
            // in is the (only) parameter.
            for (const sig of callSignatures) {
                const params = sig.getParameters();
                if (params.length === 0) {
                    continue;
                }
                // Maybe we could check return type instead,
                // but not sure if Element, ReactElement<T> are all possible values
                const propsParam = params[0];
                if (propsParam.name === 'props' || params.length === 1) {
                    return propsParam;
                }
            }
        }
        return null;
    }
    extractPropsFromTypeIfStatefulComponent(type) {
        const constructSignatures = type.getConstructSignatures();
        if (constructSignatures.length) {
            // React.Component. Is a class, so the props object we're interested
            // in is the type of 'props' property of the object constructed by the class.
            for (const sig of constructSignatures) {
                const instanceType = sig.getReturnType();
                const props = instanceType.getProperty('props');
                if (props) {
                    return props;
                }
            }
        }
        return null;
    }
    extractMembersFromType(type) {
        const methodSymbols = [];
        /**
         * Need to loop over properties first so we capture any
         * static methods. static methods aren't captured in type.symbol.members
         */
        type.getProperties().forEach((property) => {
            // Only add members, don't add non-member properties
            if (this.getCallSignature(property)) {
                methodSymbols.push(property);
            }
        });
        if (type.symbol && type.symbol.members) {
            type.symbol.members.forEach((member) => {
                methodSymbols.push(member);
            });
        }
        return methodSymbols;
    }
    getMethodsInfo(type) {
        const members = this.extractMembersFromType(type);
        const methods = [];
        members.forEach((member) => {
            if (!this.isTaggedPublic(member)) {
                return;
            }
            const name = member.getName();
            const docblock = findDocComment_1.getFullJsDocComment(this.checker, member).fullComment;
            const callSignature = this.getCallSignature(member);
            const params = this.getParameterInfo(callSignature);
            const description = ts.displayPartsToString(member.getDocumentationComment(this.checker));
            const returnType = this.checker.typeToString(callSignature.getReturnType());
            const returnDescription = this.getReturnDescription(member);
            const modifiers = this.getModifiers(member);
            methods.push({
                description,
                docblock,
                modifiers,
                name,
                params,
                returns: returnDescription
                    ? {
                        description: returnDescription,
                        type: returnType,
                    }
                    : null,
            });
        });
        return methods;
    }
    getModifiers(member) {
        const modifiers = [];
        const flags = ts.getCombinedModifierFlags(member.valueDeclaration);
        const isStatic = (flags & ts.ModifierFlags.Static) !== 0;
        if (isStatic) {
            modifiers.push('static');
        }
        return modifiers;
    }
    getParameterInfo(callSignature) {
        return callSignature.parameters.map((param) => {
            const paramType = this.checker.getTypeOfSymbolAtLocation(param, param.valueDeclaration);
            const paramDeclaration = this.checker.symbolToParameterDeclaration(param, undefined, undefined);
            const isOptionalParam = !!(paramDeclaration && paramDeclaration.questionToken);
            return {
                description: ts.displayPartsToString(param.getDocumentationComment(this.checker)) || null,
                name: param.getName() + (isOptionalParam ? '?' : ''),
                type: { name: this.checker.typeToString(paramType) },
            };
        });
    }
    getCallSignature(symbol) {
        const symbolType = this.checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
        return symbolType.getCallSignatures()[0];
    }
    isTaggedPublic(symbol) {
        const jsDocTags = symbol.getJsDocTags();
        const isPublic = Boolean(jsDocTags.find((tag) => tag.name === 'public'));
        return isPublic;
    }
    getReturnDescription(symbol) {
        const tags = symbol.getJsDocTags();
        const returnTag = tags.find((tag) => tag.name === 'returns');
        return findDocComment_1.formatTagText(returnTag) || null;
    }
    getFunctionStatement(statement) {
        if (ts.isFunctionDeclaration(statement)) {
            return statement;
        }
        if (ts.isVariableStatement(statement)) {
            let initializer = statement.declarationList &&
                statement.declarationList.declarations[0].initializer;
            // Look at forwardRef function argument
            if (initializer && ts.isCallExpression(initializer)) {
                const symbol = this.checker.getSymbolAtLocation(initializer.expression);
                if (!symbol || symbol.getName() !== 'forwardRef')
                    return undefined;
                initializer = initializer.arguments[0];
            }
            if (initializer &&
                (ts.isArrowFunction(initializer) ||
                    ts.isFunctionExpression(initializer))) {
                return initializer;
            }
        }
        return undefined;
    }
    extractDefaultPropsFromComponent(symbol, source) {
        const possibleStatements = [
            ...source.statements
                // ensure that name property is available
                .filter((stmt) => !!stmt.name)
                .filter((stmt) => this.checker.getSymbolAtLocation(stmt.name) === symbol),
            ...source.statements.filter((stmt) => ts.isExpressionStatement(stmt) || ts.isVariableStatement(stmt)),
        ];
        return possibleStatements.reduce((res, statement) => {
            if (statementIsClassDeclaration(statement) && statement.members.length) {
                const possibleDefaultProps = statement.members.filter((member) => member.name && getPropertyName(member.name) === 'defaultProps');
                if (!possibleDefaultProps.length) {
                    return res;
                }
                const defaultProps = possibleDefaultProps[0];
                let { initializer } = defaultProps;
                if (!initializer) {
                    return res;
                }
                let { properties } = initializer;
                while (ts.isIdentifier(initializer)) {
                    const defaultPropsReference = this.checker.getSymbolAtLocation(initializer);
                    if (defaultPropsReference) {
                        const declarations = defaultPropsReference.getDeclarations();
                        if (declarations) {
                            initializer = declarations[0]
                                .initializer;
                            properties = initializer
                                .properties;
                        }
                    }
                }
                let propMap = {};
                if (properties) {
                    propMap = this.getPropMap(properties);
                }
                return Object.assign(Object.assign({}, res), propMap);
            }
            else if (statementIsStatelessWithDefaultProps(statement)) {
                let propMap = {};
                statement.getChildren().forEach((child) => {
                    let { right } = child;
                    if (right && ts.isIdentifier(right)) {
                        const value = source.locals.get(right.escapedText);
                        if (value &&
                            value.valueDeclaration &&
                            ts.isVariableDeclaration(value.valueDeclaration) &&
                            value.valueDeclaration.initializer) {
                            right = value.valueDeclaration.initializer;
                        }
                    }
                    if (right) {
                        const { properties } = right;
                        if (properties) {
                            propMap = this.getPropMap(properties);
                        }
                    }
                });
                return Object.assign(Object.assign({}, res), propMap);
            }
            const functionStatement = this.getFunctionStatement(statement);
            // Extracting default values from props destructuring
            if (functionStatement && functionStatement.parameters.length) {
                const { name } = functionStatement.parameters[0];
                if (ts.isObjectBindingPattern(name)) {
                    return Object.assign(Object.assign({}, res), this.getPropMap(name.elements));
                }
            }
            return res;
        }, {});
    }
    getLiteralValueFromPropertyAssignment(property) {
        let { initializer } = property;
        // Shorthand properties, so inflect their actual value
        if (!initializer) {
            if (ts.isShorthandPropertyAssignment(property)) {
                const symbol = this.checker.getShorthandAssignmentValueSymbol(property);
                const decl = symbol && symbol.valueDeclaration;
                if (decl && decl.initializer) {
                    initializer = decl.initializer;
                }
            }
        }
        if (!initializer) {
            return undefined;
        }
        // Literal values
        // eslint-disable-next-line default-case
        switch (initializer.kind) {
            case ts.SyntaxKind.FalseKeyword:
                return this.savePropValueAsString ? 'false' : false;
            case ts.SyntaxKind.TrueKeyword:
                return this.savePropValueAsString ? 'true' : true;
            case ts.SyntaxKind.StringLiteral:
                return initializer.text.trim();
            case ts.SyntaxKind.PrefixUnaryExpression:
                return this.savePropValueAsString
                    ? initializer.getFullText().trim()
                    : Number(initializer.getFullText());
            case ts.SyntaxKind.NumericLiteral:
                return this.savePropValueAsString
                    ? `${initializer.text}`
                    : Number(initializer.text);
            case ts.SyntaxKind.NullKeyword:
                return this.savePropValueAsString ? 'null' : null;
            case ts.SyntaxKind.Identifier:
                // can potentially find other identifiers in the source and map those in the future
                return initializer.text === 'undefined'
                    ? 'undefined'
                    : null;
            case ts.SyntaxKind.PropertyAccessExpression: {
                const symbol = this.checker.getSymbolAtLocation(initializer);
                if (symbol && symbol.declarations && symbol.declarations.length) {
                    const declaration = symbol.declarations[0];
                    if (ts.isBindingElement(declaration) ||
                        ts.isPropertyAssignment(declaration)) {
                        return this.getLiteralValueFromPropertyAssignment(declaration);
                    }
                }
            }
        }
        try {
            return initializer.getText();
        }
        catch (e) {
            return null;
        }
    }
    getPropMap(properties) {
        const propMap = properties.reduce((acc, property) => {
            if (ts.isSpreadAssignment(property) || !property.name) {
                return acc;
            }
            const literalValue = this.getLiteralValueFromPropertyAssignment(property);
            const propertyName = getPropertyName(property.name);
            if ((typeof literalValue === 'string' ||
                typeof literalValue === 'number' ||
                typeof literalValue === 'boolean' ||
                literalValue === null) &&
                propertyName !== null) {
                acc[propertyName] = literalValue;
            }
            return acc;
        }, {});
        return propMap;
    }
    getComponentFromExpression(exp) {
        const declaration = exp.valueDeclaration || exp.declarations[0];
        const type = this.checker.getTypeOfSymbolAtLocation(exp, declaration);
        const typeSymbol = type.symbol || type.aliasSymbol;
        if (!typeSymbol) {
            return exp;
        }
        const symbolName = typeSymbol.getName();
        if ((symbolName === 'MemoExoticComponent' ||
            symbolName === 'ForwardRefExoticComponent') &&
            exp.valueDeclaration &&
            ts.isExportAssignment(exp.valueDeclaration) &&
            ts.isCallExpression(exp.valueDeclaration.expression)) {
            const component = this.checker.getSymbolAtLocation(exp.valueDeclaration.expression.arguments[0]);
            if (component) {
                exp = component;
            }
        }
        return exp;
    }
}
exports.Parser = Parser;
function statementIsClassDeclaration(statement) {
    return !!statement.members;
}
function statementIsStatelessWithDefaultProps(statement) {
    const children = statement.getChildren();
    for (const child of children) {
        const { left } = child;
        if (left) {
            const { name } = left;
            if (name && name.escapedText === 'defaultProps') {
                return true;
            }
        }
    }
    return false;
}
function getPropertyName(name) {
    switch (name.kind) {
        case ts.SyntaxKind.NumericLiteral:
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.Identifier:
            return name.text;
        case ts.SyntaxKind.ComputedPropertyName:
            return name.getText();
        default:
            return null;
    }
}
function getTextValueOfClassMember(classDeclaration, memberName) {
    if (!classDeclaration.members) {
        return '';
    }
    const [textValue] = classDeclaration.members
        .filter((member) => ts.isPropertyDeclaration(member))
        .filter((member) => {
        const name = ts.getNameOfDeclaration(member);
        return name && name.text === memberName;
    })
        .map((member) => {
        const property = member;
        return (property.initializer && property.initializer.text);
    });
    return textValue || '';
}
function getTextValueOfFunctionProperty(exp, source, propertyName) {
    const [textValue] = source.statements
        .filter((statement) => ts.isExpressionStatement(statement))
        .filter((statement) => {
        const expr = statement
            .expression;
        return (expr.left &&
            expr.left.name &&
            expr.left.name.escapedText ===
                propertyName);
    })
        .filter((statement) => {
        const expr = statement
            .expression;
        return (expr.left.expression
            .escapedText === exp.getName());
    })
        .filter((statement) => {
        return ts.isStringLiteral(statement
            .expression.right);
    })
        .map((statement) => {
        return statement
            .expression.right.text;
    });
    return textValue || '';
}
function computeComponentName(exp, source) {
    const exportName = exp.getName();
    const statelessDisplayName = getTextValueOfFunctionProperty(exp, source, 'displayName');
    const statefulDisplayName = exp.valueDeclaration &&
        ts.isClassDeclaration(exp.valueDeclaration) &&
        getTextValueOfClassMember(exp.valueDeclaration, 'displayName');
    if (statelessDisplayName || statefulDisplayName) {
        return statelessDisplayName || statefulDisplayName || '';
    }
    if (exportName === 'default' ||
        exportName === '__function' ||
        exportName === 'Stateless' ||
        exportName === 'StyledComponentClass' ||
        exportName === 'StyledComponent' ||
        exportName === 'FunctionComponent' ||
        exportName === 'StatelessComponent' ||
        exportName === 'ForwardRefExoticComponent') {
        return getDefaultExportForFile(source);
    }
    else {
        return exportName;
    }
}
// Default export for a file: named after file
function getDefaultExportForFile(source) {
    const name = path.basename(source.fileName, path.extname(source.fileName));
    const filename = name === 'index' ? path.basename(path.dirname(source.fileName)) : name;
    // JS identifiers must starts with a letter, and contain letters and/or numbers
    // So, you could not take filename as is
    const identifier = filename
        .replace(/^[^A-Z]*/gi, '')
        .replace(/[^A-Z0-9]*/gi, '');
    return identifier.length ? identifier : 'DefaultName';
}
exports.getDefaultExportForFile = getDefaultExportForFile;
//# sourceMappingURL=parser.js.map