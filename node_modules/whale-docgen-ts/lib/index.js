"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withCompilerOptions = exports.withDefaultConfig = exports.parse = exports.defaultOptions = void 0;
const tslib_1 = require("tslib");
const ts = require("typescript");
const WmParser_1 = require("./WmParser");
const TypeParser_1 = require("./TypeParser");
tslib_1.__exportStar(require("./utils/propItemType"), exports);
tslib_1.__exportStar(require("./types"), exports);
tslib_1.__exportStar(require("./WmParser"), exports);
const defaultParserOpts = {};
exports.defaultOptions = {
    jsx: ts.JsxEmit.React,
    module: ts.ModuleKind.CommonJS,
    target: ts.ScriptTarget.Latest,
};
/**
 * Parses a file with default TS options
 * @param filePath component file that should be parsed
 */
function parse(filePathOrPaths, parserOpts = defaultParserOpts) {
    return withCompilerOptions(exports.defaultOptions, parserOpts).parse(filePathOrPaths);
}
exports.parse = parse;
/**
 * Constructs a parser for a default configuration.
 */
function withDefaultConfig(parserOpts = defaultParserOpts) {
    return withCompilerOptions(exports.defaultOptions, parserOpts);
}
exports.withDefaultConfig = withDefaultConfig;
/**
 * Constructs a parser for a specified set of TS compiler options.
 */
function withCompilerOptions(compilerOptions, parserOpts = defaultParserOpts) {
    const parseFn = (filePathOrPaths) => parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts);
    const parseWithProgramProviderFn = (filePathOrPaths, programProvider) => parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts, programProvider);
    return {
        parse: parseFn,
        parseWithProgramProvider: parseWithProgramProviderFn,
    };
}
exports.withCompilerOptions = withCompilerOptions;
function parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts, programProvider) {
    const filePaths = Array.isArray(filePathOrPaths)
        ? filePathOrPaths
        : [filePathOrPaths];
    const program = programProvider
        ? programProvider(filePaths, compilerOptions)
        : ts.createProgram(filePaths, compilerOptions);
    const checker = program.getTypeChecker();
    const parser = new WmParser_1.WmParser(program, parserOpts);
    return filePaths
        .map((filePath) => program.getSourceFile(filePath))
        .filter((sourceFile) => sourceFile)
        .reduce((docs, sourceFile) => {
        const moduleSymbol = checker.getSymbolAtLocation(sourceFile);
        if (moduleSymbol) {
            // 遍历导出的组件
            checker.getExportsOfModule(moduleSymbol).forEach((exp) => {
                const doc = parser.getWmComponentDoc(exp, sourceFile);
                if (doc) {
                    docs.push(doc);
                }
                /**
                 * 子组件文档，如
                 *
                 * class Button extends React.Component {
                 *  static Group = ButtonGroup;
                 * }
                 * export default Object.assign(Button, {
                 *  Group2: ButtonGroup;
                 * });
                 */
                docs.push(...checker
                    .getTypeOfSymbolAtLocation(exp, TypeParser_1.getValueDeclaration(exp))
                    .getProperties()
                    .map((symbol) => parser.getSubWmComponentDoc(exp, symbol, sourceFile))
                    .filter((vo) => vo));
            });
        }
        return docs;
    }, []);
}
//# sourceMappingURL=index.js.map