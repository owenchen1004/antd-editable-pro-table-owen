import escapeText from './escapeText';
import styleToCSS from './styleToCSS';
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8; // For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var OMITTED_CLOSE_TAGS = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};
/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */

function quoteAttribute(prop, value) {
  return prop + "=\"" + escapeText(value) + "\"";
}

function createOpenTagMarkup(tagName, style, attributes) {
  var tagOpen = "<" + tagName;

  if (style) {
    var styleAttr = styleToCSS(style);

    if (styleAttr) {
      tagOpen += ' ' + quoteAttribute('style', styleAttr);
    }
  }

  if (attributes) {
    for (var attrKey in attributes) {
      tagOpen += ' ' + quoteAttribute(attrKey, attributes[attrKey]);
    }
  }

  return tagOpen;
}

var Serializer = /*#__PURE__*/function () {
  function Serializer(node) {
    this.html = '';
    this.startNode = node;
  }

  var _proto = Serializer.prototype;

  _proto.toJSON = function toJSON() {
    return this.toJSONChildren(this.startNode, true);
  };

  _proto.toJSONChildren = function toJSONChildren(parentNode, isTopLevel) {
    var childNodes = parentNode.childNodes;

    if (childNodes) {
      var children = [];

      for (var i = 0, len = childNodes.length; i < len; i++) {
        var node = childNodes[i];

        if (node.nodeType === ELEMENT_NODE) {
          var json = {
            tagName: node.tagName
          };
          var childrenJSON = this.toJSONChildren(node);

          if (childrenJSON) {
            json.children = childrenJSON;
          }

          if (Object.keys(node.style).length > 0) {
            json.style = node.style;
          }

          if (Object.keys(node.attributes).length > 0) {
            json.attributes = node.attributes;
          }

          if (Object.keys(node.eventListeners).length > 0) {
            json.eventListeners = node.eventListeners;
          }

          children.push(json);
        } else if (node.nodeType === TEXT_NODE) {
          var text = node.data;

          if (typeof text === 'string') {
            text = escapeText(text);
          }

          children.push(text);
        }
      } // Do not wrap array when only child in top-level


      if (isTopLevel && children.length === 1) {
        return children[0];
      }

      return children.length === 0 ? null : children;
    }

    return null;
  };

  _proto.serialize = function serialize() {
    this.serializeChildren(this.startNode);
    return this.html;
  };

  _proto.serializeChildren = function serializeChildren(parentNode) {
    var childNodes = parentNode.childNodes;

    if (childNodes) {
      for (var i = 0, len = childNodes.length; i < len; i++) {
        var node = childNodes[i];

        if (node.nodeType === ELEMENT_NODE) {
          var tagName = node.tagName.toLowerCase();
          this.html += createOpenTagMarkup(tagName, node.style, node.attributes);

          if (OMITTED_CLOSE_TAGS[tagName]) {
            this.html += '/>';
          } else {
            this.html += '>';

            if (node.__html) {
              this.html += node.__html;
            } else {
              this.serializeChildren(node);
            }

            this.html += "</" + tagName + ">";
          }
        } else if (node.nodeType === TEXT_NODE) {
          this.html += escapeText(node.data);
        } else if (node.nodeType === COMMENT_NODE) {
          this.html += '<!--' + node.data + '-->';
        }
      }
    }
  };

  return Serializer;
}();

export default Serializer;