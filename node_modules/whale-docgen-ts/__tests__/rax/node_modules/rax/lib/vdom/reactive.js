"use strict";

exports.__esModule = true;
exports.default = void 0;

var _host = _interopRequireDefault(require("./host"));

var _component = _interopRequireDefault(require("./component"));

var _invokeFunctionsWithContext = _interopRequireDefault(require("../invokeFunctionsWithContext"));

var _error = require("../error");

var _constant = require("../constant");

var _types = require("../types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var RE_RENDER_LIMIT = 24;
/**
 * Functional Reactive Component Class Wrapper
 */

var ReactiveComponent = /*#__PURE__*/function (_Component) {
  _inheritsLoose(ReactiveComponent, _Component);

  function ReactiveComponent(pureRender, ref) {
    var _this;

    _this = _Component.call(this) || this; // Marked ReactiveComponent.

    _this.__isReactiveComponent = true; // A pure function

    _this.__render = pureRender;
    _this.__hookID = 0; // Number of rerenders

    _this.__reRenders = 0;
    _this.__hooks = {}; // Is render scheduled

    _this.__isScheduled = false;
    _this.__shouldUpdate = false;
    _this.__children = null;
    _this.__contexts = {}; // Handles store

    _this.didMount = [];
    _this.didUpdate = [];
    _this.willUnmount = [];
    _this.state = _types.EMPTY_OBJECT;

    if (pureRender._forwardRef) {
      _this.__prevForwardRef = _this._forwardRef = ref;
    }

    var compares = pureRender.__compares;

    if (compares) {
      _this.shouldComponentUpdate = function (nextProps) {
        // Process composed compare
        var arePropsEqual = true; // Compare push in and pop out

        for (var i = compares.length - 1; i > -1; i--) {
          if (arePropsEqual = compares[i](_this.props, nextProps)) {
            break;
          }
        }

        return !arePropsEqual || _this.__prevForwardRef !== _this._forwardRef;
      };
    }

    return _this;
  }

  var _proto = ReactiveComponent.prototype;

  _proto.getHooks = function getHooks() {
    return this.__hooks;
  };

  _proto.getHookID = function getHookID() {
    return ++this.__hookID;
  };

  _proto.useContext = function useContext(context) {
    var _this2 = this;

    var contextID = context._contextID;
    var contextItem = this.__contexts[contextID];

    if (!contextItem) {
      var provider = context.__getNearestParentProvider(this);

      contextItem = this.__contexts[contextID] = {
        __provider: provider
      };

      if (provider) {
        var handleContextChange = function handleContextChange(value) {
          // Check the last value that maybe alread rerender
          // avoid rerender twice when provider value changed
          if (contextItem.__lastValue !== value) {
            _this2.__shouldUpdate = true;

            _this2.__update();
          }
        };

        provider.__on(handleContextChange);

        this.willUnmount.push(function () {
          return provider.__off(handleContextChange);
        });
      }
    }

    return contextItem.__lastValue = contextItem.__provider ? contextItem.__provider.getValue() : context._defaultValue;
  };

  _proto.componentWillMount = function componentWillMount() {
    this.__shouldUpdate = true;
  };

  _proto.componentDidMount = function componentDidMount() {
    (0, _invokeFunctionsWithContext.default)(this.didMount);
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps() {
    this.__shouldUpdate = true;
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    (0, _invokeFunctionsWithContext.default)(this.didUpdate);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    (0, _invokeFunctionsWithContext.default)(this.willUnmount);
  };

  _proto.__update = function __update() {
    this[_constant.INTERNAL].__isPendingForceUpdate = true;
    this.setState(_types.EMPTY_OBJECT);
  };

  _proto.render = function render() {
    if (process.env.NODE_ENV !== 'production') {
      _host.default.measurer && _host.default.measurer.beforeRender();
    }

    this.__hookID = 0;
    this.__reRenders = 0;
    this.__isScheduled = false;

    var children = this.__render(this.props, this._forwardRef ? this._forwardRef : this.context);

    while (this.__isScheduled) {
      this.__reRenders++;

      if (this.__reRenders > RE_RENDER_LIMIT) {
        if (process.env.NODE_ENV !== 'production') {
          throw new Error('Too many re-renders, the number of renders is limited to prevent an infinite loop.');
        } else {
          (0, _error.throwMinifiedError)(4);
        }
      }

      this.__hookID = 0;
      this.__isScheduled = false;
      children = this.__render(this.props, this._forwardRef ? this._forwardRef : this.context);
    }

    if (this.__shouldUpdate) {
      this.__children = children;
      this.__shouldUpdate = false;
    }

    return this.__children;
  };

  return ReactiveComponent;
}(_component.default);

exports.default = ReactiveComponent;