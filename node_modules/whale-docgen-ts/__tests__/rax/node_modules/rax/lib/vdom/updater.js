"use strict";

exports.__esModule = true;
exports.default = void 0;

var _host = _interopRequireDefault(require("./host"));

var _scheduler = require("./scheduler");

var _constant = require("../constant");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Dirty components store
var dirtyComponents = [];

function getPendingCallbacks(internal) {
  return internal.__pendingCallbacks;
}

function setPendingCallbacks(internal, callbacks) {
  return internal.__pendingCallbacks = callbacks;
}

function getPendingStateQueue(internal) {
  return internal.__pendingStateQueue;
}

function setPendingStateQueue(internal, partialState) {
  return internal.__pendingStateQueue = partialState;
}

function enqueueCallback(internal, callback) {
  var callbackQueue = getPendingCallbacks(internal) || setPendingCallbacks(internal, []);
  callbackQueue.push(callback);
}

function enqueueState(internal, partialState) {
  var stateQueue = getPendingStateQueue(internal) || setPendingStateQueue(internal, []);
  stateQueue.push(partialState);
}

function runUpdate(component) {
  var internal = component[_constant.INTERNAL];

  if (!internal) {
    return;
  }

  _host.default.__isUpdating = true;
  var prevElement = internal.__currentElement;
  var prevUnmaskedContext = internal._context;
  var nextUnmaskedContext = internal.__penddingContext || prevUnmaskedContext;
  internal.__penddingContext = undefined;

  if (getPendingStateQueue(internal) || internal.__isPendingForceUpdate) {
    internal.__updateComponent(prevElement, prevElement, prevUnmaskedContext, nextUnmaskedContext);

    (0, _scheduler.flushLayout)();
  }

  _host.default.__isUpdating = false;
}

function mountOrderComparator(c1, c2) {
  return c2[_constant.INTERNAL]._mountID - c1[_constant.INTERNAL]._mountID;
}

function performUpdate() {
  if (_host.default.__isUpdating) {
    return (0, _scheduler.schedule)(performUpdate);
  }

  var component;
  var dirties = dirtyComponents;

  if (dirties.length > 0) {
    // Before next render, we will flush all the effects
    (0, _scheduler.flushEffect)();
    dirtyComponents = []; // Since reconciling a component higher in the owner hierarchy usually (not
    // always -- see shouldComponentUpdate()) will reconcile children, reconcile
    // them before their children by sorting the array.

    if (dirties.length > 1) {
      dirties = dirties.filter(function (c) {
        return !!c[_constant.INTERNAL];
      }).sort(mountOrderComparator);
    }

    while (component = dirties.pop()) {
      runUpdate(component);
    }
  }
}

function scheduleUpdate(component, shouldAsyncUpdate) {
  if (dirtyComponents.indexOf(component) < 0) {
    dirtyComponents.push(component);
  }

  if (shouldAsyncUpdate) {
    // If have been scheduled before, don't not need schedule again
    if (dirtyComponents.length > 1) {
      return;
    }

    (0, _scheduler.schedule)(performUpdate);
  } else {
    performUpdate();
  }
}

function requestUpdate(component, partialState, callback) {
  var internal = component[_constant.INTERNAL];

  if (!internal) {
    return;
  }

  if (callback) {
    enqueueCallback(internal, callback);
  }

  var hasComponentRendered = internal[_constant.RENDERED_COMPONENT]; // setState

  if (partialState) {
    enqueueState(internal, partialState); // State pending when request update in componentWillMount and componentWillReceiveProps,
    // isPendingState default is false value (false or null) and set to true after componentWillReceiveProps,
    // _renderedComponent is null when componentWillMount exec.

    if (!internal.__isPendingState && hasComponentRendered) {
      scheduleUpdate(component, true);
    }
  } else {
    // forceUpdate
    internal.__isPendingForceUpdate = true;

    if (hasComponentRendered) {
      scheduleUpdate(component);
    }
  }
}

var Updater = {
  setState: function setState(component, partialState, callback) {
    // Flush all effects first before update state
    if (!_host.default.__isUpdating) {
      (0, _scheduler.flushEffect)();
    }

    requestUpdate(component, partialState, callback);
  },
  forceUpdate: function forceUpdate(component, callback) {
    requestUpdate(component, null, callback);
  }
};
var _default = Updater;
exports.default = _default;