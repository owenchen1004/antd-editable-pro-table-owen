"use strict";

exports.__esModule = true;
exports.default = performInSandbox;
exports.handleError = handleError;

var _getNearestParent = _interopRequireDefault(require("./getNearestParent"));

var _scheduler = require("./scheduler");

var _constant = require("../constant");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function performInSandbox(fn, instance, callback) {
  try {
    return fn();
  } catch (e) {
    if (callback) {
      callback(e);
    } else {
      handleError(instance, e);
    }
  }
}
/**
 * A class component becomes an error boundary if 
 * it defines either (or both) of the lifecycle methods static getDerivedStateFromError() or componentDidCatch().
 * Use static getDerivedStateFromError() to render a fallback UI after an error has been thrown.
 * Use componentDidCatch() to log error information.
 * @param {*} instance 
 * @param {*} error 
 */


function handleError(instance, error) {
  var boundary = (0, _getNearestParent.default)(instance, function (parent) {
    return parent.componentDidCatch || parent.constructor && parent.constructor.getDerivedStateFromError;
  });

  if (boundary) {
    (0, _scheduler.scheduleLayout)(function () {
      var boundaryInternal = boundary[_constant.INTERNAL]; // Should not attempt to recover an unmounting error boundary

      if (boundaryInternal) {
        performInSandbox(function () {
          if (boundary.componentDidCatch) {
            boundary.componentDidCatch(error);
          } // Update state to the next render to show the fallback UI.


          if (boundary.constructor && boundary.constructor.getDerivedStateFromError) {
            var state = boundary.constructor.getDerivedStateFromError();
            boundary.setState(state);
          }
        }, boundaryInternal.__parentInstance);
      }
    });
  } else {
    // Do not break when error happens
    (0, _scheduler.scheduler)(function () {
      throw error;
    }, 0);
  }
}