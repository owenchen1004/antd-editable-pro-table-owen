"use strict";

exports.__esModule = true;
exports.default = getPrevSiblingNativeNode;

var _host = _interopRequireDefault(require("./host"));

var _types = require("../types");

var _constant = require("../constant");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This function is usually been used to find the closet previous sibling native node of FragmentComponent.
 * FragmentComponent does not have a native node in the DOM tree, so when it is replaced, the new node has no corresponding location to insert.
 * So we need to look forward from the current mount position of the FragmentComponent to the nearest component which have the native node.
 * @param component
 * @return nativeNode
 */
function getPrevSiblingNativeNode(component) {
  var parent = component;

  while (parent = component.__parentInstance && component.__parentInstance[_constant.INTERNAL]) {
    if (parent instanceof _host.default.__Composite) {
      component = parent;
      continue;
    }

    var keys = Object.keys(parent.__renderedChildren); // Find previous sibling native node from current mount index

    for (var i = component.__mountIndex - 1; i >= 0; i--) {
      var nativeNode = parent.__renderedChildren[keys[i]].__getNativeNode(); // Fragment component always return array


      if ((0, _types.isArray)(nativeNode)) {
        if (nativeNode.length > 0) {
          // Get the last one
          return nativeNode[nativeNode.length - 1];
        }
      } else {
        // Others maybe native node or empty node
        return nativeNode;
      }
    } // Find parent over parent


    if (parent instanceof _host.default.__Fragment) {
      component = parent;
    } else {
      return null;
    }
  }
}