"use strict";

exports.__esModule = true;
exports.default = void 0;

var _reactive = _interopRequireDefault(require("./reactive"));

var _updater = _interopRequireDefault(require("./updater"));

var _host = _interopRequireDefault(require("./host"));

var _ref = require("./ref");

var _instantiateComponent = _interopRequireDefault(require("./instantiateComponent"));

var _shouldUpdateComponent = _interopRequireDefault(require("./shouldUpdateComponent"));

var _shallowEqual = _interopRequireDefault(require("./shallowEqual"));

var _base = _interopRequireDefault(require("./base"));

var _getPrevSiblingNativeNode = _interopRequireDefault(require("./getPrevSiblingNativeNode"));

var _performInSandbox = _interopRequireDefault(require("./performInSandbox"));

var _toArray = _interopRequireDefault(require("../toArray"));

var _scheduler = require("./scheduler");

var _types = require("../types");

var _assign = _interopRequireDefault(require("../assign"));

var _constant = require("../constant");

var _invokeFunctionsWithContext = _interopRequireDefault(require("../invokeFunctionsWithContext"));

var _validateChildKeys = _interopRequireDefault(require("../validateChildKeys"));

var _error = require("../error");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var measureLifeCycle;

if (process.env.NODE_ENV !== 'production') {
  measureLifeCycle = function measureLifeCycle(callback, instanceID, type) {
    _host.default.measurer && _host.default.measurer.beforeLifeCycle(instanceID, type);
    callback();
    _host.default.measurer && _host.default.measurer.afterLifeCycle(instanceID, type);
  };
}

function scheduleLayoutInSandbox(fn, instance) {
  (0, _scheduler.scheduleLayout)(function () {
    (0, _performInSandbox.default)(fn, instance);
  });
}

function scheduleLayoutCallbacksInSandbox(callbacks, instance) {
  if (callbacks) {
    scheduleLayoutInSandbox(function () {
      (0, _invokeFunctionsWithContext.default)(callbacks, instance);
    }, instance);
  }
}
/**
 * Composite Component
 */


var CompositeComponent = /*#__PURE__*/function (_BaseComponent) {
  _inheritsLoose(CompositeComponent, _BaseComponent);

  function CompositeComponent() {
    return _BaseComponent.apply(this, arguments) || this;
  }

  var _proto = CompositeComponent.prototype;

  _proto.__mountComponent = function __mountComponent(parent, parentInstance, context, nativeNodeMounter) {
    var _this = this;

    this.__initComponent(parent, parentInstance, context);

    if (process.env.NODE_ENV !== 'production') {
      this._updateCount = 0;
      _host.default.measurer && _host.default.measurer.beforeMountComponent(this._mountID, this);
    }

    var currentElement = this.__currentElement;
    var Component = currentElement.type;
    var ref = currentElement.ref;
    var publicProps = currentElement.props;
    var componentPrototype = Component.prototype; // Context process

    var publicContext = this.__processContext(context); // Initialize the public class


    var instance;
    var renderedElement;
    (0, _performInSandbox.default)(function () {
      if (componentPrototype && componentPrototype.render) {
        // Class Component instance
        instance = new Component(publicProps, publicContext);
      } else if ((0, _types.isFunction)(Component)) {
        // Functional reactive component with hooks
        instance = new _reactive.default(Component, ref);
      } else {
        if (process.env.NODE_ENV !== 'production') {
          (0, _error.throwError)('Invalid component type, expected a class or function component.', Component);
        } else {
          (0, _error.throwMinifiedError)(6, Component);
        }
      }
    }, parentInstance);

    if (!instance) {
      return;
    } // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.


    instance.props = publicProps;
    instance.context = publicContext;
    instance.refs = {}; // Inject the updater into instance

    instance.updater = _updater.default;
    instance[_constant.INTERNAL] = this;
    this[_constant.INSTANCE] = instance; // Init state, must be set to an object or null

    var initialState = instance.state;

    if (initialState === undefined) {
      // TODO clone the state?
      instance.state = initialState = null;
    }

    if (instance.componentWillMount) {
      (0, _performInSandbox.default)(function () {
        if (process.env.NODE_ENV !== 'production') {
          measureLifeCycle(function () {
            instance.componentWillMount();
          }, _this._mountID, 'componentWillMount');
        } else {
          instance.componentWillMount();
        }
      }, instance);
    }

    _host.default.owner = this; // Process pending state when call setState in componentWillMount

    instance.state = this.__processPendingState(publicProps, publicContext);
    var callbacks = this.__pendingCallbacks;
    this.__pendingCallbacks = null;
    (0, _performInSandbox.default)(function () {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCycle(function () {
          renderedElement = instance.render();
        }, _this._mountID, 'render');
      } else {
        renderedElement = instance.render();
      }
    }, instance);

    if (process.env.NODE_ENV !== 'production') {
      (0, _validateChildKeys.default)(renderedElement, this.__currentElement.type);
    }

    _host.default.owner = null;
    this[_constant.RENDERED_COMPONENT] = (0, _instantiateComponent.default)(renderedElement);

    this[_constant.RENDERED_COMPONENT].__mountComponent(this._parent, instance, this.__processChildContext(context), nativeNodeMounter);

    if (!currentElement.type._forwardRef && ref) {
      (0, _ref.attachRef)(currentElement._owner, ref, this);
    }

    if (instance.componentDidMount) {
      scheduleLayoutInSandbox(function () {
        if (process.env.NODE_ENV !== 'production') {
          measureLifeCycle(function () {
            instance.componentDidMount();
          }, _this._mountID, 'componentDidMount');
        } else {
          instance.componentDidMount();
        }
      }, instance);
    } // Trigger setState callback


    scheduleLayoutCallbacksInSandbox(callbacks, instance);

    if (process.env.NODE_ENV !== 'production') {
      (0, _scheduler.scheduleLayout)(function () {
        _host.default.reconciler.mountComponent(_this);

        _host.default.measurer && _host.default.measurer.afterMountComponent(_this._mountID);
      });
    }

    return instance;
  };

  _proto.unmountComponent = function unmountComponent(shouldNotRemoveChild) {
    var instance = this[_constant.INSTANCE]; // Unmounting a composite component maybe not complete mounted
    // when throw error in component constructor stage

    if (instance && instance.componentWillUnmount) {
      (0, _performInSandbox.default)(function () {
        instance.componentWillUnmount();
      }, instance);
    }

    if (this[_constant.RENDERED_COMPONENT] != null) {
      var currentElement = this.__currentElement;
      var ref = currentElement.ref;

      if (!currentElement.type._forwardRef && ref) {
        (0, _ref.detachRef)(currentElement._owner, ref, this);
      }

      this[_constant.RENDERED_COMPONENT].unmountComponent(shouldNotRemoveChild);

      this[_constant.RENDERED_COMPONENT] = null;
    } // Reset pending fields
    // Even if this component is scheduled for another async update,
    // it would still be ignored because these fields are reset.


    this.__pendingStateQueue = null;
    this.__isPendingForceUpdate = false;

    this.__destoryComponent();
  }
  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   */
  ;

  _proto.__processContext = function __processContext(context) {
    var maskedContext = {};
    var Component = this.__currentElement.type;
    var contextTypes = Component.contextTypes;

    if (contextTypes) {
      for (var contextName in contextTypes) {
        maskedContext[contextName] = context[contextName];
      }
    }

    return maskedContext;
  };

  _proto.__processChildContext = function __processChildContext(currentContext) {
    var instance = this[_constant.INSTANCE]; // The getChildContext method context should be current instance

    var childContext = instance.getChildContext && instance.getChildContext();

    if (childContext) {
      return (0, _assign.default)({}, currentContext, childContext);
    }

    return currentContext;
  };

  _proto.__processPendingState = function __processPendingState(props, context) {
    var instance = this[_constant.INSTANCE];
    var queue = this.__pendingStateQueue;

    if (!queue) {
      return instance.state;
    } // Reset pending queue


    this.__pendingStateQueue = null;
    var nextState = (0, _assign.default)({}, instance.state);

    for (var i = 0; i < queue.length; i++) {
      var partial = queue[i];
      (0, _assign.default)(nextState, (0, _types.isFunction)(partial) ? partial.call(instance, nextState, props, context) : partial);
    }

    return nextState;
  };

  _proto.__updateComponent = function __updateComponent(prevElement, nextElement, prevUnmaskedContext, nextUnmaskedContext) {
    var _this2 = this;

    var instance = this[_constant.INSTANCE]; // Maybe update component that has already been unmounted or failed mount.

    if (!instance) {
      return;
    }

    (0, _performInSandbox.default)(function () {
      if (process.env.NODE_ENV !== 'production') {
        _host.default.measurer && _host.default.measurer.beforeUpdateComponent(_this2._mountID, _this2);
      }

      var willReceive;
      var nextContext;
      var nextProps; // Determine if the context has changed or not

      if (_this2._context === nextUnmaskedContext) {
        nextContext = instance.context;
      } else {
        nextContext = _this2.__processContext(nextUnmaskedContext);
        willReceive = true;
      } // Distinguish between a props update versus a simple state update
      // Skip checking prop types again -- we don't read component.props to avoid
      // warning for DOM component props in this upgrade


      nextProps = nextElement.props;

      if (prevElement !== nextElement) {
        willReceive = true;
      }

      if (willReceive && instance.componentWillReceiveProps) {
        // Calling this.setState() within componentWillReceiveProps will not trigger an additional render.
        _this2.__isPendingState = true;
        instance.componentWillReceiveProps(nextProps, nextContext);
        _this2.__isPendingState = false;
      } // Update refs


      if (_this2.__currentElement.type._forwardRef) {
        instance.__prevForwardRef = prevElement.ref;
        instance._forwardRef = nextElement.ref;
      } else {
        (0, _ref.updateRef)(prevElement, nextElement, _this2);
      } // Shoud update default


      var shouldUpdate = true;
      var prevProps = instance.props;
      var prevState = instance.state; // TODO: could delay execution processPendingState

      var nextState = _this2.__processPendingState(nextProps, nextContext);

      var callbacks = _this2.__pendingCallbacks;
      _this2.__pendingCallbacks = null; // ShouldComponentUpdate is not called when forceUpdate is used

      if (!_this2.__isPendingForceUpdate) {
        if (instance.shouldComponentUpdate) {
          shouldUpdate = instance.shouldComponentUpdate(nextProps, nextState, nextContext);
        } else if (instance.__isPureComponent) {
          // Pure Component
          shouldUpdate = !(0, _shallowEqual.default)(prevProps, nextProps) || !(0, _shallowEqual.default)(prevState, nextState);
        }
      }

      if (shouldUpdate) {
        _this2.__isPendingForceUpdate = false; // Will set `this.props`, `this.state` and `this.context`.

        var prevContext = instance.context; // Cannot use this.setState() in componentWillUpdate.
        // If need to update state in response to a prop change, use componentWillReceiveProps instead.

        if (instance.componentWillUpdate) {
          instance.componentWillUpdate(nextProps, nextState, nextContext);
        } // Replace with next


        _this2.__currentElement = nextElement;
        _this2._context = nextUnmaskedContext;
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = nextContext;

        _this2.__updateRenderedComponent(nextUnmaskedContext);

        if (instance.componentDidUpdate) {
          scheduleLayoutInSandbox(function () {
            instance.componentDidUpdate(prevProps, prevState, prevContext);
          }, instance);
        }

        if (process.env.NODE_ENV !== 'production') {
          // Calc update count.
          _this2._updateCount++;
        }
      } else {
        // If it's determined that a component should not update, we still want
        // to set props and state but we shortcut the rest of the update.
        _this2.__currentElement = nextElement;
        _this2._context = nextUnmaskedContext;
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = nextContext;
      }

      scheduleLayoutCallbacksInSandbox(callbacks, instance);

      if (process.env.NODE_ENV !== 'production') {
        (0, _scheduler.scheduleLayout)(function () {
          _host.default.measurer && _host.default.measurer.afterUpdateComponent(_this2._mountID);

          _host.default.reconciler.receiveComponent(_this2);
        });
      }
    }, instance);
  }
  /**
   * Call the component's `render` method and update the DOM accordingly.
   */
  ;

  _proto.__updateRenderedComponent = function __updateRenderedComponent(context) {
    var prevRenderedComponent = this[_constant.RENDERED_COMPONENT];
    var prevRenderedElement = prevRenderedComponent.__currentElement;
    var instance = this[_constant.INSTANCE];
    var nextRenderedElement;
    _host.default.owner = this;

    if (process.env.NODE_ENV !== 'production') {
      measureLifeCycle(function () {
        nextRenderedElement = instance.render();
      }, this._mountID, 'render');
    } else {
      nextRenderedElement = instance.render();
    }

    _host.default.owner = null;

    if ((0, _shouldUpdateComponent.default)(prevRenderedElement, nextRenderedElement)) {
      var prevRenderedUnmaskedContext = prevRenderedComponent._context;

      var nextRenderedUnmaskedContext = this.__processChildContext(context); // If getChildContext existed and invoked when component updated that will make
      // prevRenderedUnmaskedContext not equal nextRenderedUnmaskedContext under the tree


      if (prevRenderedElement !== nextRenderedElement || prevRenderedUnmaskedContext !== nextRenderedUnmaskedContext) {
        // If element type is illegal catch the error
        prevRenderedComponent.__updateComponent(prevRenderedElement, nextRenderedElement, prevRenderedUnmaskedContext, nextRenderedUnmaskedContext);
      }

      if (process.env.NODE_ENV !== 'production') {
        _host.default.measurer && _host.default.measurer.recordOperation({
          instanceID: this._mountID,
          type: 'update component',
          payload: {}
        });
      }
    } else {
      var lastNativeNode = null;

      var prevNativeNode = prevRenderedComponent.__getNativeNode(); // Only prevNativeNode is empty fragment should find the prevSlibingNativeNode
      // And current root component is fragment, but not need find the prevSlibingNativeNode when init mounting


      if ((0, _types.isArray)(prevNativeNode) && prevNativeNode.length === 0 && instance.__rootID == null) {
        lastNativeNode = (0, _getPrevSiblingNativeNode.default)(prevRenderedComponent);
      }

      prevRenderedComponent.unmountComponent(true);
      this[_constant.RENDERED_COMPONENT] = (0, _instantiateComponent.default)(nextRenderedElement);

      this[_constant.RENDERED_COMPONENT].__mountComponent(this._parent, instance, this.__processChildContext(context), function (newNativeNode, parent) {
        var driver = _host.default.driver;
        prevNativeNode = (0, _toArray.default)(prevNativeNode);
        newNativeNode = (0, _toArray.default)(newNativeNode); // If the new length large then prev

        for (var i = 0; i < newNativeNode.length; i++) {
          var nativeNode = newNativeNode[i];

          if (prevNativeNode[i]) {
            driver.replaceChild(nativeNode, prevNativeNode[i]);
          } else if (lastNativeNode) {
            driver.insertAfter(nativeNode, lastNativeNode);
          } else {
            driver.appendChild(nativeNode, parent);
          }

          lastNativeNode = nativeNode;
        } // If the new length less then prev


        for (var _i = newNativeNode.length; _i < prevNativeNode.length; _i++) {
          driver.removeChild(prevNativeNode[_i]);
        }
      });
    }
  };

  _proto.__getNativeNode = function __getNativeNode() {
    var renderedComponent = this[_constant.RENDERED_COMPONENT];

    if (renderedComponent) {
      return renderedComponent.__getNativeNode();
    }
  };

  _proto.__getPublicInstance = function __getPublicInstance() {
    var instance = this[_constant.INSTANCE]; // The functional components cannot be given refs

    if (instance.__isReactiveComponent) return null;
    return instance;
  };

  return CompositeComponent;
}(_base.default);

var _default = CompositeComponent;
exports.default = _default;