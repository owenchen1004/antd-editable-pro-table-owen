"use strict";

exports.__esModule = true;
exports.useState = useState;
exports.useContext = useContext;
exports.useEffect = useEffect;
exports.useLayoutEffect = useLayoutEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useRef = useRef;
exports.useCallback = useCallback;
exports.useMemo = useMemo;
exports.useReducer = useReducer;

var _host = _interopRequireDefault(require("./vdom/host"));

var _scheduler = require("./vdom/scheduler");

var _shallowEqual = require("./vdom/shallowEqual");

var _types = require("./types");

var _error = require("./error");

var _constant = require("./constant");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getCurrentInstance() {
  return _host.default.owner && _host.default.owner[_constant.INSTANCE];
}

function getCurrentRenderingInstance() {
  var currentInstance = getCurrentInstance();

  if (currentInstance) {
    return currentInstance;
  } else {
    if (process.env.NODE_ENV !== 'production') {
      (0, _error.throwError)('Hooks called outside a component, or multiple version of Rax are used.');
    } else {
      (0, _error.throwMinifiedError)(1);
    }
  }
}

function areInputsEqual(inputs, prevInputs) {
  if ((0, _types.isNull)(prevInputs) || inputs.length !== prevInputs.length) {
    return false;
  }

  for (var i = 0; i < inputs.length; i++) {
    if ((0, _shallowEqual.is)(inputs[i], prevInputs[i])) {
      continue;
    }

    return false;
  }

  return true;
}

function useState(initialState) {
  var currentInstance = getCurrentRenderingInstance();
  var hookID = currentInstance.getHookID();
  var hooks = currentInstance.getHooks();

  if (!hooks[hookID]) {
    // If the initial state is the result of an expensive computation,
    // you may provide a function instead for lazy initial state.
    if ((0, _types.isFunction)(initialState)) {
      initialState = initialState();
    }

    var setState = function setState(newState) {
      // Flush all effects first before update state
      if (!_host.default.__isUpdating) {
        (0, _scheduler.flushEffect)();
      }

      var hook = hooks[hookID];
      var eagerState = hook[2]; // function updater

      if ((0, _types.isFunction)(newState)) {
        newState = newState(eagerState);
      }

      if (!(0, _shallowEqual.is)(newState, eagerState)) {
        // Current instance is in render update phase.
        // After this one render finish, will containue run.
        hook[2] = newState;

        if (getCurrentInstance() === currentInstance) {
          // Marked as is scheduled that could finish hooks.
          currentInstance.__isScheduled = true;
        } else {
          currentInstance.__update();
        }
      }
    };

    hooks[hookID] = [initialState, setState, initialState];
  }

  var hook = hooks[hookID];

  if (!(0, _shallowEqual.is)(hook[0], hook[2])) {
    hook[0] = hook[2];
    currentInstance.__shouldUpdate = true;
  }

  return hook;
}

function useContext(context) {
  var currentInstance = getCurrentRenderingInstance();
  return currentInstance.useContext(context);
}

function useEffect(effect, inputs) {
  useEffectImpl(effect, inputs, true);
}

function useLayoutEffect(effect, inputs) {
  useEffectImpl(effect, inputs);
}

function useEffectImpl(effect, inputs, defered) {
  var currentInstance = getCurrentRenderingInstance();
  var hookID = currentInstance.getHookID();
  var hooks = currentInstance.getHooks();
  inputs = inputs === undefined ? null : inputs;

  if (!hooks[hookID]) {
    var __create = function __create(immediately) {
      if (!immediately && defered) return (0, _scheduler.scheduleEffect)(function () {
        return __create(true);
      });
      var current = __create.current;

      if (current) {
        __destory.current = current();
        __create.current = null;

        if (process.env.NODE_ENV !== 'production') {
          var currentDestory = __destory.current;

          if (currentDestory !== undefined && typeof currentDestory !== 'function') {
            var msg;

            if (currentDestory === null) {
              msg = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';
            } else if (typeof currentDestory.then === 'function') {
              msg = '\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useEffect(() => {\n' + '  async function fetchData() {\n' + '    // You can await here\n' + '    const response = await MyAPI.getData(someId);\n' + '    // ...\n' + '  }\n' + '  fetchData();\n' + '}, [someId]); // Or [] if effect doesn\'t need props or state.';
            } else {
              msg = ' You returned: ' + currentDestory;
            }

            (0, _error.warning)('An effect function must not return anything besides a function, ' + 'which is used for clean-up.' + msg);
          }
        }
      }
    };

    var __destory = function __destory(immediately) {
      if (!immediately && defered) return (0, _scheduler.scheduleEffect)(function () {
        return __destory(true);
      });
      var current = __destory.current;

      if (current) {
        current();
        __destory.current = null;
      }
    };

    __create.current = effect;
    hooks[hookID] = {
      __create: __create,
      __destory: __destory,
      __prevInputs: inputs,
      __inputs: inputs
    };
    currentInstance.didMount.push(__create);
    currentInstance.willUnmount.push(function () {
      return __destory(true);
    });
    currentInstance.didUpdate.push(function () {
      var _hooks$hookID = hooks[hookID],
          __prevInputs = _hooks$hookID.__prevInputs,
          __inputs = _hooks$hookID.__inputs,
          __create = _hooks$hookID.__create;

      if (__inputs == null || !areInputsEqual(__inputs, __prevInputs)) {
        __destory();

        __create();
      }
    });
  } else {
    var hook = hooks[hookID];
    var _create = hook.__create,
        prevInputs = hook.__inputs;
    hook.__inputs = inputs;
    hook.__prevInputs = prevInputs;
    _create.current = effect;
  }
}

function useImperativeHandle(ref, create, inputs) {
  var nextInputs = (0, _types.isArray)(inputs) ? inputs.concat([ref]) : null;
  useLayoutEffect(function () {
    if ((0, _types.isFunction)(ref)) {
      ref(create());
      return function () {
        return ref(null);
      };
    } else if (ref != null) {
      ref.current = create();
      return function () {
        ref.current = null;
      };
    }
  }, nextInputs);
}

function useRef(initialValue) {
  var currentInstance = getCurrentRenderingInstance();
  var hookID = currentInstance.getHookID();
  var hooks = currentInstance.getHooks();

  if (!hooks[hookID]) {
    hooks[hookID] = {
      current: initialValue
    };
  }

  return hooks[hookID];
}

function useCallback(callback, inputs) {
  return useMemo(function () {
    return callback;
  }, inputs);
}

function useMemo(create, inputs) {
  var currentInstance = getCurrentRenderingInstance();
  var hookID = currentInstance.getHookID();
  var hooks = currentInstance.getHooks();
  inputs = inputs === undefined ? null : inputs;

  if (!hooks[hookID]) {
    hooks[hookID] = [create(), inputs];
  } else {
    var prevInputs = hooks[hookID][1];

    if ((0, _types.isNull)(inputs) || !areInputsEqual(inputs, prevInputs)) {
      hooks[hookID] = [create(), inputs];
    }
  }

  return hooks[hookID][0];
}

function useReducer(reducer, initialArg, init) {
  var currentInstance = getCurrentRenderingInstance();
  var hookID = currentInstance.getHookID();
  var hooks = currentInstance.getHooks();
  var hook = hooks[hookID];

  if (!hook) {
    var initialState = (0, _types.isFunction)(init) ? init(initialArg) : initialArg;

    var dispatch = function dispatch(action) {
      // Flush all effects first before update state
      if (!_host.default.__isUpdating) {
        (0, _scheduler.flushEffect)();
      }

      var hook = hooks[hookID]; // Reducer will update in the next render, before that we add all
      // actions to the queue

      var queue = hook[2];

      if (getCurrentInstance() === currentInstance) {
        queue.__actions.push(action);

        currentInstance.__isScheduled = true;
      } else {
        var currentState = queue.__eagerState;
        var eagerReducer = queue.__eagerReducer;
        var eagerState = eagerReducer(currentState, action);

        if ((0, _shallowEqual.is)(eagerState, currentState)) {
          return;
        }

        queue.__eagerState = eagerState;

        queue.__actions.push(action);

        currentInstance.__update();
      }
    };

    return hooks[hookID] = [initialState, dispatch, {
      __actions: [],
      __eagerReducer: reducer,
      __eagerState: initialState
    }];
  }

  var queue = hook[2];
  var next = hook[0];

  if (currentInstance.__reRenders > 0) {
    for (var i = 0; i < queue.__actions.length; i++) {
      next = reducer(next, queue.__actions[i]);
    }
  } else {
    next = queue.__eagerState;
  }

  if (!(0, _shallowEqual.is)(next, hook[0])) {
    hook[0] = next;
    currentInstance.__shouldUpdate = true;
  }

  queue.__eagerReducer = reducer;
  queue.__eagerState = next;
  queue.__actions.length = 0;
  return hooks[hookID];
}