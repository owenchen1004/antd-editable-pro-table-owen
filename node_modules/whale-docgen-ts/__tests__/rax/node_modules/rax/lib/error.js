"use strict";

exports.__esModule = true;
exports.getTypeInfo = getTypeInfo;
exports.getRenderErrorInfo = getRenderErrorInfo;
exports.throwMinifiedError = throwMinifiedError;
exports.throwMinifiedWarn = throwMinifiedWarn;
exports.throwError = throwError;
exports.warning = void 0;

var _host = _interopRequireDefault(require("./vdom/host"));

var _scheduler = require("./vdom/scheduler");

var _types = require("./types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createMinifiedError(type, code, obj) {
  var typeInfo = obj === undefined ? '' : ' got: ' + getTypeInfo(obj);
  return new Error(type + ": #" + code + ", " + getRenderErrorInfo() + "." + typeInfo);
}

function getTypeInfo(obj) {
  return (0, _types.isPlainObject)(obj) ? Object.keys(obj) : obj;
}

function getRenderErrorInfo() {
  var ownerComponent = _host.default.owner;
  return ownerComponent ? "check <" + ownerComponent.__getName() + ">" : 'no owner';
}
/**
 * Minified code:
 *  1: Hooks called outside a component, or multiple version of Rax are used.
 *  6: Invalid component type, expected a class or function component.
 *  4: Too many re-renders, the number of renders is limited to prevent an infinite loop.
 *  5: Rax driver not found.
 * @param code {Number}
 * @param obj {Object}
 */


function throwMinifiedError(code, obj) {
  throw createMinifiedError('Error', code, obj);
}
/**
 * Minified Code:
 * 0: Invalid element type, expected a string or a class/function component but got "null" or "undefined".
 * 2. Invalid child type, expected types: Element instance, string, boolean, array, null, undefined.
 * 3. Ref can not attach because multiple copies of Rax are used.
 * @param {number} code
 * @param {string} info
 */


function throwMinifiedWarn(code, obj) {
  var err = createMinifiedError('Warn', code, obj);
  (0, _scheduler.scheduler)(function () {
    throw err;
  }, 0);
}

function throwError(message, obj) {
  var typeInfo = obj === undefined ? '' : '(found: ' + ((0, _types.isPlainObject)(obj) ? "object with keys {" + Object.keys(obj) + "}" : obj) + ')';
  throw Error(message + " " + typeInfo);
}

var warning = _types.NOOP;
exports.warning = warning;

if (process.env.NODE_ENV !== 'production') {
  exports.warning = warning = function warning(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (typeof console !== 'undefined') {
      var argsWithFormat = args.map(function (item) {
        return '' + item;
      });
      argsWithFormat.unshift('Warning: ' + template); // Don't use spread (or .apply) directly because it breaks IE9

      Function.prototype.apply.call(console.error, console, argsWithFormat);
    } // For works in DevTools when enable `Pause on caught exceptions`
    // that can find the component where caused this warning


    try {
      var argIndex = 0;
      var message = 'Warning: ' + template.replace(/%s/g, function () {
        return args[argIndex++];
      });
      throw new Error(message);
    } catch (e) {}
  };
}