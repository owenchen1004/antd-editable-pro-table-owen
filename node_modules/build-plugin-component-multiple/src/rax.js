const path = require('path');
const fse = require('fs-extra');
const chokidar = require('chokidar');
const webpack = require('webpack');
const _flatten = require('lodash/flatten');
const { WEB, MINIAPP, WECHAT_MINIPROGRAM, MINIAPP_COLOR, BUILD_COLOR, DOC_COLOR } = require('./constants');
const defaultUserConfig = require('./configs/userConfig');
const raxUserConfig = require('./configs/rax/userConfig');
const devCompileLog = require('./utils/raxDevCompileLog');
const buildCompileLog = require('./utils/raxBuildCompileLog');
const generateMiniappDemoEntry = require('./utils/generators/generateMiniappDemoEntry');
const generateMaterialJson = require('./utils/generators/generateMaterialJson');
const generateMiniappPortalPage = require('./utils/generators/generateMiniappPortalPage');
const getBaseWebpack = require('./configs/rax/getBaseWebpack');
const getMiniappConfig = require('./configs/rax/getMiniappConfig');
const getDistConfig = require('./configs/rax/getDistConfig');
const getES6Config = require('./configs/rax/getES6Config');
const getUMDConfig = require('./configs/rax/getUMDConfig');
const getLowCodeConfig = require('./configs/rax/getLowCodeConfig');
const getGroupData = require('./utils/getGroupData');
const { getAllComponentInfo, getSingleComponentInfo, getCurComponentInfo } = require('./utils/getComponentInfo');
const getDirs = require('./utils/getDirs');
const getReadmeFile = require('./utils/getReadMeFile');
const setCSSRule = require('./utils/css/setCSSRule');
const babelCompiler = require('./compiler/babel');

module.exports = (api, options = {}) => {
  const { registerTask, registerUserConfig, context, onHook, setValue, registerMethod, registerCliOption, log } = api;
  const { rootDir, userConfig, command, commandArgs, pkg } = context;
  const { plugins, targets, disableUMD, inlineStyle = true, ...compileOptions } = userConfig;
  const {
    // 是否为多组件包
    multiple: isMultiplePkg = true,
    // 是否展示进度条
    enableProgress = true,
    // 调试 web 时，是否使用  babel-plugin-import 抽取组件，以加速构建
    extractModule = false,
  } = options;
  const { component: componentName = '', demo: demoName } = commandArgs;
  const enableBuildMiniapp = targets.includes(MINIAPP) || targets.includes(WECHAT_MINIPROGRAM);
  const dirs = getDirs(rootDir);
  const { TYPES_DIR, ES_DIR, DIST_DIR, LIB_DIR, DOC_DIR, TMP_FILE_DIR, MINIAPP_DIR, BUILD_DIR } = dirs;

  // 兼容 multiple = "true" 的写法
  let multiple = isMultiplePkg === 'true' || isMultiplePkg === true;

  // 读取到的当前所有项目的 源码、demo 和 文档信息
  const componentInfo = getCurComponentInfo(context, multiple, componentName);

  // 向 build-plugin-doc-multiple 共享数据和方法
  registerUserConfig(defaultUserConfig.concat(raxUserConfig));
  registerMethod('getAllComponentInfo', getAllComponentInfo);
  registerMethod('getSingleComponentInfo', getSingleComponentInfo);
  registerMethod('getReadmeFile', getReadmeFile);
  registerMethod('getGroupData', getGroupData);
  registerMethod('getBaseWebpack', getBaseWebpack);
  registerMethod('generateMaterialJson', generateMaterialJson);
  registerMethod('setCSSRule', setCSSRule);
  setValue('dirs', dirs);
  setValue('isMultiple', multiple);
  setValue('componentInfo', componentInfo);
  setValue('miniappProgressColor', DOC_COLOR);

  // register cli options
  const cliOptions = ['component', 'demo'];

  registerCliOption(
    cliOptions.map((name) => ({
      name,
      commands: ['start', 'build'],
    })),
  );

  fse.ensureDirSync(TMP_FILE_DIR);

  // 获取所有 demo 信息
  const demos = _flatten(componentInfo.map((item) => item.demos));

  let miniappHomePagePath;

  if (command === 'start') {
    const demoDirPath = multiple ? path.join(DOC_DIR, componentName, 'demo') : path.join(rootDir, 'demo');

    miniappHomePagePath = generateMiniappPortalPage(componentInfo, TMP_FILE_DIR, pkg);

    // watch demo changes
    const demoWatcher = chokidar.watch(demoDirPath, {
      ignoreInitial: true,
      interval: 200,
    });

    demoWatcher.on('all', () => {
      // 初始化小程序 bundle.js
      if (enableBuildMiniapp) {
        generateMiniappDemoEntry(rootDir, componentInfo, miniappHomePagePath);
      }
    });

    demoWatcher.on('error', (error) => {
      log.error('fail to watch demo', error);
    });

    if (enableBuildMiniapp) {
      generateMiniappDemoEntry(rootDir, componentInfo, miniappHomePagePath);
    }

    // 清空小程序构建文件夹
    fse.emptyDirSync(MINIAPP_DIR);

    const miniappConfig = [];

    targets.forEach((target) => {
      const options = {
        ...compileOptions,
        target,
        enableProgress,
        inlineStyle,
        extractModule,
      };

      if (WEB === target) {
        const configDev = require(`./configs/rax/${target}/dev`);
        const defaultConfig = getBaseWebpack(context, {
          ...options,
        });
        configDev(defaultConfig, context, {
          ...options,
          multiple,
          component: componentName,
          demos,
        });
        registerTask(`component-dev-${target}`, defaultConfig);
      }

      if ([MINIAPP, WECHAT_MINIPROGRAM].includes(target)) {
        miniappConfig.push(
          getMiniappConfig(context, {
            ...options,
            demos: [
              {
                componentPascalName: '',
                demoPascalName: 'Home',
                filePath: miniappHomePagePath,
              },
              ...demos,
            ],
            target,
            progressBarColor: MINIAPP_COLOR,
          }).toConfig(),
        );
      }
    });

    // TODO: 因为小程序的特殊性，其与 web 同时构建会失败，先临时手动处理
    const miniappCompiler = webpack(miniappConfig);

    miniappCompiler.watch(
      {
        aggregateTimeout: 300,
        ignored: /node_modules/,
      },
      (err) => {
        if (err) {
          log.error(err);
        }
      },
    );
  } else if (command === 'build') {
    log.info('开始构建');

    fse.removeSync(BUILD_DIR);
    fse.removeSync(ES_DIR);
    fse.removeSync(LIB_DIR);
    fse.removeSync(DIST_DIR);
    fse.removeSync(TYPES_DIR);
    fse.emptyDirSync(MINIAPP_DIR);
    fse.emptyDirSync(TMP_FILE_DIR);

    const options = { ...userConfig, inlineStyle, enableProgress, extractModule };

    // 生成小程序 bundle 入口文件
    miniappHomePagePath = generateMiniappPortalPage(componentInfo, TMP_FILE_DIR, pkg);
    generateMiniappDemoEntry(rootDir, componentInfo, miniappHomePagePath);

    if (targets.includes(WEB)) {
      options[WEB] = WEB;
      registerTask(
        `component-build-${WEB}`,
        getDistConfig(context, { ...options, name: 'Web', multiple, progressBarColor: BUILD_COLOR }),
      );

      const configWebBuild = require(`./configs/rax/${WEB}/build`);
      const defaultDemoConfig = getBaseWebpack(context, {
        ...options,
        name: 'demos',
      });
      configWebBuild(defaultDemoConfig, context, { ...options, multiple, components: componentInfo });

      registerTask('component-build-demos', defaultDemoConfig);
    }

    targets.forEach((target) => {
      if ([MINIAPP, WECHAT_MINIPROGRAM].includes(target)) {
        registerTask(
          `component-build-${target}`,
          getMiniappConfig(context, {
            ...options,
            demos: [{ componentPascalName: '', demoPascalName: 'Home', filePath: miniappHomePagePath }, ...demos],
            target,
            progressBarColor: MINIAPP_COLOR,
          }),
        );
      }
    });

    registerTask(
      `component-build-es6`,
      getES6Config(context, { ...options, name: 'ES6', progressBarColor: BUILD_COLOR }),
    );
    registerTask(
      `component-build-umd`,
      getUMDConfig(context, { ...options, name: 'UMD', progressBarColor: BUILD_COLOR }),
    );
    registerTask(
      `component-build-lowcode`,
      getLowCodeConfig(context, { ...options, name: 'LowCode', progressBarColor: BUILD_COLOR }),
    );

    onHook('before.build.load', async () => {
      const disableGenerateLib = userConfig[MINIAPP] && userConfig[MINIAPP].omitLib;

      if (!disableGenerateLib) {
        // 执行 babel 构建 es、lib、types
        babelCompiler(context, log, false, compileOptions, 'rax');
      }
    });
  }

  /* hooks */
  onHook('after.start.compile', async (args) => {
    const devUrl = args.urls.lanUrlForBrowser || args.url;
    const entries = {};

    demos.forEach((demo) => {
      entries[`${componentName}$$${demo.filename}`] = demo.filePath;
    });

    devCompileLog(args, devUrl, targets, entries, rootDir, { ...userConfig });
  });

  onHook('after.build.compile', async (args) => {
    buildCompileLog(args, targets, rootDir, userConfig);
  });
};
