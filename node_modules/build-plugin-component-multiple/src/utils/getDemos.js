/**
 * get demos from demo dir
 */
const { readFileSync, existsSync } = require('fs');
const camelcase = require('camelcase');
const glob = require('glob');
const path = require('path');
const { parse: commentParse } = require('comment-parser');
const strip = require('strip-comments');
const { markdownParser } = require('../utils/markdownHelper');
const highlightCode = require('../utils/highlightCode');

module.exports = function getDemos(rootDir, componentName, demoName, multiple) {
  const demoExtPattern = '{md,js,jsx,ts,tsx}';
  const demoNamePattern = demoName || '*';
  const demoPath = path.join(rootDir, 'docs');

  if (multiple && !existsSync(demoPath)) {
    return [];
  }

  let demoFiles = [];

  if (multiple && componentName) {
    demoFiles = glob.sync(`${componentName}/demo/${demoNamePattern}.${demoExtPattern}`, {
      cwd: demoPath,
      absolute: true,
    });
  } else {
    if (multiple) {
      demoFiles = glob.sync(`*/demo/${demoNamePattern}.${demoExtPattern}`, { cwd: demoPath, absolute: true });
    } else {
      demoFiles = glob.sync(`${demoNamePattern}.${demoExtPattern}`, {
        cwd: path.join(rootDir, 'demo'),
        absolute: true,
      });
    }
  }

  return demoFiles
    .map((filePath) => {
      const filename = filePath.replace(/(.*\/)*([^.]+).*/gi, '$2');
      const ext = filePath.replace(/.+\./, '');
      const content = readFileSync(filePath, 'utf-8');
      const href = `/${multiple ? componentName + '/' : ''}${filename}`;
      const commonResult = {
        href,
        filename,
        componentName,
        componentPascalName: camelcase(componentName, { pascalCase: true }),
        demoName: filename,
        demoPascalName: camelcase(filename, { pascalCase: true }),
        filePath,
        ext,
      };

      if (ext === 'md') {
        const {
          meta,
          highlightedCode,
          content: markdownContent,
          highlightedStyle,
          code,
        } = markdownParser(content, {
          sliceCode: true,
          demoPath: path.resolve(filePath, '../'),
        });

        return {
          ...commonResult,
          ...meta,
          highlightedCode,
          markdownContent,
          highlightedStyle,
          code,
        };
      } else {
        const parsedComment = commentParse(content);
        const meta = {};

        if (Array.isArray(parsedComment) && parsedComment.length && Array.isArray(parsedComment[0].tags)) {
          parsedComment[0].tags.forEach((t) => {
            let { name, tag, description } = t;
            if (tag === 'order') {
              name = name > 0 ? +name : 999;
            } else if (tag === 'desc') {
              const { content: markdownContent } = markdownParser(`${name} ${description}`);
              name = markdownContent;
            }

            meta[tag] = name;
          });
        }

        return {
          ...commonResult,
          ...meta,
          highlightedCode: highlightCode(strip.block(content)),
          highlightedStyle: undefined,
          code: content,
        };
      }
    })
    .sort((a, b) => {
      return a.order - b.order;
    });
};
