"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useForceUpdate = exports.useGuid = exports.guid = exports.useDeprecated = exports.useValue = void 0;

var tslib_1 = require("tslib");

var rax_1 = require("rax");

var fp_1 = require("./fp");

function useValue(props, defaultValue, options) {
  var _a = options || {},
      _b = _a.valueName,
      valueName = _b === void 0 ? 'value' : _b,
      fitValue = _a.fitValue,
      compare = _a.compare;

  var defaultName = rax_1.useMemo(function () {
    var n = valueName.substr(0, 1).toUpperCase() + valueName.substr(1);
    return "default" + n;
  }, [valueName]);
  var isControlled = (valueName in props);
  var defaultVal = rax_1.useMemo(function () {
    var v = defaultValue;

    if (defaultName in props) {
      v = props[defaultName];
    }

    if (isControlled) {
      v = props[valueName];
    }

    if (fp_1.isNil(v)) {
      v = defaultValue;
    }

    if (fitValue) {
      v = fitValue(v);
    }

    return v;
  }, []);

  var getControlledValue = function () {
    var x = props[valueName];

    if (fp_1.isNil(x)) {
      if (fitValue) {
        return fitValue(defaultValue);
      }

      return defaultValue;
    }

    if (fitValue) {
      return fitValue(x);
    }

    return x;
  };

  var _c = rax_1.useState(defaultVal),
      value = _c[0],
      setValue = _c[1];

  var propValue = rax_1.useRef(defaultVal);
  rax_1.useEffect(function () {
    if (isControlled) {
      var newValue = getControlledValue();
      var isSame = compare ? compare(newValue, propValue.current) : newValue === propValue.current;

      if (!isSame) {
        propValue.current = newValue;
        setValue(newValue);
      }
    }
  }, [props[valueName], props.dataSource]);

  var setPropValue = function (val) {
    var isSame = compare ? compare(val, propValue.current) : val === propValue.current;

    if (!isSame) {
      propValue.current = val;
      setValue(val);
    }
  };

  if (isControlled) {
    return [propValue.current, setValue, isControlled, setPropValue];
  }

  return [value, setValue, isControlled, setPropValue];
}

exports.useValue = useValue;

function useDeprecated(comp, props, oldName, newName, defaultValue) {
  rax_1.useEffect(function () {
    if (oldName in props && console && console.warn) {
      console.warn("Warning: " + comp + "." + oldName + " is deprecated and will be removed in a future version, please use " + newName + " instead");
    }
  }, []);

  if (newName in props) {
    return props[newName];
  }

  if (oldName in props) {
    return props[oldName];
  }

  return defaultValue;
}

exports.useDeprecated = useDeprecated;
var counter = 0;

function guid(prefix) {
  if (prefix === void 0) {
    prefix = '';
  }

  counter += 1;
  return "" + prefix + counter;
}

exports.guid = guid;

function useGuid(prefix) {
  if (prefix === void 0) {
    prefix = '';
  }

  var id = rax_1.useRef(guid(prefix));
  return id.current;
}

exports.useGuid = useGuid;

function useForceUpdate() {
  var _a = rax_1.useState(0),
      update = _a[1];

  var cb = rax_1.useCallback(function () {
    return update(function (x) {
      return x >= Number.MAX_SAFE_INTEGER ? 0 : x + 1;
    });
  }, []);
  return cb;
}

exports.useForceUpdate = useForceUpdate;

function useWhyDidYouUpdate(componentName, props) {
  var prevProps = rax_1.useRef({});
  rax_1.useEffect(function () {
    if (prevProps.current) {
      var allKeys = Object.keys(tslib_1.__assign(tslib_1.__assign({}, prevProps.current), props));
      var changedProps_1 = {};
      allKeys.forEach(function (key) {
        if (prevProps.current[key] !== props[key]) {
          changedProps_1[key] = {
            from: prevProps.current[key],
            to: props[key]
          };
        }
      });

      if (Object.keys(changedProps_1).length) {
        console.log('[why-did-you-update]', componentName, changedProps_1);
      }
    }

    prevProps.current = props;
  });
}

exports.default = useWhyDidYouUpdate;