"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = require("tslib");

var rax_1 = require("rax");

var classnames_1 = tslib_1.__importDefault(require("classnames"));

var rax_children_1 = tslib_1.__importDefault(require("rax-children"));

var view_1 = tslib_1.__importDefault(require("../view"));

var item_1 = tslib_1.__importDefault(require("./item"));

var menu_context_1 = tslib_1.__importDefault(require("./menu-context"));

var sub_menu_1 = tslib_1.__importDefault(require("./sub-menu"));

var utils_1 = require("../utils");

var hooks_1 = require("../utils/hooks");

var constant_1 = require("./constant");

var handleChildren = function (children, prefixKey, depth) {
  if (prefixKey === void 0) {
    prefixKey = '';
  }

  if (depth === void 0) {
    depth = 1;
  }

  return rax_children_1.default.map(children, function (child, index) {
    var keyPath = prefixKey + index.toString();
    var key = child.key || keyPath;
    child.props = Object.assign({}, child.props, {
      keyPath: keyPath,
      depth: depth,
      key: key,
      itemKey: key
    });

    if (child.props.children && child.props.children instanceof Array) {
      handleChildren(child.props.children, keyPath + "-", depth + 1);
    }

    return child;
  });
};

var handleDataSource = function (items, prefixKey, depth) {
  if (prefixKey === void 0) {
    prefixKey = '';
  }

  if (depth === void 0) {
    depth = 1;
  }

  return items.map(function (child, index) {
    var keyPath = prefixKey + index.toString();
    var key = utils_1.getNotUndef(child.key, child.value, keyPath);

    if (utils_1.isValidArray(child.children)) {
      var subChild = handleDataSource(child.children, keyPath + "-", depth + 1);
      return rax_1.createElement(sub_menu_1.default, tslib_1.__assign(tslib_1.__assign({}, child), {
        key: key,
        keyPath: keyPath,
        depth: depth
      }), subChild);
    } else {
      return rax_1.createElement(item_1.default, tslib_1.__assign(tslib_1.__assign({}, child), {
        key: key,
        itemKey: key,
        keyPath: keyPath
      }), child.label);
    }
  });
};

var Menu = function (props, ref) {
  var _a = props.prefix,
      prefix = _a === void 0 ? 'mt-' : _a,
      className = props.className,
      _b = props.size,
      size = _b === void 0 ? 'medium' : _b,
      selectMode = props.selectMode,
      _c = props.onItemClick,
      onItemClick = _c === void 0 ? function () {} : _c,
      _d = props.onOpen,
      onOpen = _d === void 0 ? function () {} : _d,
      _e = props.inlineIndent,
      inlineIndent = _e === void 0 ? constant_1.DEFAULT_INLINE_INDENT : _e,
      _f = props.onSelect,
      onSelect = _f === void 0 ? function () {} : _f,
      dataSource = props.dataSource,
      children = props.children;

  var _g = hooks_1.useValue(props, [], {
    valueName: 'openKeys',
    compare: function compare(a, b) {
      return a.join(',') === b.join(',');
    }
  }),
      openKeys = _g[0],
      setOpenKeys = _g[1],
      isOpenControlled = _g[2];

  var _h = hooks_1.useValue(props, [], {
    valueName: 'selectedKeys',
    compare: function compare(a, b) {
      return a.join(',') === b.join(',');
    }
  }),
      selectedKeys = _h[0],
      setSelectedKeys = _h[1],
      isSelectedControlled = _h[2];

  var handleOpen = rax_1.useCallback(function (_a) {
    var key = _a.key,
        open = _a.open;
    var newOpenKeys = [];

    if (open) {
      newOpenKeys = openKeys.concat(key);
    } else {
      newOpenKeys = openKeys.filter(function (item) {
        return item !== key;
      });
    }

    if (isOpenControlled) {
      onOpen(newOpenKeys, {
        key: key,
        open: open
      });
    } else {
      setOpenKeys(newOpenKeys);
    }
  }, [openKeys, isOpenControlled, onOpen]);
  var handleClickItem = rax_1.useCallback(function (key, item, event) {
    return onItemClick(key, item, event);
  }, [onItemClick]);
  var handleSelect = rax_1.useCallback(function (selected, item) {
    var newSelectedKeys = [];
    var key = item.itemKey;
    var keyPath = item.keyPath;

    if (selected) {
      if (selectMode === 'single') {
        newSelectedKeys = [key];
      } else if (selectMode === 'multiple') {
        newSelectedKeys = selectedKeys.concat(key);
      }
    } else {
      newSelectedKeys = selectedKeys.filter(function (i) {
        return i !== key;
      });
    }

    if (isSelectedControlled) {
      onSelect(newSelectedKeys, item, {
        select: selected,
        key: key,
        label: item.children,
        keyPath: keyPath
      });
    } else {
      setSelectedKeys(newSelectedKeys);
    }
  }, [selectMode, selectedKeys, isSelectedControlled, onSelect]);
  var context = rax_1.useMemo(function () {
    return {
      prefix: prefix,
      size: size,
      selectMode: selectMode,
      inlineIndent: inlineIndent,
      openKeys: openKeys,
      selectedKeys: selectedKeys,
      onOpen: handleOpen,
      onClickItem: handleClickItem,
      onSelect: handleSelect
    };
  }, [prefix, size, selectMode, inlineIndent, openKeys, selectedKeys, handleOpen, handleClickItem, handleSelect]);
  var newChildren = rax_1.useMemo(function () {
    return utils_1.isValidArray(dataSource) ? handleDataSource(dataSource) : handleChildren(children);
  }, [props.dataSource, children]);
  return rax_1.createElement(menu_context_1.default.Provider, {
    value: context
  }, rax_1.createElement(view_1.default, {
    ref: ref,
    className: classnames_1.default(prefix + "menu", className, prefix + "menu-size-" + size)
  }, newChildren, rax_1.createElement(view_1.default, {
    className: prefix + "menu-obstructive"
  })));
};

Menu.displayName = 'Menu';
exports.default = rax_1.forwardRef(Menu);