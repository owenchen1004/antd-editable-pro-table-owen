"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = require("tslib");

var classnames_1 = tslib_1.__importDefault(require("classnames"));

var rax_1 = require("rax");

var utils_1 = require("../utils");

var hooks_1 = require("../utils/hooks");

var view_1 = tslib_1.__importDefault(require("../view"));

var thumb_1 = tslib_1.__importDefault(require("./thumb"));

var track_1 = tslib_1.__importDefault(require("./track"));

var utils_2 = require("./utils");

var Mode;

(function (Mode) {
  Mode["Single"] = "single";
  Mode["Double"] = "double";
})(Mode || (Mode = {}));

function getInitialRatio(max, min, value, defaultValue) {
  var ratio = min;

  if (!utils_1.isUndef(value)) {
    ratio = value;
  } else if (!utils_1.isUndef(defaultValue)) {
    ratio = defaultValue;
  }

  if (!Array.isArray(ratio)) {
    ratio = [ratio];
  }

  return ratio.map(function (item) {
    if (item > max) {
      return max;
    }

    if (item < min) {
      return min;
    }

    return item;
  }).reduce(function (prev, curr, index) {
    var _a;

    return tslib_1.__assign(tslib_1.__assign({}, prev), (_a = {}, _a[index] = (curr - min) / (max - min), _a));
  }, {});
}

var Range = function (props) {
  var _a = props.size,
      size = _a === void 0 ? 'medium' : _a,
      _b = props.min,
      min = _b === void 0 ? 0 : _b,
      _c = props.prefix,
      prefix = _c === void 0 ? 'mt-' : _c,
      _d = props.max,
      max = _d === void 0 ? 100 : _d,
      _e = props.mode,
      mode = _e === void 0 ? 'single' : _e,
      value = props.value,
      defaultValue = props.defaultValue,
      _f = props.step,
      step = _f === void 0 ? 1 : _f,
      _g = props.disabled,
      disabled = _g === void 0 ? false : _g,
      _h = props.marks,
      marks = _h === void 0 ? false : _h,
      _j = props.marksPosition,
      marksPosition = _j === void 0 ? 'below' : _j,
      _k = props.previewed,
      previewed = _k === void 0 ? false : _k,
      className = props.className,
      tooltipVisible = props.tooltipVisible,
      _l = props.onChange,
      onChange = _l === void 0 ? utils_2.noop : _l,
      _m = props.onProcess,
      onProcess = _m === void 0 ? utils_2.noop : _m,
      others = tslib_1.__rest(props, ["size", "min", "prefix", "max", "mode", "value", "defaultValue", "step", "disabled", "marks", "marksPosition", "previewed", "className", "tooltipVisible", "onChange", "onProcess"]);

  var _o = rax_1.useState(getInitialRatio(max, min, value, defaultValue)),
      ratio = _o[0],
      setRatio = _o[1];

  var _p = rax_1.useState(null),
      active = _p[0],
      setActive = _p[1];

  var _q = rax_1.useState(false),
      dragging = _q[0],
      setDragging = _q[1];

  var _r = rax_1.useState(0),
      rangeWidth = _r[0],
      setRangeWidth = _r[1];

  var id = hooks_1.useGuid('range-');
  var thumbId1 = hooks_1.useGuid('range-thumb-');
  var thumbId2 = hooks_1.useGuid('range-thumb-');
  var isControlled = ('value' in props);
  var handles = mode === Mode.Double ? {
    0: thumbId1,
    1: thumbId2
  } : {
    0: thumbId1
  };

  function getRatioValue(val) {
    return parseFloat((val * (max - min) + min).toFixed(utils_2.getPrecision(step)));
  }

  var points = rax_1.useMemo(function () {
    var data = {};

    var dealPoints = function dealPoints() {
      if (step) {
        for (var point = min; point <= max; point += step) {
          var current = Number(point.toFixed(1));
          data[current] = current;
        }
      }
    };

    if (marks instanceof Array) {
      marks.reduce(function (prev, current) {
        prev[current] = current;
        return prev;
      }, data);
    } else if (marks instanceof Object) {
      data = tslib_1.__assign({}, marks);
    }

    dealPoints();
    return Object.keys(data).map(parseFloat).sort(function (a, b) {
      return a - b;
    });
  }, [marks, step, min, max]);

  function getClosestStep(val) {
    var diffs = points.map(function (point) {
      return Math.abs(point - val - min);
    });
    return points[diffs.indexOf(Math.min.apply(Math, diffs))];
  }

  function getValue(newRatio) {
    var result = Object.keys(newRatio).map(function (key) {
      return getRatioValue(newRatio[key]);
    }).sort(function (a, b) {
      return a - b;
    });

    if (result.length === 1) {
      return result[0];
    }

    return result;
  }

  function updatePositionByTouch(e, activeIndex) {
    return utils_2.getNodeRect(id).then(function (rect) {
      var position = utils_2.getTouchPosition(e);
      var diff = position - rect.left;
      var offset = Math.max(Math.min(diff, rect.width), 0);
      var closestValue = getClosestStep(offset / rect.width * (max - min));

      var newRatio = tslib_1.__assign({}, ratio);

      if (!utils_1.isUndef(activeIndex)) {
        newRatio[activeIndex] = (closestValue - min) / (max - min);
      }

      if (!isControlled) {
        setRatio(newRatio);
      }

      return newRatio;
    });
  }

  function handleTouchStart(e) {
    if (disabled || previewed || dragging) {
      return;
    }

    var position = utils_2.getTouchPosition(e);
    utils_2.getClosestThumbIndex(position, handles).then(function (activeIndex) {
      setDragging(true);
      setActive(activeIndex);
      updatePositionByTouch(e, activeIndex).then(function (newRatio) {
        if (utils_1.isFunction(onChange)) {
          onChange(getValue(newRatio), e);
        }
      });
      utils_2.pauseEvent(e);
    });
  }

  function handleTouchMove(e) {
    if (!dragging) {
      return;
    }

    updatePositionByTouch(e, active).then(function (newRatio) {
      if (utils_1.isFunction(onProcess)) {
        onProcess(getValue(newRatio), e);
      }

      if (utils_1.isFunction(onChange)) {
        onChange(getValue(newRatio), e);
      }
    });
    utils_2.pauseEvent(e);
  }

  function handleTouchEnd(e) {
    if (!dragging) {
      return;
    }

    setDragging(false);
    setActive(null);
    updatePositionByTouch(e, active).then(function (newRatio) {
      if (utils_1.isFunction(onChange)) {
        onChange(getValue(newRatio), e);
      }
    });
    utils_2.pauseEvent(e);
  }

  function adjustRatio() {
    var data = {};
    Object.keys(ratio).forEach(function (key) {
      return data[key] = (getClosestStep(ratio[key] * (max - min)) - min) / (max - min);
    });
    setRatio(data);
  }

  rax_1.useEffect(function () {
    adjustRatio();
    setTimeout(function () {
      utils_2.getNodeRect(id).then(function (rect) {
        setRangeWidth(rect.width);
      });
    }, 100);
  }, []);
  rax_1.useEffect(function () {
    if (isControlled) {
      setRatio(getInitialRatio(max, min, value, defaultValue));
    }
  }, [value, defaultValue, max, min]);
  var ratioValue = Object.values(ratio).sort(function (a, b) {
    return a - b;
  });
  return rax_1.createElement(view_1.default, tslib_1.__assign({}, others, {
    id: id,
    withoutTouch: false,
    className: classnames_1.default(prefix + "range", className),
    onMouseDown: handleTouchStart,
    onMouseMove: handleTouchMove,
    onMouseUp: handleTouchEnd,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd
  }), rax_1.createElement(track_1.default, {
    prefix: prefix,
    size: size,
    min: min,
    max: max,
    marks: marks,
    marksPosition: marksPosition,
    disabled: disabled,
    ratio: ratioValue,
    rangeWidth: rangeWidth
  }), Object.keys(handles).map(function (key) {
    var isActive = "" + active === "" + key;
    return rax_1.createElement(thumb_1.default, {
      prefix: prefix,
      key: key,
      size: size,
      id: handles[key],
      disabled: disabled,
      isActive: isActive,
      tooltipVisible: tooltipVisible,
      offset: ratio[key] * rangeWidth,
      value: getRatioValue(ratio[key])
    });
  }));
};

Range.displayName = 'Range';
exports.default = rax_1.forwardRef(Range);