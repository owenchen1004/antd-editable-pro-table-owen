"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noop = exports.isInRange = exports.handleMarks = exports.getClosestThumbIndex = exports.getPrecision = exports.getNodeRect = exports.getTouchPosition = exports.pauseEvent = exports.unit = void 0;

var tslib_1 = require("tslib");

var dom_1 = require("./dom");

var utils_1 = require("../utils");

exports.unit = 'rpx';

function pauseEvent(e) {
  e.stopPropagation();
}

exports.pauseEvent = pauseEvent;

function isMouseEvent(e) {
  return e.pageX;
}

function isTouchEvent(e) {
  return typeof e.changedTouches !== 'undefined';
}

function getTouchPosition(e) {
  var x = 0;

  if (isMouseEvent(e)) {
    x = e.pageX;
  }

  if (isTouchEvent(e)) {
    x = e.changedTouches[0].pageX;
  }

  return dom_1.px2rem(x);
}

exports.getTouchPosition = getTouchPosition;

function getNodeRect(id) {
  return new Promise(function (resolve) {
    dom_1.getComponentRect(id, function (e) {
      resolve(e.size);
    }, true);
  });
}

exports.getNodeRect = getNodeRect;

function getPrecision(step) {
  var stepString = step.toString();
  var precision = 0;

  if (stepString.indexOf('.') >= 0) {
    precision = stepString.length - stepString.indexOf('.') - 1;
  }

  return precision;
}

exports.getPrecision = getPrecision;

function getClosestThumbIndex(position, thumbs) {
  var keys = Object.keys(thumbs);

  if (keys.length === 1) {
    return Promise.resolve(0);
  }

  var index = 0;
  return Promise.all(keys.map(function (key) {
    return getNodeRect(thumbs[key]);
  })).then(function (rects) {
    if (Math.abs(rects[0].left - position) > Math.abs(rects[1].left - position)) {
      index = 1;
    }

    return +keys[index];
  });
}

exports.getClosestThumbIndex = getClosestThumbIndex;

function handleMarks(marks, min, max) {
  if (marks instanceof Array) {
    return tslib_1.__spreadArrays(marks);
  } else if (marks instanceof Object) {
    return Object.keys(marks).map(parseFloat).sort(function (a, b) {
      return a - b;
    });
  } else if (utils_1.isNumber(marks)) {
    var current = min;
    var arr = [];

    while (current <= max) {
      arr.push(Number(current.toFixed(2)));
      current += (max - min) / marks;
    }

    return arr;
  } else {
    return [];
  }
}

exports.handleMarks = handleMarks;

function isInRange(value, range) {
  if (range.length === 1) {
    range.unshift(0);
  }

  return value >= range[0] && value <= range[1];
}

exports.isInRange = isInRange;

function noop() {}

exports.noop = noop;