"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = require("tslib");

var rax_1 = require("rax");

var classnames_1 = tslib_1.__importDefault(require("classnames"));

var env_1 = require("@uni/env");

var rax_text_1 = tslib_1.__importDefault(require("rax-text"));

var rax_textinput_1 = tslib_1.__importDefault(require("rax-textinput"));

var view_1 = tslib_1.__importDefault(require("../view"));

var icon_1 = tslib_1.__importDefault(require("../icon"));

var form_1 = tslib_1.__importDefault(require("../form"));

var utils_1 = require("../utils");

var hooks_1 = require("../utils/hooks");

var ICON_NAME_MAP = {
  warning: 'warning-filling',
  error: 'warning-filling',
  success: 'success-filling',
  loading: 'loading'
};

var Input = function (props, ref) {
  var _a, _b, _c, _d, _e, _f;

  var _g = props.prefix,
      prefix = _g === void 0 ? 'mt-' : _g,
      _h = props.size,
      size = _h === void 0 ? 'medium' : _h,
      _j = props.type,
      type = _j === void 0 ? 'normal' : _j,
      valueProp = props.value,
      _k = props.defaultValue,
      defaultValue = _k === void 0 ? '' : _k,
      _l = props.keyboardType,
      keyboardType = _l === void 0 ? 'text' : _l,
      placeholder = props.placeholder,
      _m = props.htmlType,
      htmlType = _m === void 0 ? '' : _m,
      _o = props.isPassword,
      isPasswordProp = _o === void 0 ? false : _o,
      stateProp = props.state,
      _p = props.disabled,
      disabled = _p === void 0 ? false : _p,
      _q = props.readOnly,
      readOnly = _q === void 0 ? false : _q,
      _r = props.hasClear,
      hasClear = _r === void 0 ? false : _r,
      _s = props.multiline,
      multiline = _s === void 0 ? false : _s,
      _t = props.useOriginalRef,
      useOriginalRef = _t === void 0 ? false : _t,
      _u = props.highlightable,
      highlightable = _u === void 0 ? false : _u,
      _v = props.showLimitHint,
      showLimitHint = _v === void 0 ? true : _v,
      _w = props.rows,
      rows = _w === void 0 ? 3 : _w,
      maxLength = props.maxLength,
      focused = props.focused,
      autoFocus = props.autoFocus,
      alignProp = props.align,
      _x = props.onFocus,
      onFocus = _x === void 0 ? function () {} : _x,
      _y = props.onBlur,
      onBlur = _y === void 0 ? function () {} : _y,
      _z = props.onChange,
      onChange = _z === void 0 ? function () {} : _z,
      _0 = props.onConfirm,
      onConfirm = _0 === void 0 ? function () {} : _0,
      _1 = props.onClear,
      onClear = _1 === void 0 ? function () {} : _1,
      onCompositionStart = props.onCompositionStart,
      onCompositionEnd = props.onCompositionEnd,
      className = props.className,
      controlled = props.controlled,
      _2 = props.addonAfter,
      addonAfter = _2 === void 0 ? null : _2,
      _3 = props.addonBefore,
      addonBefore = _3 === void 0 ? null : _3,
      _4 = props.innerAfter,
      innerAfter = _4 === void 0 ? null : _4,
      _5 = props.innerBefore,
      innerBefore = _5 === void 0 ? null : _5,
      enableNative = props.enableNative,
      compositionProp = props.composition,
      others = tslib_1.__rest(props, ["prefix", "size", "type", "value", "defaultValue", "keyboardType", "placeholder", "htmlType", "isPassword", "state", "disabled", "readOnly", "hasClear", "multiline", "useOriginalRef", "highlightable", "showLimitHint", "rows", "maxLength", "focused", "autoFocus", "align", "onFocus", "onBlur", "onChange", "onConfirm", "onClear", "onCompositionStart", "onCompositionEnd", "className", "controlled", "addonAfter", "addonBefore", "innerAfter", "innerBefore", "enableNative", "composition"]);

  var inputRef = rax_1.useRef(null);
  var composition = rax_1.useRef(false);
  var isPassword = isPasswordProp || htmlType === 'password';
  var clsPrefix = prefix + "input";

  var _6 = rax_1.useContext(form_1.default.ItemContext),
      validateState = _6.validateState,
      contentAlign = _6.contentAlign,
      hasFeedback = _6.hasFeedback;

  var _7 = hooks_1.useValue(props, '', {
    fitValue: function fitValue(v) {
      if (utils_1.isNumber(maxLength) && maxLength > 0) {
        return ("" + v).length > maxLength ? ("" + v).substr(0, maxLength) : v;
      }

      return v;
    }
  }),
      value = _7[0],
      setValue = _7[1],
      isControlled = _7[2],
      setPropValue = _7[3];

  var _8 = rax_1.useState(false),
      isFocused = _8[0],
      setFocusState = _8[1];

  var state = stateProp || validateState;
  var editable = !disabled && !readOnly;
  var showClear = hasClear && (env_1.isWeb && isFocused || utils_1.isMiniappPlatform) && !!value && editable;
  var clses = {
    input: classnames_1.default(clsPrefix, clsPrefix + "--" + size, clsPrefix + "--" + type, (_a = {}, _a[clsPrefix + "--hasIcon"] = showClear || state !== 'normal', _a[clsPrefix + "--" + type + "-highlighted"] = highlightable && isFocused, _a), className),
    textInputWrapper: classnames_1.default(clsPrefix + "-textinput-wrapper", (_b = {}, _b[clsPrefix + "-textinput-wrapper--multiline"] = multiline, _b)),
    textInput: classnames_1.default(clsPrefix + "-textinput", clsPrefix + "-textinput--" + size, clsPrefix + "-textinput--" + type, clsPrefix + "-textinput--" + (alignProp || contentAlign), (_c = {}, _c[clsPrefix + "-textinput--" + type + "-disabled"] = disabled, _c[clsPrefix + "-textinput--" + size + "-multiline"] = multiline, _c[clsPrefix + "-textinput--wechat"] = utils_1.isStrictWechatMiniProgram, _c[clsPrefix + "-textinput--not-bw"] = !utils_1.isStrictByteDanceMicroApp && !utils_1.isStrictWechatMiniProgram, _c[clsPrefix + "-textinput--" + type + "-readonly"] = readOnly, _c[clsPrefix + "-textinput--" + type + "-placeholder"] = readOnly && !value && placeholder, _c)),
    icon: classnames_1.default(clsPrefix + "-icon", clsPrefix + "-icon--" + size, (_d = {}, _d[clsPrefix + "-icon--loading"] = state === 'loading', _d[clsPrefix + "-icon--warning"] = state === 'warning', _d[clsPrefix + "-icon--success"] = state === 'success', _d[clsPrefix + "-icon--error"] = state === 'error', _d)),
    clear: classnames_1.default(clsPrefix + "-icon", clsPrefix + "-icon--" + size, (_e = {}, _e[clsPrefix + "-icon--clear"] = hasClear, _e)),
    limitHint: classnames_1.default(clsPrefix + "-limit-hint", clsPrefix + "-limit-hint--" + type, clsPrefix + "-limit-hint--" + size),
    addonBefore: clsPrefix + "-addon-before--" + size,
    addonAfter: clsPrefix + "-addon-after--" + size
  };

  var triggerChange = function (v, e) {
    var _a, _b, _c, _d;

    onChange(v, e);

    if (env_1.isWeb) {
      var r_1;

      try {
        if (utils_1.isNumber((_a = e === null || e === void 0 ? void 0 : e.target) === null || _a === void 0 ? void 0 : _a.selectionStart) && utils_1.isNumber((_b = e === null || e === void 0 ? void 0 : e.target) === null || _b === void 0 ? void 0 : _b.selectionEnd)) {
          r_1 = [e.target.selectionStart, e.target.selectionEnd];
        }

        if (Array.isArray(r_1) && ((_d = (_c = inputRef === null || inputRef === void 0 ? void 0 : inputRef.current) === null || _c === void 0 ? void 0 : _c._nativeNode) === null || _d === void 0 ? void 0 : _d.setSelectionRange)) {
          setTimeout(function () {
            inputRef.current._nativeNode.setSelectionRange(r_1[0], r_1[1]);
          }, 32);
        }
      } catch (err) {}
    }
  };

  var handleChange = function (v, e) {
    if (isControlled) {
      if (composition.current) {
        setPropValue(v);
      }
    } else {
      setValue(v);
    }

    if (composition.current) {
      return;
    }

    triggerChange(v, e);
  };

  var handleCompositionStart = function (e) {
    composition.current = true;

    if (onCompositionStart) {
      onCompositionStart(e);
    }
  };

  var handleCompositionEnd = function (e) {
    composition.current = false;

    if (onCompositionEnd) {
      onCompositionEnd(e);
    }

    triggerChange(utils_1.getValueFromEvents(e), e);
  };

  var clearEvt = (_f = {}, _f[env_1.isWeb ? 'onTouchEnd' : 'onClick'] = function handleClear(e) {
    if (disabled || readOnly) {
      return;
    }

    if (e && e.preventDefault) {
      e.preventDefault();
    }

    if (onClear) {
      onClear(e);
    }

    handleChange('', e);

    if (inputRef && inputRef.current) {
      inputRef.current.focus();
    }
  }, _f);

  if (compositionProp) {
    others.onCompositionStart = handleCompositionStart;
    others.onCompositionEnd = handleCompositionEnd;
  }

  rax_1.useImperativeHandle(ref, function () {
    return Object.assign(utils_1.get(inputRef, 'current') || {});
  });
  return rax_1.createElement(view_1.default, {
    className: clses.input
  }, addonBefore ? rax_1.createElement(view_1.default, {
    className: clses.addonBefore
  }, addonBefore) : null, readOnly ? rax_1.createElement(rax_text_1.default, {
    className: clses.textInput,
    numberOfLines: multiline ? 'auto' : 1
  }, value || placeholder, "\xA0") : rax_1.createElement(view_1.default, {
    className: clses.textInputWrapper
  }, innerBefore, rax_1.createElement(rax_textinput_1.default, tslib_1.__assign({
    ref: inputRef,
    autoHeight: true
  }, others, {
    editable: editable,
    value: value,
    keyboardType: keyboardType,
    multiline: multiline,
    maxLength: maxLength,
    numberOfLines: rows,
    className: clses.textInput
  }, isPassword ? {
    type: 'password'
  } : null, {
    secureTextEntry: isPassword,
    password: isPassword,
    onFocus: function handleFocus(e) {
      setFocusState(true);
      onFocus(e);
    },
    onBlur: function handleBlur(e) {
      if (env_1.isWeb) {
        if (inputRef && inputRef.current && inputRef.current._nativeNode !== document.activeElement) {
          setFocusState(false);
          onBlur(e);
        }
      } else {
        setFocusState(false);
        onBlur(e);
      }
    },
    onConfirm: function handleConfirm(e) {
      return onConfirm(utils_1.getValueFromEvents(e), e);
    },
    placeholder: placeholder,
    controlled: controlled,
    autoFocus: autoFocus || focused,
    onInput: function onInput(e) {
      return handleChange(utils_1.getValueFromEvents(e), e);
    },
    onChange: function (e) {
      return utils_1.stopPropagation(e);
    },
    placeholderColor: undefined,
    "placeholder-class": clsPrefix + "-placeholder",
    enableNative: enableNative,
    showCount: false
  })), utils_1.isNumber(maxLength) && maxLength > 0 && showLimitHint ? rax_1.createElement(rax_text_1.default, {
    className: clses.limitHint
  }, value.length || 0, "/", maxLength) : null), !multiline ? rax_1.createElement(view_1.default, {
    className: clsPrefix + "-items " + clsPrefix + "-items--" + size
  }, showClear ? rax_1.createElement(view_1.default, tslib_1.__assign({
    className: clsPrefix + "-icon-wrapper"
  }, clearEvt), rax_1.createElement(icon_1.default, {
    name: "delete-filling",
    className: clses.clear
  })) : null, !showClear && state !== 'normal' && hasFeedback ? rax_1.createElement(icon_1.default, {
    className: clses.icon,
    name: ICON_NAME_MAP[state]
  }) : null, innerAfter, addonAfter ? rax_1.createElement(view_1.default, {
    className: clses.addonAfter
  }, addonAfter) : null) : null);
};

Input.displayName = 'Input';
exports.default = rax_1.forwardRef(Input);