import { isIOS, windowWidth } from '../utils';
const config = {
    trustTags: makeMap('a,abbr,ad,audio,b,blockquote,br,code,col,colgroup,dd,del,dl,dt,div,em,fieldset,h1,h2,h3,h4,h5,h6,hr,i,img,ins,label,legend,li,ol,p,q,ruby,rt,source,span,strong,sub,sup,table,tbody,td,tfoot,th,thead,tr,title,ul,video'),
    blockTags: makeMap('address,article,aside,body,caption,center,cite,footer,header,html,nav,pre,section'),
    ignoreTags: makeMap('area,base,canvas,embed,frame,head,iframe,input,link,map,meta,param,rp,script,source,style,textarea,title,track,wbr'),
    voidTags: makeMap('area,base,br,col,circle,ellipse,embed,frame,hr,img,input,line,link,meta,param,path,polygon,rect,source,track,use,wbr'),
    entities: {
        lt: '<',
        gt: '>',
        quot: '"',
        apos: "'",
        ensp: '\u2002',
        emsp: '\u2003',
        nbsp: '\xA0',
        semi: ';',
        ndash: '–',
        mdash: '—',
        middot: '·',
        lsquo: '‘',
        rsquo: '’',
        ldquo: '“',
        rdquo: '”',
        bull: '•',
        hellip: '…',
    },
    tagStyle: {
        address: 'font-style:italic',
        big: 'display:inline;font-size:1.2em',
        caption: 'display:table-caption;text-align:center',
        center: 'text-align:center',
        cite: 'font-style:italic',
        dd: 'margin-left:40px',
        mark: 'background-color:yellow',
        pre: 'font-family:monospace;white-space:pre',
        s: 'text-decoration:line-through',
        small: 'display:inline;font-size:0.8em',
        strike: 'text-decoration:line-through',
        u: 'text-decoration:underline',
    },
};
const tagSelector = {};
const blankChar = makeMap(' ,\r,\n,\t,\f');
let idIndex = 0;
function makeMap(str) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = list.length; i--;) {
        map[list[i]] = true;
    }
    return map;
}
function decodeEntity(str, amp) {
    let i = str.indexOf('&');
    while (i !== -1) {
        const j = str.indexOf(';', i + 3);
        let code;
        if (j === -1) {
            break;
        }
        if (str[i + 1] === '#') {
            code = parseInt((str[i + 2] === 'x' ? '0' : '') + str.substring(i + 2, j));
            if (!isNaN(code)) {
                str = str.substr(0, i) + String.fromCharCode(code) + str.substr(j + 1);
            }
        }
        else {
            code = str.substring(i + 1, j);
            if (config.entities[code] || (code === 'amp' && amp)) {
                str = str.substr(0, i) + (config.entities[code] || '&') + str.substr(j + 1);
            }
        }
        i = str.indexOf('&', i + 1);
    }
    return str;
}
function HtmlParser(vm) {
    this.options = vm.props || vm.properties || {};
    this.tagStyle = Object.assign({}, config.tagStyle, this.options.tagStyle);
    this.imgList = vm.imgList || [];
    this.plugins = vm.plugins || [];
    this.attrs = Object.create(null);
    this.stack = [];
    this.nodes = [];
    this.pre =
        (this.options.containerStyle || '').includes('white-space') && this.options.containerStyle.includes('pre') ? 2 : 0;
}
HtmlParser.prototype.parse = function (content) {
    for (let i = this.plugins.length; i--;) {
        if (this.plugins[i].onUpdate) {
            content = this.plugins[i].onUpdate(content, config) || content;
        }
    }
    new Lexer(this).parse(content);
    while (this.stack.length) {
        this.popNode();
    }
    return this.nodes;
};
HtmlParser.prototype.expose = function () {
    for (let i = this.stack.length; i--;) {
        const item = this.stack[i];
        if (item.c || item.name === 'a' || item.name === 'video' || item.name === 'audio') {
            return;
        }
        item.c = 1;
    }
};
HtmlParser.prototype.hook = function (node) {
    for (let i = this.plugins.length; i--;) {
        if (this.plugins[i].onParse && this.plugins[i].onParse(node, this) === false) {
            return false;
        }
    }
    return true;
};
HtmlParser.prototype.getUrl = function (url) {
    const { domain } = this.options;
    if (url[0] === '/') {
        if (url[1] === '/') {
            url = `${domain ? domain.split('://')[0] : 'http'}:${url}`;
        }
        else if (domain) {
            url = domain + url;
        }
    }
    else if (domain && !url.includes('data:') && !url.includes('://')) {
        url = `${domain}/${url}`;
    }
    return url;
};
HtmlParser.prototype.parseStyle = function (node) {
    const { attrs } = node;
    const list = (this.tagStyle[node.name] || '').split(';').concat((attrs.style || '').split(';'));
    const styleObj = {};
    let tmp = '';
    if (attrs.id && !this.xml) {
        if (this.options.useAnchor) {
            this.expose();
        }
        else if (node.name !== 'img' && node.name !== 'a' && node.name !== 'video' && node.name !== 'audio') {
            attrs.id = undefined;
        }
    }
    if (attrs.width) {
        styleObj.width = parseFloat(attrs.width) + (attrs.width.includes('%') ? '%' : 'px');
        attrs.width = undefined;
    }
    if (attrs.height) {
        styleObj.height = parseFloat(attrs.height) + (attrs.height.includes('%') ? '%' : 'px');
        attrs.height = undefined;
    }
    for (let i = 0, len = list.length; i < len; i++) {
        const info = list[i].split(':');
        if (info.length < 2) {
            continue;
        }
        const key = info
            .shift()
            .trim()
            .toLowerCase();
        let value = info.join(':').trim();
        if ((value[0] === '-' && value.lastIndexOf('-') > 0) || value.includes('safe')) {
            tmp += `;${key}:${value}`;
        }
        else if (!styleObj[key] || value.includes('import') || !styleObj[key].includes('import')) {
            if (value.includes('url')) {
                let j = value.indexOf('(') + 1;
                if (j) {
                    while (value[j] === '"' || value[j] === "'" || blankChar[value[j]]) {
                        j++;
                    }
                    value = value.substr(0, j) + this.getUrl(value.substr(j));
                }
            }
            else if (value.includes('rpx')) {
                value = value.replace(/[0-9.]+\s*rpx/g, ($) => `${(parseFloat($) * windowWidth) / 750}px`);
            }
            styleObj[key] = value;
        }
    }
    node.attrs.style = tmp;
    return styleObj;
};
HtmlParser.prototype.onTagName = function (name) {
    this.tagName = this.xml ? name : name.toLowerCase();
    if (this.tagName === 'svg') {
        this.xml = (this.xml || 0) + 1;
    }
};
HtmlParser.prototype.onAttrName = function (name) {
    name = this.xml ? name : name.toLowerCase();
    if (name.substr(0, 5) === 'data-') {
        if (name === 'data-src' && !this.attrs.src) {
            this.attrName = 'src';
        }
        else if (this.tagName === 'img' || this.tagName === 'a') {
            this.attrName = name;
        }
        else {
            this.attrName = undefined;
        }
    }
    else {
        this.attrName = name;
        this.attrs[name] = 'T';
    }
};
HtmlParser.prototype.onAttrVal = function (val) {
    const name = this.attrName || '';
    if (name === 'style' || name === 'href') {
        this.attrs[name] = decodeEntity(val, true);
    }
    else if (name.includes('src')) {
        this.attrs[name] = this.getUrl(decodeEntity(val, true));
    }
    else if (name) {
        this.attrs[name] = val;
    }
};
HtmlParser.prototype.onOpenTag = function (selfClose) {
    const node = Object.create(null);
    node.name = this.tagName;
    node.attrs = this.attrs;
    this.attrs = Object.create(null);
    const { attrs } = node;
    const parent = this.stack[this.stack.length - 1];
    const siblings = parent ? parent.children : this.nodes;
    const close = this.xml ? selfClose : config.voidTags[node.name];
    if (tagSelector[node.name]) {
        attrs.class = tagSelector[node.name] + (attrs.class ? ` ${attrs.class}` : '');
    }
    if (node.name === 'embed') {
        const src = attrs.src || '';
        if (src.includes('.mp4') || src.includes('.3gp') || src.includes('.m3u8') || (attrs.type || '').includes('video')) {
            node.name = 'video';
        }
        else if (src.includes('.mp3') ||
            src.includes('.wav') ||
            src.includes('.aac') ||
            src.includes('.m4a') ||
            (attrs.type || '').includes('audio')) {
            node.name = 'audio';
        }
        if (attrs.autostart) {
            attrs.autoplay = 'T';
        }
        attrs.controls = 'T';
    }
    if (node.name === 'video' || node.name === 'audio') {
        if (node.name === 'video' && !attrs.id) {
            attrs.id = `v${idIndex++}`;
        }
        if (!attrs.controls && !attrs.autoplay) {
            attrs.controls = 'T';
        }
        node.src = [];
        if (attrs.src) {
            node.src.push(attrs.src);
            attrs.src = undefined;
        }
        this.expose();
    }
    if (close) {
        if (!this.hook(node) || config.ignoreTags[node.name]) {
            if (node.name === 'base' && !this.options.domain) {
                this.options.domain = attrs.href;
            }
            else if (node.name === 'source' &&
                parent &&
                (parent.name === 'video' || parent.name === 'audio') &&
                attrs.src) {
                parent.src.push(attrs.src);
            }
            return;
        }
        const styleObj = this.parseStyle(node);
        if (node.name === 'img') {
            if (attrs.src) {
                if (attrs.src.includes('webp')) {
                    node.webp = 'T';
                }
                if (attrs.src.includes('data:') && !attrs['original-src']) {
                    attrs.ignore = 'T';
                }
                if (!attrs.ignore || node.webp || attrs.src.includes('cloud://')) {
                    for (let i = this.stack.length; i--;) {
                        const item = this.stack[i];
                        if (item.name === 'a') {
                            node.a = item.attrs;
                            break;
                        }
                        const style = item.attrs.style || '';
                        if (style.includes('flex:') &&
                            !style.includes('flex:0') &&
                            !style.includes('flex: 0') &&
                            (!styleObj.width || !styleObj.width.includes('%'))) {
                            styleObj.width = '100% !important';
                            styleObj.height = '';
                            for (let j = i + 1; j < this.stack.length; j++) {
                                this.stack[j].attrs.style = (this.stack[j].attrs.style || '').replace('inline-', '');
                            }
                        }
                        else if (style.includes('flex') && styleObj.width === '100%') {
                            for (let j = i + 1; j < this.stack.length; j++) {
                                const _style = this.stack[j].attrs.style || '';
                                if (!_style.includes(';width') && !_style.includes(' width') && _style.indexOf('width') !== 0) {
                                    styleObj.width = '';
                                    break;
                                }
                            }
                        }
                        else if (style.includes('inline-block')) {
                            if (styleObj.width && styleObj.width[styleObj.width.length - 1] === '%') {
                                item.attrs.style += `;max-width:${styleObj.width}`;
                                styleObj.width = '';
                            }
                            else {
                                item.attrs.style += ';max-width:100%';
                            }
                        }
                        item.c = 1;
                    }
                    node.i = this.imgList.length;
                    let src = attrs['original-src'] || attrs.src;
                    if (this.imgList.includes(src)) {
                        let i = src.indexOf('://');
                        if (i !== -1) {
                            i += 3;
                            let newSrc = src.substr(0, i);
                            for (; i < src.length; i++) {
                                if (src[i] === '/') {
                                    break;
                                }
                                newSrc += Math.random() > 0.5 ? src[i].toUpperCase() : src[i];
                            }
                            newSrc += src.substr(i);
                            src = newSrc;
                        }
                    }
                    this.imgList.push(src);
                }
            }
            if (styleObj.display === 'inline') {
                styleObj.display = '';
            }
            if (attrs.ignore) {
                styleObj['max-width'] = styleObj['max-width'] || '100%';
                attrs.style += ';-webkit-touch-callout:none';
            }
            if (parseInt(styleObj.width) > windowWidth) {
                styleObj.height = undefined;
            }
            if (styleObj.width) {
                if (styleObj.width.includes('auto')) {
                    styleObj.width = '';
                }
                else {
                    node.w = 'T';
                    if (styleObj.height && !styleObj.height.includes('auto')) {
                        node.h = 'T';
                    }
                }
            }
        }
        else if (node.name === 'svg') {
            siblings.push(node);
            this.stack.push(node);
            this.popNode();
            return;
        }
        for (const key in styleObj) {
            if (styleObj[key]) {
                attrs.style += `;${key}:${styleObj[key].replace(' !important', '')}`;
            }
        }
        attrs.style = attrs.style.substr(1) || undefined;
    }
    else {
        if ((node.name === 'pre' || ((attrs.style || '').includes('white-space') && attrs.style.includes('pre'))) &&
            this.pre !== 2) {
            this.pre = 1;
            node.pre = 1;
        }
        node.children = [];
        this.stack.push(node);
    }
    siblings.push(node);
};
HtmlParser.prototype.onCloseTag = function (name) {
    name = this.xml ? name : name.toLowerCase();
    let i;
    for (i = this.stack.length; i--;) {
        if (this.stack[i].name === name) {
            break;
        }
    }
    if (i !== -1) {
        while (this.stack.length > i) {
            this.popNode();
        }
    }
    else if (name === 'p' || name === 'br') {
        const siblings = this.stack.length ? this.stack[this.stack.length - 1].children : this.nodes;
        siblings.push({
            name,
            attrs: {
                class: tagSelector[name],
                style: this.tagStyle[name],
            },
        });
    }
};
HtmlParser.prototype.popNode = function () {
    const node = this.stack.pop();
    let { attrs } = node;
    const { children } = node;
    const parent = this.stack[this.stack.length - 1];
    const siblings = parent ? parent.children : this.nodes;
    if (!this.hook(node) || config.ignoreTags[node.name]) {
        if (node.name === 'title' && children.length && children[0].type === 'text' && this.options.setTitle) {
        }
        siblings.pop();
        return;
    }
    if (node.pre && this.pre !== 2) {
        node.pre = undefined;
        this.pre = node.pre;
        for (let i = this.stack.length; i--;) {
            if (this.stack[i].pre) {
                this.pre = 1;
            }
        }
    }
    if (node.name === 'svg') {
        if (this.xml > 1) {
            this.xml--;
            return;
        }
        let src = '';
        const { style } = attrs;
        attrs.style = '';
        if (attrs.viewbox) {
            attrs.viewBox = attrs.viewbox;
        }
        attrs.xmlns = 'http://www.w3.org/2000/svg';
        (function traversal(_node) {
            if (_node.type === 'text') {
                src += _node.text;
                return;
            }
            src += `<${_node.name}`;
            for (const item in _node.attrs) {
                const val = _node.attrs[item];
                if (val) {
                    src += ` ${item}="${val}"`;
                }
            }
            if (!_node.children) {
                src += '/>';
            }
            else {
                src += '>';
                for (let i = 0; i < _node.children.length; i++) {
                    traversal(_node.children[i]);
                }
                src += `</${_node.name}>`;
            }
        })(node);
        node.name = 'img';
        node.attrs = {
            src: `data:image/svg+xml;utf8,${src.replace(/#/g, '%23')}`,
            style,
            ignore: 'T',
        };
        node.children = undefined;
        this.xml = false;
        return;
    }
    const styleObj = {};
    if (attrs.align) {
        if (node.name === 'table') {
            if (attrs.align === 'center') {
                styleObj['margin-inline-end'] = 'auto';
                styleObj['margin-inline-start'] = styleObj['margin-inline-end'];
            }
            else {
                styleObj.float = attrs.align;
            }
        }
        else {
            styleObj['text-align'] = attrs.align;
        }
        attrs.align = undefined;
    }
    if (node.name === 'font') {
        if (attrs.color) {
            styleObj.color = attrs.color;
            attrs.color = undefined;
        }
        if (attrs.face) {
            styleObj['font-family'] = attrs.face;
            attrs.face = undefined;
        }
        if (attrs.size) {
            let size = parseInt(attrs.size);
            if (!isNaN(size)) {
                if (size < 1) {
                    size = 1;
                }
                else if (size > 7) {
                    size = 7;
                }
                styleObj['font-size'] = ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'][size - 1];
            }
            attrs.size = undefined;
        }
    }
    if ((attrs.class || '').includes('align-center')) {
        styleObj['text-align'] = 'center';
    }
    Object.assign(styleObj, this.parseStyle(node));
    if (node.name !== 'table' && parseInt(styleObj.width) > windowWidth) {
        styleObj['max-width'] = '100%';
        styleObj['box-sizing'] = 'border-box';
    }
    if (config.blockTags[node.name]) {
        node.name = 'div';
    }
    else if (!config.trustTags[node.name] && !this.xml) {
        node.name = 'span';
    }
    else if (node.name === 'a' || node.name === 'ad') {
        this.expose();
    }
    else if (node.name === 'video' || node.name === 'audio') {
        node.children = undefined;
    }
    else if ((node.name === 'ul' || node.name === 'ol') && node.c) {
        const types = {
            a: 'lower-alpha',
            A: 'upper-alpha',
            i: 'lower-roman',
            I: 'upper-roman',
        };
        if (types[attrs.type]) {
            attrs.style += `;list-style-type:${types[attrs.type]}`;
            attrs.type = undefined;
        }
        node.c = 1;
        for (let i = children.length; i--;) {
            if (children[i].name === 'li') {
                children[i].c = 1;
            }
        }
    }
    else if (node.name === 'table') {
        let padding = parseFloat(attrs.cellpadding);
        let spacing = parseFloat(attrs.cellspacing);
        const border = parseFloat(attrs.border);
        node.c = 1;
        if (node.c) {
            if (isNaN(padding)) {
                padding = 2;
            }
            if (isNaN(spacing)) {
                spacing = 2;
            }
        }
        if (border) {
            attrs.style += `;border:${border}px solid gray`;
        }
        if (node.flag && node.c) {
            node.flag = undefined;
            styleObj.display = 'grid';
            if (spacing) {
                styleObj['grid-gap'] = `${spacing}px`;
                styleObj.padding = `${spacing}px`;
            }
            else if (border) {
                attrs.style += ';border-left:0;border-top:0';
            }
            const width = [];
            const trList = [];
            const cells = [];
            const map = {};
            (function traversal(nodes) {
                for (let i = 0; i < nodes.length; i++) {
                    if (nodes[i].name === 'tr') {
                        trList.push(nodes[i]);
                    }
                    else {
                        traversal(nodes[i].children || []);
                    }
                }
            })(children);
            for (let row = 1; row <= trList.length; row++) {
                let col = 1;
                for (let j = 0; j < trList[row - 1].children.length; j++, col++) {
                    const td = trList[row - 1].children[j];
                    if (td.name === 'td' || td.name === 'th') {
                        while (map[`${row}.${col}`]) {
                            col++;
                        }
                        td.c = 1;
                        let style = td.attrs.style || '';
                        const start = style.indexOf('width') ? style.indexOf(';width') : 0;
                        if (start !== -1) {
                            let end = style.indexOf(';', start + 6);
                            if (end === -1) {
                                end = style.length;
                            }
                            if (!td.attrs.colspan) {
                                width[col] = style.substring(start ? start + 7 : 6, end);
                            }
                            style = style.substr(0, start) + style.substr(end);
                        }
                        style +=
                            (border ? `;border:${border}px solid gray${spacing ? '' : ';border-right:0;border-bottom:0'}` : '') +
                                (padding ? `;padding:${padding}px` : '');
                        if (td.attrs.colspan) {
                            style += `;grid-column-start:${col};grid-column-end:${col + parseInt(td.attrs.colspan)}`;
                            if (!td.attrs.rowspan) {
                                style += `;grid-row-start:${row};grid-row-end:${row + 1}`;
                            }
                            col += parseInt(td.attrs.colspan) - 1;
                        }
                        if (td.attrs.rowspan) {
                            style += `;grid-row-start:${row};grid-row-end:${row + parseInt(td.attrs.rowspan)}`;
                            if (!td.attrs.colspan) {
                                style += `;grid-column-start:${col};grid-column-end:${col + 1}`;
                            }
                            for (let rowspan = 1; rowspan < td.attrs.rowspan; rowspan++) {
                                for (let colspan = 0; colspan < (td.attrs.colspan || 1); colspan++) {
                                    map[`${row + rowspan}.${col - colspan}`] = 1;
                                }
                            }
                        }
                        if (style) {
                            td.attrs.style = style;
                        }
                        cells.push(td);
                    }
                }
                if (row === 1) {
                    let temp = '';
                    for (let i = 1; i < col; i++) {
                        temp += `${width[i] ? width[i] : 'auto'} `;
                    }
                    styleObj['grid-template-columns'] = temp;
                }
            }
            node.children = cells;
        }
        else {
            if (node.c) {
                styleObj.display = 'table';
            }
            if (!isNaN(spacing)) {
                styleObj['border-spacing'] = `${spacing}px`;
            }
            if (border || padding || node.c) {
                (function traversal(nodes) {
                    for (let i = 0; i < nodes.length; i++) {
                        const td = nodes[i];
                        if (node.c) {
                            td.c = 1;
                        }
                        if (td.name === 'th' || td.name === 'td') {
                            if (border) {
                                td.attrs.style = `border:${border}px solid gray;${td.attrs.style || ''}`;
                            }
                            if (padding) {
                                td.attrs.style = `padding:${padding}px;${td.attrs.style || ''}`;
                            }
                        }
                        else if (td.children) {
                            traversal(td.children);
                        }
                    }
                })(children);
            }
        }
        if (this.options.enableTableScroll && !(attrs.style || '').includes('inline')) {
            const table = Object.assign({}, node);
            node.name = 'div';
            node.attrs = {
                style: 'overflow-x:auto;padding:1px',
            };
            node.children = [table];
            attrs = table.attrs;
        }
    }
    else if ((node.name === 'td' || node.name === 'th') && (attrs.colspan || attrs.rowspan)) {
        for (let i = this.stack.length; i--;) {
            if (this.stack[i].name === 'table') {
                this.stack[i].flag = 1;
                break;
            }
        }
    }
    else if (node.name === 'ruby') {
        node.name = 'span';
        for (let i = 0; i < children.length - 1; i++) {
            if (children[i].type === 'text' && children[i + 1].name === 'rt') {
                children[i] = {
                    name: 'span',
                    attrs: {
                        style: 'display:inline-block;text-align:center',
                    },
                    children: [
                        {
                            name: 'div',
                            attrs: {
                                style: `font-size:50%;${children[i + 1].attrs.style || ''}`,
                            },
                            children: children[i + 1].children,
                        },
                        children[i],
                    ],
                };
                children.splice(i + 1, 1);
            }
        }
    }
    if ((styleObj.display || '').includes('flex') && !node.c) {
        for (let i = children.length; i--;) {
            const item = children[i];
            if (item.f) {
                item.attrs.style = (item.attrs.style || '') + item.f;
                item.f = undefined;
            }
        }
    }
    const flex = parent &&
        (parent.attrs.style || '').includes('flex') &&
        !node.c &&
        !(styleObj.display || '').includes('inline');
    if (flex) {
        node.f = ';max-width:100%';
    }
    for (const key in styleObj) {
        if (styleObj[key]) {
            const val = `;${key}:${styleObj[key].replace(' !important', '')}`;
            if (flex &&
                ((key.includes('flex') && key !== 'flex-direction') ||
                    key === 'align-self' ||
                    styleObj[key][0] === '-' ||
                    (key === 'width' && val.includes('%')))) {
                node.f += val;
                if (key === 'width') {
                    attrs.style += ';width:100%';
                }
            }
            else {
                attrs.style += val;
            }
        }
    }
    attrs.style =
        attrs.style.substr(1) ||
            undefined;
};
HtmlParser.prototype.onText = function (text) {
    if (!this.pre) {
        let trim = '';
        let flag;
        for (let i = 0, len = text.length; i < len; i++) {
            if (!blankChar[text[i]]) {
                trim += text[i];
            }
            else {
                if (trim[trim.length - 1] !== ' ') {
                    trim += ' ';
                }
                if (text[i] === '\n' && !flag) {
                    flag = true;
                }
            }
        }
        if (trim === ' ' && flag) {
            return;
        }
        text = trim;
    }
    const node = Object.create(null);
    node.type = 'text';
    node.text = decodeEntity(text);
    if (this.hook(node)) {
        if (this.options.selectable === 'force' && isIOS) {
            this.expose();
            node.us = 'T';
        }
        const siblings = this.stack.length ? this.stack[this.stack.length - 1].children : this.nodes;
        siblings.push(node);
    }
};
function Lexer(handler) {
    this.handler = handler;
}
Lexer.prototype.parse = function (content) {
    this.content = content || '';
    this.i = 0;
    this.start = 0;
    this.state = this.text;
    for (const len = this.content.length; this.i !== -1 && this.i < len;) {
        this.state();
    }
};
Lexer.prototype.checkClose = function (method) {
    const selfClose = this.content[this.i] === '/';
    if (this.content[this.i] === '>' || (selfClose && this.content[this.i + 1] === '>')) {
        if (method) {
            this.handler[method](this.content.substring(this.start, this.i));
        }
        this.i += selfClose ? 2 : 1;
        this.start = this.i;
        this.handler.onOpenTag(selfClose);
        if (this.handler.tagName === 'script') {
            this.i = this.content.indexOf('</', this.i);
            if (this.i !== -1) {
                this.i += 2;
                this.start = this.i;
            }
            this.state = this.endTag;
        }
        else {
            this.state = this.text;
        }
        return true;
    }
    return false;
};
Lexer.prototype.text = function () {
    this.i = this.content.indexOf('<', this.i);
    if (this.i === -1) {
        if (this.start < this.content.length) {
            this.handler.onText(this.content.substring(this.start, this.content.length));
        }
        return;
    }
    const c = this.content[this.i + 1];
    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
        if (this.start !== this.i) {
            this.handler.onText(this.content.substring(this.start, this.i));
        }
        this.start = ++this.i;
        this.state = this.tagName;
    }
    else if (c === '/' || c === '!' || c === '?') {
        if (this.start !== this.i) {
            this.handler.onText(this.content.substring(this.start, this.i));
        }
        const next = this.content[this.i + 2];
        if (c === '/' && ((next >= 'a' && next <= 'z') || (next >= 'A' && next <= 'Z'))) {
            this.i += 2;
            this.start = this.i;
            this.state = this.endTag;
            return;
        }
        let end = '-->';
        if (c !== '!' || this.content[this.i + 2] !== '-' || this.content[this.i + 3] !== '-') {
            end = '>';
        }
        this.i = this.content.indexOf(end, this.i);
        if (this.i !== -1) {
            this.i += end.length;
            this.start = this.i;
        }
    }
    else {
        this.i++;
    }
};
Lexer.prototype.tagName = function () {
    if (blankChar[this.content[this.i]]) {
        this.handler.onTagName(this.content.substring(this.start, this.i));
        while (blankChar[this.content[++this.i]]) { }
        if (this.i < this.content.length && !this.checkClose()) {
            this.start = this.i;
            this.state = this.attrName;
        }
    }
    else if (!this.checkClose('onTagName')) {
        this.i++;
    }
};
Lexer.prototype.attrName = function () {
    let c = this.content[this.i];
    if (blankChar[c] || c === '=') {
        this.handler.onAttrName(this.content.substring(this.start, this.i));
        let needVal = c === '=';
        const len = this.content.length;
        while (++this.i < len) {
            c = this.content[this.i];
            if (!blankChar[c]) {
                if (this.checkClose()) {
                    return;
                }
                if (needVal) {
                    this.start = this.i;
                    this.state = this.attrVal;
                    return;
                }
                if (this.content[this.i] === '=') {
                    needVal = true;
                }
                else {
                    this.start = this.i;
                    this.state = this.attrName;
                    return;
                }
            }
        }
    }
    else if (!this.checkClose('onAttrName')) {
        this.i++;
    }
};
Lexer.prototype.attrVal = function () {
    const c = this.content[this.i];
    const len = this.content.length;
    if (c === '"' || c === "'") {
        this.start = ++this.i;
        this.i = this.content.indexOf(c, this.i);
        if (this.i === -1) {
            return;
        }
        this.handler.onAttrVal(this.content.substring(this.start, this.i));
    }
    else {
        for (; this.i < len; this.i++) {
            if (blankChar[this.content[this.i]]) {
                this.handler.onAttrVal(this.content.substring(this.start, this.i));
                break;
            }
            else if (this.checkClose('onAttrVal')) {
                return;
            }
        }
    }
    while (blankChar[this.content[++this.i]]) { }
    if (this.i < len && !this.checkClose()) {
        this.start = this.i;
        this.state = this.attrName;
    }
};
Lexer.prototype.endTag = function () {
    const c = this.content[this.i];
    if (blankChar[c] || c === '>' || c === '/') {
        this.handler.onCloseTag(this.content.substring(this.start, this.i));
        if (c !== '>') {
            this.i = this.content.indexOf('>', this.i);
            if (this.i === -1) {
                return;
            }
        }
        this.start = ++this.i;
        this.state = this.text;
    }
    else {
        this.i++;
    }
};
export default HtmlParser;
