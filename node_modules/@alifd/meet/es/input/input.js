import { __rest } from "tslib";
import { createElement, forwardRef, useContext, useState, useRef, useImperativeHandle, } from 'rax';
import classNames from 'classnames';
import { isWeb } from '@uni/env';
import Text from 'rax-text';
import TextInput from 'rax-textinput';
import View from '../view';
import Icon from '../icon';
import Form from '../form';
import { getValueFromEvents, isStrictByteDanceMicroApp, isStrictWechatMiniProgram, stopPropagation, isNumber, isMiniappPlatform, get, } from '../utils';
import { useValue } from '../utils/hooks';
const ICON_NAME_MAP = {
    warning: 'warning-filling',
    error: 'warning-filling',
    success: 'success-filling',
    loading: 'loading',
};
const Input = (props, ref) => {
    const { prefix = 'mt-', size = 'medium', type = 'normal', value: valueProp, defaultValue = '', keyboardType = 'text', placeholder, htmlType = '', isPassword: isPasswordProp = false, state: stateProp, disabled = false, readOnly = false, hasClear = false, multiline = false, useOriginalRef = false, highlightable = false, showLimitHint = true, rows = 3, maxLength, focused, autoFocus, align: alignProp, onFocus = () => { }, onBlur = () => { }, onChange = () => { }, onConfirm = () => { }, onClear = () => { }, onCompositionStart, onCompositionEnd, className, controlled, addonAfter = null, addonBefore = null, innerAfter = null, innerBefore = null, enableNative, composition: compositionProp } = props, others = __rest(props, ["prefix", "size", "type", "value", "defaultValue", "keyboardType", "placeholder", "htmlType", "isPassword", "state", "disabled", "readOnly", "hasClear", "multiline", "useOriginalRef", "highlightable", "showLimitHint", "rows", "maxLength", "focused", "autoFocus", "align", "onFocus", "onBlur", "onChange", "onConfirm", "onClear", "onCompositionStart", "onCompositionEnd", "className", "controlled", "addonAfter", "addonBefore", "innerAfter", "innerBefore", "enableNative", "composition"]);
    const inputRef = useRef(null);
    const composition = useRef(false);
    const isPassword = isPasswordProp || htmlType === 'password';
    const clsPrefix = `${prefix}input`;
    const { validateState, contentAlign, hasFeedback } = useContext(Form.ItemContext);
    const [value, setValue, isControlled, setPropValue] = useValue(props, '', {
        fitValue: (v) => {
            if (isNumber(maxLength) && maxLength > 0) {
                return `${v}`.length > maxLength ? `${v}`.substr(0, maxLength) : v;
            }
            return v;
        },
    });
    const [isFocused, setFocusState] = useState(false);
    const align = alignProp || contentAlign;
    const state = stateProp || validateState;
    const editable = !disabled && !readOnly;
    const showClear = hasClear && ((isWeb && isFocused) || isMiniappPlatform) && !!value && editable;
    const hasIcon = showClear || state !== 'normal';
    const clses = {
        input: classNames(clsPrefix, `${clsPrefix}--${size}`, `${clsPrefix}--${type}`, {
            [`${clsPrefix}--hasIcon`]: hasIcon,
            [`${clsPrefix}--${type}-highlighted`]: highlightable && isFocused,
        }, className),
        textInputWrapper: classNames(`${clsPrefix}-textinput-wrapper`, {
            [`${clsPrefix}-textinput-wrapper--multiline`]: multiline,
        }),
        textInput: classNames(`${clsPrefix}-textinput`, `${clsPrefix}-textinput--${size}`, `${clsPrefix}-textinput--${type}`, `${clsPrefix}-textinput--${align}`, {
            [`${clsPrefix}-textinput--${type}-disabled`]: disabled,
            [`${clsPrefix}-textinput--${size}-multiline`]: multiline,
            [`${clsPrefix}-textinput--wechat`]: isStrictWechatMiniProgram,
            [`${clsPrefix}-textinput--not-bw`]: !isStrictByteDanceMicroApp && !isStrictWechatMiniProgram,
            [`${clsPrefix}-textinput--${type}-readonly`]: readOnly,
            [`${clsPrefix}-textinput--${type}-placeholder`]: readOnly && !value && placeholder,
        }),
        icon: classNames(`${clsPrefix}-icon`, `${clsPrefix}-icon--${size}`, {
            [`${clsPrefix}-icon--loading`]: state === 'loading',
            [`${clsPrefix}-icon--warning`]: state === 'warning',
            [`${clsPrefix}-icon--success`]: state === 'success',
            [`${clsPrefix}-icon--error`]: state === 'error',
        }),
        clear: classNames(`${clsPrefix}-icon`, `${clsPrefix}-icon--${size}`, {
            [`${clsPrefix}-icon--clear`]: hasClear,
        }),
        limitHint: classNames(`${clsPrefix}-limit-hint`, `${clsPrefix}-limit-hint--${type}`, `${clsPrefix}-limit-hint--${size}`),
        addonBefore: `${clsPrefix}-addon-before--${size}`,
        addonAfter: `${clsPrefix}-addon-after--${size}`,
    };
    const handleFocus = (e) => {
        setFocusState(true);
        onFocus(e);
    };
    const handleBlur = (e) => {
        if (isWeb) {
            if (inputRef && inputRef.current && inputRef.current._nativeNode !== document.activeElement) {
                setFocusState(false);
                onBlur(e);
            }
        }
        else {
            setFocusState(false);
            onBlur(e);
        }
    };
    const handleConfirm = (e) => onConfirm(getValueFromEvents(e), e);
    const triggerChange = (v, e) => {
        var _a, _b, _c, _d;
        onChange(v, e);
        if (isWeb) {
            let r;
            try {
                if (isNumber((_a = e === null || e === void 0 ? void 0 : e.target) === null || _a === void 0 ? void 0 : _a.selectionStart) && isNumber((_b = e === null || e === void 0 ? void 0 : e.target) === null || _b === void 0 ? void 0 : _b.selectionEnd)) {
                    r = [e.target.selectionStart, e.target.selectionEnd];
                }
                if (Array.isArray(r) && ((_d = (_c = inputRef === null || inputRef === void 0 ? void 0 : inputRef.current) === null || _c === void 0 ? void 0 : _c._nativeNode) === null || _d === void 0 ? void 0 : _d.setSelectionRange)) {
                    setTimeout(() => {
                        inputRef.current._nativeNode.setSelectionRange(r[0], r[1]);
                    }, 32);
                }
            }
            catch (err) {
            }
        }
    };
    const handleChange = (v, e) => {
        if (isControlled) {
            if (composition.current) {
                setPropValue(v);
            }
        }
        else {
            setValue(v);
        }
        if (composition.current) {
            return;
        }
        triggerChange(v, e);
    };
    const handleClear = (e) => {
        if (disabled || readOnly) {
            return;
        }
        if (e && e.preventDefault) {
            e.preventDefault();
        }
        if (onClear) {
            onClear(e);
        }
        handleChange('', e);
        if (inputRef && inputRef.current) {
            inputRef.current.focus();
        }
    };
    const handleCompositionStart = (e) => {
        composition.current = true;
        if (onCompositionStart) {
            onCompositionStart(e);
        }
    };
    const handleCompositionEnd = (e) => {
        composition.current = false;
        if (onCompositionEnd) {
            onCompositionEnd(e);
        }
        triggerChange(getValueFromEvents(e), e);
    };
    const clearEvt = {
        [isWeb ? 'onTouchEnd' : 'onClick']: handleClear,
    };
    if (compositionProp) {
        others.onCompositionStart = handleCompositionStart;
        others.onCompositionEnd = handleCompositionEnd;
    }
    useImperativeHandle(ref, () => Object.assign(get(inputRef, 'current') || {}));
    return (createElement(View, { className: clses.input },
        addonBefore ? createElement(View, { className: clses.addonBefore }, addonBefore) : null,
        readOnly ? (createElement(Text, { className: clses.textInput, numberOfLines: multiline ? 'auto' : 1 },
            value || placeholder,
            "\u00A0")) : (createElement(View, { className: clses.textInputWrapper },
            innerBefore,
            createElement(TextInput, Object.assign({ ref: inputRef, autoHeight: true }, others, { editable: editable, value: value, keyboardType: keyboardType, multiline: multiline, maxLength: maxLength, numberOfLines: rows, className: clses.textInput }, (isPassword ? { type: 'password' } : null), { secureTextEntry: isPassword, password: isPassword, onFocus: handleFocus, onBlur: handleBlur, onConfirm: handleConfirm, placeholder: placeholder, controlled: controlled, autoFocus: autoFocus || focused, onInput: (e) => handleChange(getValueFromEvents(e), e), onChange: (e) => stopPropagation(e), placeholderColor: undefined, "placeholder-class": `${clsPrefix}-placeholder`, enableNative: enableNative, showCount: false })),
            isNumber(maxLength) && maxLength > 0 && showLimitHint ? (createElement(Text, { className: clses.limitHint },
                value.length || 0,
                "/",
                maxLength)) : null)),
        !multiline ? (createElement(View, { className: `${clsPrefix}-items ${clsPrefix}-items--${size}` },
            showClear ? (createElement(View, Object.assign({ className: `${clsPrefix}-icon-wrapper` }, clearEvt),
                createElement(Icon, { name: "delete-filling", className: clses.clear }))) : null,
            !showClear && state !== 'normal' && hasFeedback ? (createElement(Icon, { className: clses.icon, name: ICON_NAME_MAP[state] })) : null,
            innerAfter,
            addonAfter ? createElement(View, { className: clses.addonAfter }, addonAfter) : null)) : null));
};
Input.displayName = 'Input';
export default forwardRef(Input);
