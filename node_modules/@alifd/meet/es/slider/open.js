import { __rest } from "tslib";
import classNames from 'classnames';
import { Component, createElement, createRef } from 'rax';
import Text from 'rax-text';
import Video from 'rax-video';
import View from '../view';
import Icon from '../icon';
import Modal from '../modal';
import SliderItem from './item';
import Slider from './slider';
import { isStrictMiniApp, isStrictWechatMiniProgram, isString, nextTick, px2rpx, windowHeight } from '../utils';
import { guid } from '../utils/hooks';
import { renderToRoot } from '../utils/render';
import { getContexts, pauseAll } from './util';
class SliderWrapper extends Component {
    constructor(props) {
        super(props);
        this.handleClick = (index) => {
            if (this.props.onClick) {
                this.props.onClick(index);
            }
        };
        this.handleClose = () => {
            const { onClose } = this.props;
            this.setState({
                visible: false,
            });
            if (onClose) {
                onClose();
            }
        };
        this.handleChange = (index) => {
            const { onChange, autoControl = true } = this.props;
            const nodes = getContexts(this.itemRefs, this.state.sliderIdPrefix);
            if (autoControl) {
                pauseAll(nodes);
                if (nodes && nodes[index] && nodes[index].play) {
                    nodes[index].play();
                }
            }
            this.setState({
                curIndex: index,
            });
            if (onChange) {
                onChange(index, nodes, this.itemRefs);
            }
        };
        this.handleItemClick = (isImage) => {
            if (isImage) {
                this.handleClose();
            }
        };
        this.state = {
            visible: true,
            curIndex: props.activeIndex,
            sliderIdPrefix: guid('slider-'),
        };
        this.itemRefs = [];
    }
    componentWillMount() {
        const { items } = this.props;
        for (let i = 0; i < items.length; i++) {
            this.itemRefs[i] = createRef();
        }
    }
    componentDidMount() {
        const { onReady } = this.props;
        if (onReady) {
            nextTick(() => {
                const nodes = getContexts(this.itemRefs, this.state.sliderIdPrefix);
                onReady(nodes, this.itemRefs);
            });
        }
    }
    render() {
        const _a = this.props, { items, activeIndex, prefix = 'mt-', autoPlay } = _a, others = __rest(_a, ["items", "activeIndex", "prefix", "autoPlay"]);
        const sliderHeight = px2rpx(windowHeight);
        const { visible, curIndex } = this.state;
        const clsPrefix = `${prefix}slider`;
        return (createElement(Modal, { className: `${clsPrefix}-modal`, containerClassName: `${clsPrefix}-modal-container`, visible: visible, onClose: this.handleClose },
            createElement(View, { className: `${clsPrefix}-control` },
                createElement(View, { className: `${clsPrefix}-close-wrapper`, onClick: this.handleClose },
                    createElement(Icon, { name: "close", className: `${clsPrefix}-close` })),
                createElement(Text, { className: `${clsPrefix}-pagination` },
                    curIndex + 1,
                    "/",
                    items.length)),
            createElement(Slider, Object.assign({}, others, { activeIndex: activeIndex, showDots: false, width: 750, height: sliderHeight, onChange: this.handleChange }), items.map((item, index) => {
                let _item = item;
                if (isString(item)) {
                    _item = {
                        src: item,
                        type: 'image',
                    };
                }
                const { src, type, height: itemHeight } = _item, rest = __rest(_item, ["src", "type", "height"]);
                const isImage = type === 'image';
                const _height = itemHeight || sliderHeight || '100%';
                let imgStyle = {};
                if (isImage) {
                    imgStyle = {
                        backgroundImage: `url(${_item.src})`,
                        height: _height,
                    };
                }
                return (createElement(SliderItem, { key: `${index}-${item}` },
                    createElement(View, { className: classNames(`${prefix}slider-open-item`, {
                            [`${prefix}slider-open-item--image`]: isImage,
                        }), style: Object.assign({}, imgStyle), onClick: () => {
                            this.handleItemClick(isImage);
                        } }, type === 'video' ? (createElement(Video, Object.assign({ ref: (r) => {
                            this.itemRefs[index] = r;
                        }, id: `${this.state.sliderIdPrefix}-${index}` }, rest, { src: _item.src, style: { width: '750rpx' }, autoPlay: autoPlay, showCenterPlayBtn: true, "enable-progress-gesture": false }))) : null)));
            }))));
    }
}
SliderWrapper.defaultProps = {
    items: [],
    activeIndex: 0,
    onClick: () => { },
    onClose: () => { },
    onChange: () => { },
};
export default function (options) {
    if (isStrictWechatMiniProgram) {
        const { items, activeIndex, onSuccess, onFail, onComplete } = options, others = __rest(options, ["items", "activeIndex", "onSuccess", "onFail", "onComplete"]);
        return wx.previewMedia({
            sources: items.map((item) => (Object.assign(Object.assign({}, item), { url: item.src }))),
            current: activeIndex,
            success: onSuccess,
            fail: onFail,
            complete: onComplete,
            others,
        });
    }
    else if (isStrictMiniApp) {
        const { items, activeIndex, onSuccess, onFail, onComplete } = options, others = __rest(options, ["items", "activeIndex", "onSuccess", "onFail", "onComplete"]);
        return my.previewImage(Object.assign({ urls: items.filter((item) => item.type === 'image').map((item) => item.src), current: activeIndex, success: onSuccess, fail: onFail, complete: onComplete }, others));
    }
    else {
        const unMount = renderToRoot(createElement(SliderWrapper, Object.assign({}, options)));
        return {
            close: () => unMount(),
        };
    }
}
