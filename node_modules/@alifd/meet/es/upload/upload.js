import { __awaiter, __rest } from "tslib";
import { createElement, forwardRef, useCallback, useEffect, useImperativeHandle, useRef, useState, } from 'rax';
import classNames from 'classnames';
import Text from 'rax-text';
import chooseImage from 'universal-choose-image';
import View from '../view';
import Icon from '../icon';
import Message from '../message';
import Card from './item/card';
import { useLocale } from '../locale';
import defaultLang from '../locale/lang/zh-cn';
import { default as defaultRequest } from './request';
import { getWidth, isBoolean, isFunction, isStrictWechatMiniProgram, isString, isValidArray, replaceMessage, } from '../utils';
import { useGuid } from '../utils/hooks';
import { chooseImageForWechat, createFileItem, UPLOAD_THROTTLE } from './utils';
import { isPromise } from '../utils/types';
const FILE_CACHAE = {};
const updateFileStatus = (files = []) => {
    if (!isValidArray(files)) {
        return [];
    }
    return [...files].map((file) => {
        const { uid, state } = file;
        if (FILE_CACHAE[uid] === 'done' && state === 'uploading') {
            file.state = 'done';
        }
        return file;
    });
};
const Upload = (props, ref) => {
    const { prefix = 'mt-', extraIcon, className, action, limit = 1, label = '', value: valueProp, defaultValue, data: dataProp, headers, request, formatter, disabled, cols = 4, size = 'medium', listType = 'card', name: nameProp = 'file', filePicker, withCredentials, fileKeyName, fileType = 'image', accept = 'image/*', useDataURL = true, autoUpload = true, hasRemove = true, showAddButton = true, singleLimit = 9, beforeUpload, afterSelect, onProgress, onSuccess, onError, progressProps, onSelect, onChange, onRemove, onPreview, sizeType = ['original', 'compressed'], sourceType = ['album', 'camera'], children, style } = props, others = __rest(props, ["prefix", "extraIcon", "className", "action", "limit", "label", "value", "defaultValue", "data", "headers", "request", "formatter", "disabled", "cols", "size", "listType", "name", "filePicker", "withCredentials", "fileKeyName", "fileType", "accept", "useDataURL", "autoUpload", "hasRemove", "showAddButton", "singleLimit", "beforeUpload", "afterSelect", "onProgress", "onSuccess", "onError", "progressProps", "onSelect", "onChange", "onRemove", "onPreview", "sizeType", "sourceType", "children", "style"]);
    const name = fileKeyName || nameProp;
    const locale = useLocale('Upload', others, defaultLang.Upload);
    const [itemSize, setItemSize] = useState('0px');
    const [value, setValue] = useState(valueProp || defaultValue || []);
    const newestValue = useRef(value);
    const timerQueue = useRef([]);
    const uploadRef = useRef();
    const uploadId = useGuid('mtUpload');
    const uploadStyle = Object.assign({ gridTemplateColumns: `repeat(${cols}, 1fr)` }, style);
    useEffect(() => {
        if (isValidArray(valueProp)) {
            valueProp.forEach((file) => {
                if (file.state && file.uid) {
                    FILE_CACHAE[file.uid] = file.state;
                }
            });
        }
        setTimeout(() => {
            (() => __awaiter(void 0, void 0, void 0, function* () {
                const width = yield getWidth(uploadId);
                const newCardSize = `calc(((${width}px - var(--upload-card-spacing)*${cols - 1} )) / ${cols})`;
                setItemSize(newCardSize);
            }))();
        }, 200);
        return () => {
            timerQueue.current.forEach((x) => clearInterval(x));
            timerQueue.current = [];
        };
    }, []);
    const getFile = useCallback((uid) => {
        const item = newestValue.current.find((it) => it.uid === uid);
        if (item) {
            return {
                file: item,
                index: newestValue.current.indexOf(item),
            };
        }
        return undefined;
    }, []);
    const updateFile = useCallback((uid, mod) => {
        const gotFile = getFile(uid);
        if (!gotFile) {
            throw new Error(`File id ${uid} not found`);
        }
        const { file, index } = gotFile;
        if (mod.state) {
            FILE_CACHAE[uid] = mod.state;
        }
        let isSame = true;
        for (const k in mod) {
            if (mod.hasOwnProperty(k) && file[k] !== mod[k]) {
                isSame = false;
                break;
            }
        }
        if (isSame) {
            return file;
        }
        const newFile = Object.assign(Object.assign({}, file), mod);
        const newValue = [...newestValue.current];
        newValue.splice(index, 1, newFile);
        newestValue.current = newValue;
        if (onChange) {
            onChange(newValue);
        }
        if (!('value' in props)) {
            setValue(newValue);
        }
        return newFile;
    }, [valueProp, onChange]);
    const uploadFiles = useCallback((files) => {
        const uploadFile = (it) => __awaiter(void 0, void 0, void 0, function* () {
            if (it.state !== 'selected') {
                return;
            }
            const { uid } = it;
            updateFile(uid, {
                state: 'pending',
            });
            let options = {
                action,
                data: dataProp || {},
                headers: headers || {},
            };
            if (isFunction(options.data)) {
                options.data = options.data();
            }
            if (beforeUpload) {
                try {
                    const res = beforeUpload(it, options);
                    if (isBoolean(res)) {
                        if (res === false) {
                            updateFile(uid, {
                                state: 'uploading',
                            });
                            return;
                        }
                    }
                    else if (isPromise(res)) {
                        options = yield res;
                    }
                    else {
                        options = res;
                    }
                }
                catch (e) {
                    updateFile(uid, {
                        state: 'error',
                    });
                    console.error(e);
                    return;
                }
            }
            let curFile = updateFile(uid, {
                state: 'uploading',
            });
            if (onProgress) {
                onProgress();
            }
            if (!(options === null || options === void 0 ? void 0 : options.action)) {
                console.warn('Upload request failed,  action prop is required');
                curFile = updateFile(uid, {
                    state: 'error',
                });
                if (onError) {
                    onError(curFile, newestValue.current);
                }
                return;
            }
            let timer = null;
            const clearTimer = () => {
                if (timer && timerQueue.current.includes(timer)) {
                    clearInterval(timer);
                    timerQueue.current.splice(timerQueue.current.indexOf(timer), 1);
                }
                timer = null;
            };
            const complete = () => clearTimer();
            let newProcess = 0;
            yield new Promise((resolve, reject) => {
                const requestObj = {
                    onProgress: (ev) => {
                        if (curFile.state !== 'uploading') {
                            return;
                        }
                        if (!timer) {
                            timer = setInterval(() => {
                                if (curFile.state !== 'uploading') {
                                    clearTimer();
                                    return;
                                }
                                curFile = updateFile(uid, {
                                    state: 'uploading',
                                    percent: newProcess,
                                });
                                if (newProcess === 100) {
                                    clearTimer();
                                }
                            }, UPLOAD_THROTTLE);
                            timerQueue.current.push(timer);
                        }
                        newProcess = ev.percent;
                    },
                    onError: (err, body) => {
                        console.error('Upload request failed', err);
                        curFile = updateFile(uid, {
                            state: 'error',
                            response: body,
                        });
                        if (onError) {
                            onError(curFile, newestValue.current);
                        }
                        resolve('error');
                        complete();
                    },
                    onSuccess: (res) => {
                        res.status = res.statusCode;
                        if (isString(res.data)) {
                            try {
                                res.data = JSON.parse(res.data);
                            }
                            catch (e) {
                            }
                        }
                        const result = formatter ? formatter(res, it) : res.data;
                        if (typeof result !== 'object') {
                            console.error(`Expect a json object response, ${result} got`);
                            curFile = updateFile(uid, {
                                state: 'error',
                            });
                            if (onError) {
                                onError(curFile, newestValue.current);
                            }
                            resolve('error');
                            return;
                        }
                        const finalState = {
                            response: result,
                            percent: 100,
                            state: result.success ? 'done' : 'error',
                        };
                        if (result.success && result.url) {
                            finalState.url = result.url;
                            finalState.imgURL = result.imgURL || result.url;
                            finalState.downloadURL = result.downloadURL || result.url;
                        }
                        curFile = updateFile(uid, finalState);
                        if (finalState.state === 'done' && onSuccess) {
                            onSuccess(curFile, newestValue.current);
                        }
                        if (finalState.state === 'error' && onError) {
                            onError(curFile, newestValue.current);
                        }
                        clearTimer();
                        resolve('success');
                    },
                    fileType,
                    data: options.data,
                    filename: name,
                    file: it.file,
                    withCredentials,
                    action: options.action,
                    method: 'post',
                    timeout: 0,
                    headers: options.headers,
                };
                if (request) {
                    request(requestObj);
                }
                else {
                    defaultRequest(requestObj);
                }
            });
        });
        if (!isValidArray(files)) {
            return;
        }
        try {
            Promise.all(files.map((it) => uploadFile(it))).then(() => {
                const arr = updateFileStatus(newestValue.current);
                if (arr) {
                    if (isFunction(onChange)) {
                        onChange(arr);
                    }
                    if (!('value' in props)) {
                        setValue(arr);
                        newestValue.current = arr;
                    }
                }
            });
        }
        catch (e) {
            console.warn('上传失败');
        }
    }, [action, dataProp, headers, beforeUpload, onProgress, formatter, onSuccess, onError, request]);
    const doUpload = useCallback(() => uploadFiles(newestValue.current.filter((it) => it.state === 'selected')), []);
    const doReUpload = useCallback((it) => {
        updateFile(it.uid, {
            state: 'selected',
            percent: 0,
        });
        doUpload();
    }, []);
    const handleAdd = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        if (limit <= newestValue.current.length || disabled) {
            Message.notice(replaceMessage(locale.limit, { limit }));
            return;
        }
        let file;
        const defaultSizeType = ['original', 'compressed'];
        const defaultSourceType = ['album', 'camera'];
        try {
            if (isFunction(filePicker)) {
                file = yield filePicker();
            }
            else if (isStrictWechatMiniProgram) {
                let mediaType = ['video', 'image'];
                if (accept === 'image/*') {
                    mediaType = ['image'];
                }
                else if (accept === 'video/*') {
                    mediaType = ['video'];
                }
                file = yield chooseImageForWechat({
                    count: Math.min(singleLimit, limit - newestValue.current.length),
                    mediaType,
                    sizeType: sizeType || defaultSizeType,
                    sourceType: sourceType || defaultSourceType,
                });
            }
            else {
                file = yield chooseImage({
                    count: Math.min(singleLimit, limit - newestValue.current.length),
                    accept,
                    sizeType: sizeType || defaultSizeType,
                    sourceType: sourceType || defaultSourceType,
                });
            }
        }
        catch (e) {
            console.error(e);
        }
        if (!file || !Array.isArray(file === null || file === void 0 ? void 0 : file.data)) {
            return;
        }
        let fileItems = file.data.map((it, index) => {
            return createFileItem(it, file.files ? file.files[index] : null);
        });
        if (afterSelect) {
            fileItems = fileItems.filter((it) => afterSelect(it) !== false);
        }
        if (useDataURL) {
            fileItems.forEach((it) => {
                if (it.dataURL && it.isImage) {
                    it.imgURL = it.dataURL;
                }
            });
        }
        if (onSelect) {
            onSelect();
        }
        const newValue = [...newestValue.current, ...fileItems];
        if (onChange) {
            onChange(newValue);
        }
        if (!('value' in props)) {
            setValue(newValue);
            newestValue.current = newValue;
        }
        if (autoUpload) {
            doUpload();
        }
    }), [limit, disabled, locale, sizeType, sourceType, afterSelect, autoUpload, onSelect, onChange]);
    const handleRemove = useCallback((file) => {
        const doRemove = () => {
            const index = newestValue.current.indexOf(file);
            if (index === -1) {
                return;
            }
            const newValue = [...newestValue.current];
            newValue.splice(index, 1);
            if (onChange) {
                onChange(newValue);
            }
            if (!('value' in props)) {
                setValue(newValue);
                newestValue.current = newValue;
            }
        };
        if (!onRemove) {
            doRemove();
            return;
        }
        const result = onRemove(file);
        if (isBoolean(result)) {
            if (result === true) {
                doRemove();
            }
            return;
        }
        if (isPromise(result)) {
            result.then((should) => should && doRemove()).catch(() => { });
        }
    }, [onChange, onRemove]);
    const handleItemClick = useCallback((file, e) => {
        if (onPreview) {
            onPreview(file, Object.assign(Object.assign({}, e), { fileList: value }));
        }
    }, [onPreview]);
    useEffect(() => {
        if ('value' in props) {
            newestValue.current = updateFileStatus(valueProp || defaultValue || []);
            setValue(newestValue.current);
            if (autoUpload) {
                doUpload();
            }
        }
    }, [valueProp]);
    useImperativeHandle(ref, () => {
        return Object.assign(uploadRef.current, {
            add: handleAdd,
            upload: doUpload,
            getInstance() {
                return {
                    startUpload: doUpload,
                };
            },
        });
    });
    const clsPrefix = `${prefix}upload`;
    const hasAdd = showAddButton && limit > value.length && !disabled;
    const ItemComponent = Card;
    return (createElement(View, { id: uploadId, ref: uploadRef },
        label || extraIcon ? (createElement(View, { className: `${clsPrefix}-header` },
            createElement(Text, { className: `${clsPrefix}-label ${clsPrefix}-label--${size}` }, label),
            extraIcon ? (createElement(View, { className: `${clsPrefix}-extra` },
                createElement(Text, { className: `${clsPrefix}-counter` },
                    value.length || 0,
                    "/",
                    limit),
                createElement(Icon, { className: `${clsPrefix}-extra-icon`, size: size, onClick: handleAdd, name: extraIcon }))) : null)) : null,
        createElement(View, Object.assign({ className: classNames(clsPrefix, `${clsPrefix}--${listType}`, className), style: uploadStyle }, others),
            value.map((file) => {
                return (createElement(ItemComponent, { key: file.uid, file: file, prefix: clsPrefix, progressProps: progressProps, onClick: handleItemClick, reUpload: locale.reupload, onReUpload: doReUpload, hasRemove: hasRemove && !disabled, onRemove: handleRemove, style: {
                        width: `${itemSize}`,
                        height: `${itemSize}`,
                    } }));
            }),
            hasAdd && (createElement(View, { className: classNames(`${clsPrefix}-item`, `${clsPrefix}-item--add`, `${clsPrefix}-item--${listType}`), onClick: handleAdd, style: {
                    width: `${itemSize}`,
                    height: `${itemSize}`,
                } }, children ? children : createElement(Icon, { className: `${clsPrefix}-item-icon`, name: "add" }))))));
};
Upload.displayName = 'Upload';
export default forwardRef(Upload);
