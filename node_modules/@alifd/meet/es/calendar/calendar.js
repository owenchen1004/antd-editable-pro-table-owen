import { __rest } from "tslib";
import { createElement, forwardRef, useState, createRef, useEffect } from 'rax';
import classNames from 'classnames';
import dayjs from 'dayjs';
import RaxSlider from 'rax-slider';
import View from '../view';
import CalendarContent from './content';
import CalendarHeader from './header';
import CalendarTimePicker from './time-picker';
import { useLocale } from '../locale';
import { isValidDate, toDate } from '../utils/date';
import { HeaderType } from './types';
import { cloneDate, genContentHeight, getMaxMinDate, getTargetDate, NOW, genTotalPageDates, getSelectedIndex, } from './utils';
import { isValidArray } from '../utils';
const defaultLocale = {
    weekdays: ['日', '一', '二', '三', '四', '五', '六'],
    months: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    year: '年',
    month: '月',
    day: '日',
    timePickerLabel: '选择时间',
};
function formatValue(value) {
    if (!value) {
        return undefined;
    }
    if (Array.isArray(value)) {
        return value.map((it) => toDate(it));
    }
    return toDate(value);
}
const Calendar = (props, ref) => {
    const { prefix = 'mt-', defaultValue, value, shape = 'panel', mode = 'month', validRange, onSelect = () => { }, dateCellRender, monthCellRender, disabledDate, onModeChange, needSlider = false, enableYearPicker = false, enableTimePicker = false, timeFormat = 'HH:mm:ss', sliderHeight = genContentHeight(mode), sliderWidth = '750', renderCellBottom, renderCellRight, renderHeadLeft, renderHeadRight, firstDay, fixSliderNumber } = props, others = __rest(props, ["prefix", "defaultValue", "value", "shape", "mode", "validRange", "onSelect", "dateCellRender", "monthCellRender", "disabledDate", "onModeChange", "needSlider", "enableYearPicker", "enableTimePicker", "timeFormat", "sliderHeight", "sliderWidth", "renderCellBottom", "renderCellRight", "renderHeadLeft", "renderHeadRight", "firstDay", "fixSliderNumber"]);
    const genInitVisibleDate = (sValue) => {
        let date = NOW;
        if (sValue) {
            if (Array.isArray(sValue)) {
                if (sValue.length > 0 && sValue[0]) {
                    date = sValue[0];
                }
            }
            else {
                date = sValue;
            }
        }
        if (firstDay && mode === 'week') {
            const tempDay = dayjs(date).day(firstDay);
            date = new Date(tempDay.valueOf());
        }
        return cloneDate(date);
    };
    const genInitSelectedDate = (sValue, dValue, vShape) => {
        const tempSDate = sValue || dValue;
        if (tempSDate) {
            return tempSDate;
        }
        if (vShape === 'range') {
            return [];
        }
        if (vShape === 'multi') {
            return [];
        }
        return null;
    };
    const locale = useLocale('Calendar', others, defaultLocale);
    let selectedDate = genInitSelectedDate(formatValue(value), formatValue(defaultValue), shape);
    const [minDate, maxDate] = getMaxMinDate(validRange);
    const [currentMode, changeCurrentMode] = useState(mode);
    const [visibleDate, changeVisibleDate] = useState(genInitVisibleDate(Array.isArray(selectedDate) && selectedDate.length === 0 && ['range', 'multi'].indexOf(shape) > -1
        ? minDate
        : selectedDate));
    const [preVisibleDate, changePreVisibleDate] = useState(getTargetDate(mode, visibleDate, 'pre', maxDate, minDate));
    const [currentVisibleDate, changeCurrentVisibleDate] = useState(visibleDate);
    const [nextVisibleDate, changeNextVisibleDate] = useState(getTargetDate(mode, visibleDate, 'next', maxDate, minDate));
    const totalPageDates = fixSliderNumber ? genTotalPageDates(minDate, maxDate, mode, visibleDate, firstDay) : [];
    const defaultIndex = getSelectedIndex(totalPageDates, visibleDate);
    const [currentPage, changeCurrentPage] = useState(defaultIndex);
    const [showYearPicker, setYearPickerShow] = useState(false);
    const [showTimePicker, setTimePickerShow] = useState(false);
    const sliderRef = createRef();
    const showTimePickerNode = enableTimePicker && mode === 'month' && shape === 'panel' && !needSlider;
    useEffect(() => changeVisibleDate(genInitVisibleDate(Array.isArray(selectedDate) && selectedDate.length === 0 && ['range', 'multi'].indexOf(shape) > -1
        ? minDate
        : selectedDate)), [value, shape]);
    if (showTimePickerNode && !selectedDate) {
        selectedDate = new Date();
    }
    const renderContent = () => renderContentWithVisibleDate(visibleDate);
    const renderContentWithVisibleDate = (visibleD) => {
        const shapeContentMap = {
            fullscreen: 'fullscreen',
            range: 'range',
            multi: 'multi',
        };
        const contentType = shapeContentMap[shape] || 'normal';
        return (createElement(CalendarContent, { prefix: prefix, selectedDate: selectedDate, visibleDate: visibleD, type: contentType, firstDay: firstDay, mode: onModeChange ? mode : currentMode, enableTimePicker: showTimePickerNode, onDateChange: (newValue, clickedItem) => {
                if (!onSelect) {
                    return;
                }
                if (showTimePickerNode) {
                    const _d = selectedDate ? dayjs(selectedDate) : dayjs(new Date());
                    const h = _d.hour();
                    const m = _d.minute();
                    const s = _d.second();
                    const newDate = dayjs(newValue)
                        .hour(h)
                        .minute(m)
                        .second(s);
                    onSelect(newDate.toDate());
                }
                else {
                    onSelect(newValue);
                }
            }, maxDate: maxDate, minDate: minDate, disabledDate: disabledDate, locale: locale, renderCellBottom: renderCellBottom, renderCellRight: renderCellRight, dateCellRender: dateCellRender, monthCellRender: monthCellRender }));
    };
    const getShapeType = () => {
        let headerType = HeaderType.normal;
        if (shape === 'fullscreen' || (shape === 'card' && mode !== 'week')) {
            headerType = HeaderType.select;
        }
        return headerType;
    };
    const renderHeader = () => (createElement(CalendarHeader, { prefix: prefix, date: visibleDate, maxDate: maxDate, minDate: minDate, enableYearPicker: enableYearPicker && !needSlider, enableTimePicker: showTimePickerNode, mode: onModeChange ? mode : currentMode, type: getShapeType(), locale: locale, renderHeadLeft: renderHeadLeft, renderHeadRight: renderHeadRight, onPickerShow: (show) => setYearPickerShow(show), disabledDate: disabledDate, onModeChange: (v) => {
            if (onModeChange) {
                onModeChange(v);
                return;
            }
            changeCurrentMode(v);
        }, onDateChange: (date, isAdd, changeMode) => {
            if (changeMode === 'picker') {
                const d = dayjs(date);
                const y = d.year();
                const m = d.month();
                const firstDayOfMonth = dayjs(`${y}-${m + 1}-01`);
                let day = isValidDate(selectedDate) ? dayjs(selectedDate).date() : 1;
                if (firstDayOfMonth.daysInMonth() < day) {
                    day = firstDayOfMonth.daysInMonth();
                }
                if (shape !== 'range' && shape !== 'multi') {
                    let sd = dayjs(`${y}-${m + 1}-${day}`);
                    if (isValidArray(validRange)) {
                        if (sd.isAfter(validRange[1])) {
                            sd = dayjs(validRange[1]);
                        }
                        else if (sd.isBefore(validRange[0])) {
                            sd = dayjs(validRange[0]);
                        }
                    }
                    onSelect(sd.toDate());
                }
                changeVisibleDate(date);
                return;
            }
            if (fixSliderNumber) {
                let sliderIndex = currentPage;
                if (isAdd) {
                    sliderIndex = sliderIndex + 1;
                }
                else {
                    sliderIndex = sliderIndex - 1;
                }
                if (sliderIndex >= 0 && sliderIndex <= totalPageDates.length - 1) {
                    sliderRef.current.slideTo(sliderIndex);
                }
                return;
            }
            changeVisibleDate(date);
            let newPre;
            let newCurrent;
            let newNext;
            if (isAdd) {
                newPre = getTargetDate(changeMode, preVisibleDate, 'next', maxDate, minDate);
                newCurrent = getTargetDate(changeMode, currentVisibleDate, 'next', maxDate, minDate);
                newNext = getTargetDate(changeMode, nextVisibleDate, 'next', maxDate, minDate);
            }
            else {
                newPre = getTargetDate(changeMode, preVisibleDate, 'pre', maxDate, minDate);
                newCurrent = getTargetDate(changeMode, currentVisibleDate, 'pre', maxDate, minDate);
                newNext = getTargetDate(changeMode, nextVisibleDate, 'pre', maxDate, minDate);
            }
            changeCurrentVisibleDate(newCurrent);
            changePreVisibleDate(newPre);
            changeNextVisibleDate(newNext);
        } }));
    const genSliderItems = () => {
        const preItem = createElement(RaxSlider.Item, { key: "Slider.Item.0" }, renderContentWithVisibleDate(preVisibleDate));
        const currentItem = (createElement(RaxSlider.Item, { key: "Slider.Item.1" }, renderContentWithVisibleDate(currentVisibleDate)));
        const nextItem = (createElement(RaxSlider.Item, { key: "Slider.Item.2" }, renderContentWithVisibleDate(nextVisibleDate)));
        return [preItem, currentItem, nextItem];
    };
    const dealSliderChange = (oldIndex, newIndex) => {
        if (oldIndex === newIndex) {
            return;
        }
        let newVisible;
        let newPre = preVisibleDate;
        let newCurrent = currentVisibleDate;
        let newNext = nextVisibleDate;
        if (oldIndex === 2 && newIndex === 0) {
            newVisible = getTargetDate(mode, visibleDate, 'next', maxDate, minDate);
            newCurrent = getTargetDate(mode, newVisible, 'next', maxDate, minDate);
        }
        else {
            if (oldIndex === 0 && newIndex === 2) {
                newVisible = getTargetDate(mode, visibleDate, 'pre', maxDate, minDate);
                newCurrent = getTargetDate(mode, newVisible, 'pre', maxDate, minDate);
            }
            else {
                if (newIndex > oldIndex) {
                    newVisible = getTargetDate(mode, visibleDate, 'next', maxDate, minDate);
                    if (newIndex === 1) {
                        newNext = getTargetDate(mode, newVisible, 'next', maxDate, minDate);
                    }
                    if (newIndex === 2) {
                        newPre = getTargetDate(mode, newVisible, 'next', maxDate, minDate);
                    }
                }
                if (newIndex < oldIndex) {
                    newVisible = getTargetDate(mode, visibleDate, 'pre', maxDate, minDate);
                    if (newIndex === 0) {
                        newNext = getTargetDate(mode, newVisible, 'pre', maxDate, minDate);
                    }
                    if (newIndex === 1) {
                        newPre = getTargetDate(mode, newVisible, 'pre', maxDate, minDate);
                    }
                }
            }
        }
        changeVisibleDate(newVisible);
        changeCurrentVisibleDate(newCurrent);
        changeNextVisibleDate(newNext);
        changePreVisibleDate(newPre);
    };
    const renderFixSliderContent = () => {
        const items = [];
        for (let i = 0; i < totalPageDates.length; i++) {
            items.push(createElement(RaxSlider.Item, { key: 'Slider.Item.' + 'i' }, renderContentWithVisibleDate(totalPageDates[i])));
        }
        return (createElement(RaxSlider, { ref: sliderRef, autoPlay: false, showsPagination: false, index: defaultIndex, loop: false, width: sliderWidth, height: sliderHeight, direction: "horizontal", onChange: (index) => changeCurrentPage(index.index) }, items));
    };
    const renderSliderContent = () => {
        if (fixSliderNumber) {
            return renderFixSliderContent();
        }
        return (createElement(RaxSlider, { autoPlay: false, showsPagination: false, index: 1, width: sliderWidth, height: sliderHeight, direction: "horizontal", onChange: (index) => {
                dealSliderChange(currentPage, index.index);
                changeCurrentPage(index.index);
            } }, genSliderItems()));
    };
    const renderCalendar = () => {
        const s = getShapeType();
        if (needSlider && s === 'normal') {
            return renderSliderContent();
        }
        return renderContent();
    };
    const handleTimePickerToggle = (show) => setTimePickerShow(show);
    return (createElement(View, Object.assign({ ref: ref }, others, { className: classNames(`${prefix}calendar`, `${prefix}calendar-${shape}`, `${prefix}calendar-${shape}-${currentMode}`) }),
        !showTimePicker ? renderHeader() : null,
        !showYearPicker && !showTimePicker ? renderCalendar() : null,
        showTimePickerNode && !showYearPicker && (createElement(CalendarTimePicker, { value: selectedDate, format: timeFormat, label: locale.timePickerLabel, onPickerToggle: handleTimePickerToggle, onChange: (date) => {
                if (onSelect) {
                    onSelect(date);
                }
            } }))));
};
Calendar.displayName = 'Calendar';
export default forwardRef(Calendar);
