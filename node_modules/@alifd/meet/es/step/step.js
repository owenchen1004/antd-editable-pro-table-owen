import { __awaiter, __rest } from "tslib";
import { createElement, forwardRef, useEffect, useState } from 'rax';
import classNames from 'classnames';
import { getBoundingClientRect } from 'universal-element';
import Children from 'rax-children';
import isValidElement from 'rax-is-valid-element';
import cloneElement from 'rax-clone-element';
import ScrollView from 'rax-scrollview';
import View from '../view';
import Item from './item';
import { getWidth, isStrictWechatMiniProgram, get } from '../utils';
import { useGuid } from '../utils/hooks';
const getCurrent = (props) => {
    const { current, children } = props;
    const childCount = Children.count(children);
    let newCurrent = current;
    if (isNaN(current) || current < -1) {
        newCurrent = -1;
    }
    else if (current > childCount) {
        newCurrent = childCount - 1;
    }
    return newCurrent;
};
const Step = (props, ref) => {
    const { prefix = 'mt-', shape = 'circle', children, disabled = false, readOnly = false, direction: directionProp = 'hoz', className, onChange, } = props;
    const clsPrefix = `${prefix}step`;
    const direction = shape === 'arrow' ? 'hoz' : directionProp;
    const [isOverflow, setOverflow] = useState(false);
    const clses = {
        step: classNames(className, `${clsPrefix}`, {
            [`${clsPrefix}--scroll`]: isOverflow,
            [`${clsPrefix}--wechat-${shape}`]: isStrictWechatMiniProgram && direction === 'hoz',
        }),
        container: classNames(`${clsPrefix}-container`, `${clsPrefix}-container--${direction}`, {
            [`${clsPrefix}-container--scroll`]: isOverflow,
        }),
    };
    const validChildren = Children.toArray(children).filter((child) => {
        return isValidElement(child) && child.type === Item;
    }) || [];
    const childrenCount = validChildren.length;
    const current = getCurrent(props);
    const disabledIndexes = validChildren
        .map((child, index) => (disabled || get(child, 'props.disabled') ? index : null))
        .filter((item) => item !== null);
    const stepId = useGuid('step-');
    const stepContainerId = useGuid('step-container-');
    const Parent = direction === 'hoz' ? ScrollView : View;
    if (shape === 'arrow' && directionProp === 'ver') {
        console.warn('arrow shape support hoz direction only');
    }
    useEffect(() => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            const width = yield getWidth(stepId);
            const containerWidth = yield getWidth(stepContainerId);
            if (isStrictWechatMiniProgram) {
                const ele = document.getElementById(stepContainerId);
                if (ele && ele._internal) {
                    getBoundingClientRect(`#${stepId}`, ele._internal).then((res) => {
                        if (res && res[0] && res[0].width) {
                            const w = res[0].width;
                            setOverflow(w >= containerWidth);
                        }
                    });
                }
            }
            else {
                setOverflow(width >= containerWidth);
            }
        }))();
    });
    const renderChildren = () => {
        return validChildren.map((child, index) => {
            const childProps = child.props;
            const { disabled: childDisabled, status: childStatusProp, className: childClassName, onClick: childOnClick } = childProps, others = __rest(childProps, ["disabled", "status", "className", "onClick"]);
            let status = childStatusProp;
            if (!childStatusProp) {
                status = 'wait';
                if (index === current) {
                    status = 'process';
                }
                else if (index < current) {
                    status = 'finish';
                }
            }
            return cloneElement(child, Object.assign(Object.assign({ key: `mt_step_${index}` }, others), { order: index, isFirst: index === 0, isLast: index === childrenCount - 1, isPreDisabled: disabledIndexes.indexOf(index - 1) > -1, shape,
                direction,
                status,
                prefix, onClick: () => {
                    if (childOnClick) {
                        childOnClick(index);
                    }
                    if (onChange && !readOnly && !disabled && !childDisabled) {
                        onChange(index);
                    }
                }, className: classNames(childClassName, `${clsPrefix}-item--${direction}`) }));
        });
    };
    return (createElement(Parent, { id: stepContainerId, ref: ref, className: clses.step, horizontal: true },
        createElement(View, { id: stepId, className: clses.container }, renderChildren())));
};
Step.displayName = 'Step';
export default forwardRef(Step);
