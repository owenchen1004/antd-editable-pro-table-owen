import { __rest } from "tslib";
import { createElement, forwardRef, Fragment, useCallback, useContext, useEffect, useMemo, useRef, useState, useImperativeHandle, } from 'rax';
import classNames from 'classnames';
import Text from 'rax-text';
import View from '../view';
import { ItemContext } from '../form';
import BottomButton from '../bottom-button';
import SelectDrawer from '../select-drawer';
import { useLocale } from '../locale';
import defaultLang from '../locale/lang/zh-cn';
import { useValue } from '../utils/hooks';
import { findInArray, getDataSource, isFunction, isString, isValidArray } from '../utils';
import SelectBody from './section/select-body';
import SelectSearch from './section/select-search';
import SelectedListDrawer from './section/selected-list-drawer';
import SelectContext from './context';
import { defaultLocalFilter, getValidEvtValues, innerRenderSelection, isEqualItems } from './util';
const AUTO_CLOSE_WAITING_TIME = 300;
const compare = (a, b) => isEqualItems(a, b, true);
const BaseSelect = (props, ref) => {
    const { prefix = 'mt-', placeholder, value: _value, type, defaultValue, className, mode, hasSearch, children, dataSource: _dataSource, displayType, disabled, autoConfirm, hasClear, filterLocal, transferSearchToOption, filter = defaultLocalFilter, renderSelection, useDetailValue, locale: _locale, size: sizeProp, notFoundContent, onVisibleChange, onChange = () => { }, onClear = () => { }, onCancel = () => { }, onOk = () => { }, onSearch, drawerClassName } = props, others = __rest(props, ["prefix", "placeholder", "value", "type", "defaultValue", "className", "mode", "hasSearch", "children", "dataSource", "displayType", "disabled", "autoConfirm", "hasClear", "filterLocal", "transferSearchToOption", "filter", "renderSelection", "useDetailValue", "locale", "size", "notFoundContent", "onVisibleChange", "onChange", "onClear", "onCancel", "onOk", "onSearch", "drawerClassName"]);
    const { isInsideForm, size: contextSize } = useContext(ItemContext);
    const size = sizeProp || (isInsideForm ? contextSize : 'medium');
    const [searchVal, setSearchVal] = useState('');
    const [drawerVisible, setDrawerVisible] = useState(false);
    const selectLocale = useLocale('Select', props, defaultLang.Select);
    const selectDrawerLocal = useLocale('SelectDrawer', {}, defaultLang.SelectDrawer);
    const clsPrefix = `${prefix}select`;
    const baseSelectRef = useRef(null);
    const dataSource = useMemo(() => {
        return getDataSource(props.dataSource, props.children);
    }, [props.dataSource, props.children]);
    const fitValue = (v) => {
        if (v === '' || v === null) {
            return [];
        }
        const x = Array.isArray(v) ? v : [v];
        if (useDetailValue) {
            return x;
        }
        else if (isValidArray(x)) {
            return x.map((item) => {
                const tmp = findInArray(dataSource, (d) => d.value === item);
                return (tmp || {
                    label: item,
                    value: item,
                });
            });
        }
        else {
            return [];
        }
    };
    const [value, setValue, isControlled] = useValue(props, [], {
        fitValue,
        compare,
    });
    const [innerValue, setInnerValue] = useState(value);
    const [confirmVisible, setConfirmVisible] = useState(false);
    const isSingle = mode === 'single';
    const searchRef = useRef(null);
    const realHasSearch = props.hasSearch || props.showSearch;
    useMemo(() => {
        if (isControlled && !compare(value, innerValue)) {
            setInnerValue(value);
        }
    }, [value]);
    const handleCancel = useCallback((reason) => {
        if (searchRef && searchRef.current) {
            searchRef.current.setValue('');
        }
        if (isFunction(onCancel)) {
            onCancel(reason);
        }
        setTimeout(() => {
            setInnerValue(value);
        }, 300);
    }, [value]);
    const handleOk = () => {
        if (!isControlled) {
            setValue(innerValue);
        }
        const changed = !isEqualItems(value, innerValue);
        if (isFunction(onOk)) {
            onOk();
        }
        if (changed && isFunction(onChange)) {
            const { value: val, items } = getValidEvtValues({
                selectedItems: innerValue,
                isSingle,
                useDetailValue,
            });
            onChange(val, 'change', items);
        }
        if (searchRef === null || searchRef === void 0 ? void 0 : searchRef.current) {
            searchRef.current.setValue('');
        }
    };
    const handleTotalClick = () => {
        setConfirmVisible(true);
    };
    const handleClear = () => {
        if (!isControlled) {
            setValue([]);
            setInnerValue([]);
            if (searchRef === null || searchRef === void 0 ? void 0 : searchRef.current) {
                searchRef.current.setValue('');
            }
        }
        if (isFunction(onClear)) {
            onClear();
        }
        if (isFunction(onChange)) {
            const { value: val, items } = getValidEvtValues({
                selectedItems: [],
                useDetailValue,
                isSingle,
            });
            onChange(val, 'clear', items);
        }
    };
    const handleConfirmDone = (items) => {
        setInnerValue(items);
        setConfirmVisible(false);
    };
    const handleConfirmCancel = () => {
        setConfirmVisible(false);
    };
    const handleBottomOk = () => {
        var _a;
        if ((_a = baseSelectRef === null || baseSelectRef === void 0 ? void 0 : baseSelectRef.current) === null || _a === void 0 ? void 0 : _a.ok) {
            baseSelectRef.current.ok();
        }
    };
    const handleBottomCancel = () => {
        var _a;
        if ((_a = baseSelectRef === null || baseSelectRef === void 0 ? void 0 : baseSelectRef.current) === null || _a === void 0 ? void 0 : _a.cancel) {
            baseSelectRef.current.cancel('cancel-button');
        }
    };
    const handleVisibleChange = (visible) => {
        setDrawerVisible(visible);
        if (isFunction(onVisibleChange)) {
            onVisibleChange(visible);
        }
    };
    const contextValue = useMemo(() => {
        return Object.assign(Object.assign({}, props), { hasSearch: realHasSearch, dataSource,
            type,
            mode,
            size,
            prefix,
            value,
            innerValue,
            displayType, locale: selectLocale, onChange: (v) => {
                setInnerValue(v);
            }, searchValue: searchVal, setSearchValue: setSearchVal });
    }, [
        props,
        realHasSearch,
        dataSource,
        type,
        mode,
        size,
        prefix,
        value,
        innerValue,
        displayType,
        selectLocale,
        searchVal,
    ]);
    useEffect(() => {
        if (drawerVisible && isSingle && !realHasSearch && autoConfirm === true) {
            setTimeout(() => {
                var _a;
                if ((_a = baseSelectRef === null || baseSelectRef === void 0 ? void 0 : baseSelectRef.current) === null || _a === void 0 ? void 0 : _a.ok) {
                    baseSelectRef.current.ok();
                }
            }, AUTO_CLOSE_WAITING_TIME);
        }
    }, [innerValue]);
    useImperativeHandle(ref, () => Object.assign(baseSelectRef.current));
    return (createElement(Fragment, null,
        createElement(SelectDrawer, Object.assign({}, others, { hideButton: isSingle && autoConfirm === true, size: size, ref: baseSelectRef, showToolbar: !realHasSearch, type: type, disabled: disabled, placeholder: placeholder, hasClear: hasClear, className: classNames(clsPrefix, className), content: renderSelection ? renderSelection(value) : innerRenderSelection(value, contextValue), onClear: handleClear, onCancel: handleCancel, onOk: handleOk, onVisibleChange: handleVisibleChange, drawerClassName: classNames(drawerClassName, {
                [`${clsPrefix}--searchable`]: realHasSearch,
            }) }),
            createElement(SelectContext.Provider, { value: contextValue },
                createElement(Fragment, null,
                    realHasSearch && createElement(SelectSearch, { ref: searchRef }),
                    dataSource.length === 0 && !realHasSearch ? (createElement(View, { className: `${clsPrefix}-drawer-content ${clsPrefix}drawer-drawer--empty` }, isString(notFoundContent) ? (createElement(Text, { className: `${clsPrefix}drawer-drawer-empty-text` }, notFoundContent)) : (createElement(View, { className: `${clsPrefix}drawer-drawer-empty-text` }, notFoundContent)))) : (createElement(View, { className: `${clsPrefix}-option-list` },
                        createElement(SelectBody, { emptySearchText: selectLocale.emptySearchText, searchToOptionBtnText: selectLocale.searchToOptionBtnText }))),
                    realHasSearch && (createElement(View, { className: `${clsPrefix}-drawer-footer` },
                        createElement(BottomButton, { okText: selectDrawerLocal.ok, cancelText: selectDrawerLocal.cancel, onOk: handleBottomOk, onCancel: handleBottomCancel }, !isSingle && (createElement(View, { className: `${clsPrefix}-footer-counter`, onClick: handleTotalClick },
                            createElement(Text, null, selectLocale.totalPrefixText),
                            createElement(Text, { className: `${clsPrefix}-total-num` }, innerValue.length),
                            createElement(Text, null, selectLocale.totalSuffixText))))))))),
        !isSingle && (createElement(SelectedListDrawer, { prefix: contextValue.prefix, innerValue: contextValue.innerValue, locale: contextValue.locale, visible: confirmVisible, onOk: handleConfirmDone, onCancel: handleConfirmCancel }))));
};
const RefBaseSelect = forwardRef(BaseSelect);
RefBaseSelect.displayName = 'BaseSelect';
RefBaseSelect.defaultProps = {
    mode: 'single',
    type: 'normal',
    displayType: 'normal',
    disabled: false,
    hideButton: false,
    transferSearchToOption: false,
    filterLocal: false,
    hasClear: false,
    autoConfirm: false,
    notFoundContent: '',
    stickyOnTop: false,
};
export default RefBaseSelect;
