import dayjs from 'dayjs';
import isBtw from 'dayjs/plugin/isBetween';
import { isInvalidValue } from './fp';
dayjs.extend(isBtw);
function isDate(obj) {
    return typeof obj === 'object' && obj instanceof Date;
}
export function formatDate(d, format, invalidStr = '') {
    if (!isInvalidValue(d)) {
        const date = dayjs(d);
        if (date.isValid()) {
            return date.format(format);
        }
    }
    return invalidStr;
}
export function isValidDate(obj) {
    return isDate(obj) && !isNaN(obj.getTime());
}
export function toValidDate(from, defaultDate) {
    const res = toDate(from);
    return isValidDate(res) ? res : defaultDate || new Date();
}
export function toDate(from) {
    if (isInvalidValue(from)) {
        return undefined;
    }
    if (isDate(from)) {
        return from;
    }
    if (typeof from === 'object' && typeof from.toDate === 'function') {
        const d = from.toDate();
        if (isDate(d)) {
            return d;
        }
    }
    return toDay(from).toDate();
}
export function isBetween(date, startDate, endDate, unit = 'd', intervalMode = '[]') {
    return dayjs(date).isBetween(startDate, endDate, unit, intervalMode);
}
export function toDay(from) {
    return dayjs(from);
}
export function cloneDate(d) {
    return new Date(d.getTime());
}
export function getDateNum(type, d) {
    switch (type) {
        case 'y':
            return d.getFullYear();
        case 'm':
            return d.getMonth();
        case 'd':
            return d.getDate();
        case 'h':
            return d.getHours();
        case 'i':
            return d.getMinutes();
        case 's':
            return d.getSeconds();
    }
}
export function isTypeSame(type, d1, d2) {
    return getDateNum(type, d1) === getDateNum(type, d2);
}
export var RANGE_CHECK_RESULT;
(function (RANGE_CHECK_RESULT) {
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["IN_RANGE"] = 0] = "IN_RANGE";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_HOUR"] = 1] = "SMALL_THAN_HOUR";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_HOUR"] = 2] = "BIGGER_THAN_HOUR";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_MIN"] = 3] = "SMALL_THAN_MIN";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_MIN"] = 4] = "BIGGER_THAN_MIN";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_SEC"] = 5] = "SMALL_THAN_SEC";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_SEC"] = 6] = "BIGGER_THAN_SEC";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_YEAR"] = 7] = "SMALL_THAN_YEAR";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_YEAR"] = 8] = "BIGGER_THAN_YEAR";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_MONTH"] = 9] = "SMALL_THAN_MONTH";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_MONTH"] = 10] = "BIGGER_THAN_MONTH";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_DAY"] = 11] = "SMALL_THAN_DAY";
    RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_DAY"] = 12] = "BIGGER_THAN_DAY";
})(RANGE_CHECK_RESULT || (RANGE_CHECK_RESULT = {}));
var TIME_PRE_CHECK;
(function (TIME_PRE_CHECK) {
    TIME_PRE_CHECK[TIME_PRE_CHECK["NONE"] = 0] = "NONE";
    TIME_PRE_CHECK[TIME_PRE_CHECK["SKIP"] = 1] = "SKIP";
    TIME_PRE_CHECK[TIME_PRE_CHECK["USE_START"] = 2] = "USE_START";
    TIME_PRE_CHECK[TIME_PRE_CHECK["USE_END"] = 3] = "USE_END";
})(TIME_PRE_CHECK || (TIME_PRE_CHECK = {}));
export function checkDateRange(d, options, validRange) {
    if (!validRange) {
        return RANGE_CHECK_RESULT.IN_RANGE;
    }
    const [startDate, endDate] = validRange;
    let isCheckDate = TIME_PRE_CHECK.NONE;
    if (options.date) {
        const { hasYear, hasMonth, hasDay } = options.date;
        isCheckDate = TIME_PRE_CHECK.SKIP;
        if (hasYear) {
            if (getDateNum('y', startDate) > getDateNum('y', d)) {
                return RANGE_CHECK_RESULT.BIGGER_THAN_YEAR;
            }
            if (getDateNum('y', endDate) < getDateNum('d', d)) {
                return RANGE_CHECK_RESULT.SMALL_THAN_YEAR;
            }
        }
        const isStartYear = isTypeSame('y', d, startDate);
        const isEndYear = isTypeSame('y', d, endDate);
        if ((isStartYear || isEndYear) && hasMonth) {
            if (isStartYear && getDateNum('m', startDate) > getDateNum('m', d)) {
                return RANGE_CHECK_RESULT.BIGGER_THAN_MONTH;
            }
            if (isEndYear && getDateNum('m', endDate) < getDateNum('m', d)) {
                return RANGE_CHECK_RESULT.SMALL_THAN_MONTH;
            }
        }
        const isStartMonth = isStartYear && isTypeSame('m', d, startDate);
        const isEndMonth = isEndYear && isTypeSame('m', d, endDate);
        if (isStartMonth || isEndMonth) {
            if (hasDay) {
                if (isStartMonth && getDateNum('d', startDate) > getDateNum('d', d)) {
                    return RANGE_CHECK_RESULT.BIGGER_THAN_DAY;
                }
                if (isEndMonth && getDateNum('d', endDate) < getDateNum('d', d)) {
                    return RANGE_CHECK_RESULT.SMALL_THAN_DAY;
                }
                if (isEndMonth && isTypeSame('d', endDate, d)) {
                    isCheckDate = TIME_PRE_CHECK.USE_END;
                }
                if (isStartMonth && isTypeSame('d', startDate, d)) {
                    isCheckDate = TIME_PRE_CHECK.USE_START;
                }
            }
            else {
                isCheckDate = isStartMonth ? TIME_PRE_CHECK.USE_START : TIME_PRE_CHECK.USE_END;
            }
        }
    }
    if (options.time && isCheckDate !== TIME_PRE_CHECK.SKIP) {
        const { hasHour, hasMinute, hasSecond } = options.time;
        if (hasHour) {
            if (isCheckDate !== TIME_PRE_CHECK.USE_END && getDateNum('h', startDate) > getDateNum('h', d)) {
                return RANGE_CHECK_RESULT.BIGGER_THAN_HOUR;
            }
            if (isCheckDate !== TIME_PRE_CHECK.USE_START && getDateNum('h', endDate) < getDateNum('h', d)) {
                return RANGE_CHECK_RESULT.SMALL_THAN_HOUR;
            }
        }
        const isStartHour = isTypeSame('h', d, startDate);
        const isEndHour = isTypeSame('h', d, endDate);
        if ((isStartHour || isEndHour) && hasMinute) {
            if (isStartHour && isCheckDate !== TIME_PRE_CHECK.USE_END && getDateNum('i', startDate) > getDateNum('i', d)) {
                return RANGE_CHECK_RESULT.BIGGER_THAN_MIN;
            }
            if (isEndHour && isCheckDate !== TIME_PRE_CHECK.USE_START && getDateNum('i', endDate) < getDateNum('i', d)) {
                return RANGE_CHECK_RESULT.SMALL_THAN_MIN;
            }
        }
        const isStartMinutes = isStartHour && isTypeSame('i', d, startDate);
        const isEndMinutes = isEndHour && isTypeSame('i', d, endDate);
        if ((isStartMinutes || isEndMinutes) && hasSecond) {
            if (isStartMinutes && isCheckDate !== TIME_PRE_CHECK.USE_END && getDateNum('s', startDate) > getDateNum('s', d)) {
                return RANGE_CHECK_RESULT.BIGGER_THAN_SEC;
            }
            if (isEndMinutes && isCheckDate !== TIME_PRE_CHECK.USE_START && getDateNum('s', endDate) < getDateNum('s', d)) {
                return RANGE_CHECK_RESULT.SMALL_THAN_SEC;
            }
        }
    }
    return RANGE_CHECK_RESULT.IN_RANGE;
}
export function getRangeDate(d, options, validRange) {
    if (!validRange) {
        return d;
    }
    const [startDate, endDate] = validRange;
    let newDate;
    switch (checkDateRange(d, options, validRange)) {
        case RANGE_CHECK_RESULT.IN_RANGE:
            return d;
        case RANGE_CHECK_RESULT.SMALL_THAN_YEAR:
        case RANGE_CHECK_RESULT.SMALL_THAN_MONTH:
        case RANGE_CHECK_RESULT.SMALL_THAN_DAY:
        case RANGE_CHECK_RESULT.SMALL_THAN_HOUR:
        case RANGE_CHECK_RESULT.SMALL_THAN_MIN:
        case RANGE_CHECK_RESULT.SMALL_THAN_SEC:
            newDate = cloneDate(endDate);
            break;
        case RANGE_CHECK_RESULT.BIGGER_THAN_YEAR:
        case RANGE_CHECK_RESULT.BIGGER_THAN_MONTH:
        case RANGE_CHECK_RESULT.BIGGER_THAN_DAY:
        case RANGE_CHECK_RESULT.BIGGER_THAN_HOUR:
        case RANGE_CHECK_RESULT.BIGGER_THAN_MIN:
        case RANGE_CHECK_RESULT.BIGGER_THAN_SEC:
            newDate = cloneDate(startDate);
            break;
    }
    if (options.date) {
        const { hasMonth, hasDay } = options.date;
        if (!hasDay) {
            newDate.setDate(1);
        }
        if (!hasMonth) {
            newDate.setMonth(0);
            if (newDate.getMonth() !== 0) {
                newDate.setMonth(0);
            }
        }
    }
    if (options.time) {
        const { hasHour, hasMinute, hasSecond } = options.time;
        if (!hasHour) {
            newDate.setHours(0);
        }
        if (!hasMinute) {
            newDate.setMinutes(0);
        }
        if (!hasSecond) {
            newDate.setSeconds(0);
        }
    }
    else {
        newDate.setHours(0, 0, 0);
    }
    newDate.setMilliseconds(0);
    return newDate;
}
const timeTypes = ['Hours', 'Minutes', 'Seconds'];
export function getNearestDate(options, extra, d, calcType) {
    const { hasHour = false, hasMinute = false, hasSecond = false } = options;
    const { hourStep = 1, minuteStep = 1, secondStep = 1 } = extra;
    const check = (has, step, timeType) => {
        const setter = Date.prototype[`set${timeType}`];
        const getter = Date.prototype[`get${timeType}`];
        if (!has) {
            setter.call(d, 0);
        }
        if (step === 1) {
            return;
        }
        const a = getter.call(d);
        const x = a % step;
        if (x > 0) {
            let type = calcType;
            if (type === 'auto') {
                type = x >= step / 2 ? 'plus' : 'minus';
            }
            if (type === 'plus') {
                setter.call(d, a + (step - x));
            }
            else {
                setter.call(d, a - x);
            }
            for (let i = timeTypes.indexOf(timeType) + 1; i < timeTypes.length; i++) {
                Date.prototype[`set${timeTypes[i]}`].call(d, 0);
            }
        }
    };
    check(hasSecond, secondStep, 'Seconds');
    check(hasMinute, minuteStep, 'Minutes');
    check(hasHour, hourStep, 'Hours');
    return d;
}
export function getRealRange(options, extra, validRange) {
    if (!validRange) {
        return undefined;
    }
    return [
        getNearestDate(options, extra, cloneDate(validRange[0]), 'plus'),
        getNearestDate(options, extra, cloneDate(validRange[1]), 'minus'),
    ];
}
