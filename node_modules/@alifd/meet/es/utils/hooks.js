import { useCallback, useEffect, useMemo, useRef, useState } from 'rax';
import { isNil } from './fp';
export function useValue(props, defaultValue, options) {
    const { valueName = 'value', fitValue, compare } = options || {};
    const defaultName = useMemo(() => {
        const n = valueName.substr(0, 1).toUpperCase() + valueName.substr(1);
        return `default${n}`;
    }, [valueName]);
    const isControlled = valueName in props;
    const defaultVal = useMemo(() => {
        let v = defaultValue;
        if (defaultName in props) {
            v = props[defaultName];
        }
        if (isControlled) {
            v = props[valueName];
        }
        if (isNil(v)) {
            v = defaultValue;
        }
        if (fitValue) {
            v = fitValue(v);
        }
        return v;
    }, []);
    const getControlledValue = () => {
        const x = props[valueName];
        if (isNil(x)) {
            if (fitValue) {
                return fitValue(defaultValue);
            }
            return defaultValue;
        }
        if (fitValue) {
            return fitValue(x);
        }
        return x;
    };
    const [value, setValue] = useState(defaultVal);
    const propValue = useRef(defaultVal);
    useEffect(() => {
        if (isControlled) {
            const newValue = getControlledValue();
            const isSame = compare ? compare(newValue, propValue.current) : newValue === propValue.current;
            if (!isSame) {
                propValue.current = newValue;
                setValue(newValue);
            }
        }
    }, [props[valueName], props.dataSource]);
    const setPropValue = (val) => {
        const isSame = compare ? compare(val, propValue.current) : val === propValue.current;
        if (!isSame) {
            propValue.current = val;
            setValue(val);
        }
    };
    if (isControlled) {
        return [propValue.current, setValue, isControlled, setPropValue];
    }
    return [value, setValue, isControlled, setPropValue];
}
export function useDeprecated(comp, props, oldName, newName, defaultValue) {
    useEffect(() => {
        if (oldName in props && console && console.warn) {
            console.warn(`Warning: ${comp}.${oldName} is deprecated and will be removed in a future version, please use ${newName} instead`);
        }
    }, []);
    if (newName in props) {
        return props[newName];
    }
    if (oldName in props) {
        return props[oldName];
    }
    return defaultValue;
}
let counter = 0;
export function guid(prefix = '') {
    counter += 1;
    return `${prefix}${counter}`;
}
export function useGuid(prefix = '') {
    const id = useRef(guid(prefix));
    return id.current;
}
export function useForceUpdate() {
    const [, update] = useState(0);
    const cb = useCallback(() => update((x) => (x >= Number.MAX_SAFE_INTEGER ? 0 : x + 1)), []);
    return cb;
}
export default function useWhyDidYouUpdate(componentName, props) {
    const prevProps = useRef({});
    useEffect(() => {
        if (prevProps.current) {
            const allKeys = Object.keys(Object.assign(Object.assign({}, prevProps.current), props));
            const changedProps = {};
            allKeys.forEach((key) => {
                if (prevProps.current[key] !== props[key]) {
                    changedProps[key] = {
                        from: prevProps.current[key],
                        to: props[key],
                    };
                }
            });
            if (Object.keys(changedProps).length) {
                console.log('[why-did-you-update]', componentName, changedProps);
            }
        }
        prevProps.current = props;
    });
}
