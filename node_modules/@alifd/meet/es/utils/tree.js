import { isUndef, isValidArray } from './fp';
export function find(tree, callback) {
    let found;
    dfs(tree, function (node, par, ctrl) {
        if (callback.call(node, node, par)) {
            ctrl.stop = true;
            found = this;
        }
    });
    return found;
}
export function getSiblings(tree, val) {
    let p;
    dfs(tree, (node, par) => {
        if (node.value === val) {
            p = par;
        }
    });
    if (!p) {
        return tree;
    }
    else {
        return filter(tree, (node, par) => {
            return par && par.value === p.value;
        });
    }
}
export function filter(tree, callback) {
    const rs = [];
    dfs(tree, (node, par) => {
        if (callback(node, par)) {
            rs.push(node);
        }
    });
    return rs;
}
export function dfs(node, callback) {
    let cur;
    let par;
    let children;
    let ctrl;
    let i;
    const nodes = Array.isArray(node) ? node.slice(0).reverse() : [node];
    const parents = [];
    const childrenName = 'children';
    if (isUndef(nodes[0]) && nodes.length === 1) {
        return;
    }
    for (i = nodes.length - 1; i >= 0; i--) {
        parents.push(undefined);
    }
    while (nodes.length > 0) {
        cur = nodes.pop();
        par = parents.pop();
        ctrl = {};
        callback.call(cur, cur, par, ctrl);
        if (ctrl.stop) {
            break;
        }
        children = cur && cur[childrenName] ? cur[childrenName] : [];
        for (i = ctrl.cutoff ? -1 : children.length - 1; i >= 0; i--) {
            nodes.push(children[i]);
            parents.push(cur);
        }
    }
    return node;
}
export function firstChild(tree) {
    const ret = [];
    if (!Array.isArray(tree) || tree.length === 0) {
        return ret;
    }
    let node = tree[0];
    do {
        if (node) {
            ret.push(node);
        }
        node = Array.isArray(node.children) && node.children.length > 0 ? node.children[0] : null;
    } while (node);
    return ret.map((item) => item.value);
}
export function getMaxDepth(tree) {
    let depth = 0;
    tree.forEach((item) => {
        if (item.children) {
            depth = Math.max(depth, getMaxDepth(item.children) + 1);
        }
        else {
            depth = Math.max(depth, 1);
        }
    });
    return depth;
}
export function getFirstValue(tree = []) {
    const ret = [];
    if (!Array.isArray(tree) || tree.length === 0) {
        return ret;
    }
    let node = tree[0];
    do {
        if (node) {
            ret.push(node);
        }
        node = Array.isArray(node.children) && node.children.length > 0 ? node.children[0] : null;
    } while (node);
    return ret.map((item) => item.value);
}
export function getDataByValues(tree = [], values = []) {
    const ret = [];
    const len = values.length;
    let child = tree;
    for (let i = 0; i < len; i++) {
        const val = values[i];
        const l = child.length;
        let flag = false;
        for (let j = 0; j < l; j++) {
            const item = child[j];
            if (item.value === val) {
                flag = true;
                if (Array.isArray(item.children)) {
                    child = item.children;
                }
                ret.push(item);
                break;
            }
        }
        if (!flag) {
            ret.push({
                label: val,
                value: val,
            });
        }
    }
    return ret;
}
export function getItemsFromDataSource(tree = [], values = []) {
    if (!isUndef(values) && !Array.isArray(values)) {
        values = [values];
    }
    if (!isValidArray(tree) || !isValidArray(values)) {
        return [];
    }
    return values.map((val) => {
        return (find(tree, (it) => it.value === val) || {
            lavel: val,
            value: val,
        });
    });
}
export function getFullPathByValue(tree, value, key = 'value') {
    const path = [];
    const nodes = Array.isArray(tree) ? tree : [tree];
    function helper(node) {
        for (let i = 0; i < node.length; i++) {
            const item = node[i];
            if (item[key] === value) {
                path.push(value);
                return true;
            }
            if (item.children && helper(item.children)) {
                path.push(item[key]);
                return true;
            }
        }
        return false;
    }
    helper(nodes);
    return path.reverse();
}
