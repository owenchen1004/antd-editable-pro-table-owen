import { __awaiter, __rest } from "tslib";
import { createContext, createElement, forwardRef, Fragment, useEffect, useRef, useState, } from 'rax';
import classNames from 'classnames';
import Children from 'rax-children';
import cloneElement from 'rax-clone-element';
import ScrollView from 'rax-scrollview';
import Text from 'rax-text';
import View from '../view';
import Icon from '../icon';
import Picker from '../picker';
import { BaseSelectDrawer } from '../select-drawer';
import TabItem from './item';
import { useLocale } from '../locale';
import defaultLang from '../locale/lang/zh-cn';
import { getLeft, getScrollLeft, getWidth, isFunction, isValidArray, isStrictWechatMiniProgram, screenPixelRatio, } from '../utils';
import { useGuid } from '../utils/hooks';
export const TabContext = createContext({
    activeKey: -1,
    fullWidth: true,
    shape: 'normal',
    activeLineType: 'normal',
    change: () => { },
});
const getTabData = (props) => {
    const { dataSource, children } = props;
    if (isValidArray(dataSource)) {
        return dataSource.map((item) => (Object.assign(Object.assign({}, item), { label: item.title, value: item.key })));
    }
    else if (children) {
        return Children.map(children, (child) => {
            const { title } = child.props;
            const { key } = child;
            return {
                label: title,
                value: key,
            };
        });
    }
    else {
        return [];
    }
};
const getInitActiveKey = (props) => {
    if ('activeKey' in props && props.activeKey) {
        return props.activeKey;
    }
    else if (props.defaultActiveKey || props.defaultActiveKey === 0) {
        return props.defaultActiveKey;
    }
    else {
        return undefined;
    }
};
const timerMap = {};
const Tab = (props, ref) => {
    const { prefix = 'mt-', activeKey, defaultActiveKey = -1, size = 'medium', activeLineType = 'normal', shape = 'normal', fullWidth = true, renderTool, onChange = () => { }, dataSource = [], className, contentClassName, contentStyle, renderTab, children } = props, others = __rest(props, ["prefix", "activeKey", "defaultActiveKey", "size", "activeLineType", "shape", "fullWidth", "renderTool", "onChange", "dataSource", "className", "contentClassName", "contentStyle", "renderTab", "children"]);
    const locale = useLocale('Tab', others, defaultLang.Tab);
    const [curActiveKey, setActiveKey] = useState(getInitActiveKey(props));
    const [drawerVisible, setDrawerVisible] = useState(false);
    const [internalTabKey, setInternalActiveKey] = useState(getInitActiveKey(props));
    const curTabScrollId = useGuid('tab-scroll-');
    const curScrollContainerId = useGuid('tab-ctn-');
    const scrollRef = useRef();
    const activeTabRef = useRef();
    const isControlled = 'activeKey' in props;
    const [isOverflow, setOverflow] = useState(false);
    const isExcessMode = !fullWidth && isOverflow;
    const clsPrefix = `${prefix}tab`;
    const clses = {
        tab: classNames([clsPrefix, `${clsPrefix}--${shape}`, className]),
        divider: classNames({
            [`${clsPrefix}-divider`]: shape !== 'capsule',
        }),
        container: classNames({
            [`${clsPrefix}-container`]: true,
            [`${clsPrefix}-container--${size}`]: true,
            [`${clsPrefix}-container--wechat`]: isStrictWechatMiniProgram,
        }),
        scrollContainer: classNames(`${clsPrefix}-scroll-container`, `${clsPrefix}-scroll-container--${size}`, {
            [`${clsPrefix}-scroll-container--fullwidth`]: fullWidth,
            [`${clsPrefix}-scroll-container--wechat`]: isStrictWechatMiniProgram,
        }),
        tool: classNames(`${clsPrefix}-tool`, `${clsPrefix}-tool--${size}`),
        toolIcon: classNames(`${clsPrefix}-tool-icon`, `${clsPrefix}-tool-icon--${size}`),
        drawer: classNames(`${clsPrefix}-drawer`),
        content: classNames(`${clsPrefix}-content`, contentClassName),
    };
    const scrollTo = (offset) => {
        if (!timerMap[curTabScrollId]) {
            timerMap[curTabScrollId] = setTimeout(() => {
                if (scrollRef && scrollRef.current && scrollRef.current.scrollTo) {
                    scrollRef.current.scrollTo(Object.assign(Object.assign({}, offset), { duration: 150 }));
                    timerMap[curTabScrollId] = null;
                }
            }, 200);
        }
    };
    useEffect(() => {
        if (isControlled && curActiveKey && !props.activeKey) {
            setActiveKey(getInitActiveKey(props));
            return;
        }
        if (isControlled) {
            setActiveKey(props.activeKey);
        }
    });
    useEffect(() => {
        setTimeout(() => {
            (() => __awaiter(void 0, void 0, void 0, function* () {
                const activeTabId = activeTabRef.current && activeTabRef.current.id;
                const containerWidth = yield getWidth(curTabScrollId);
                const containerOffsetLeft = yield getLeft(curTabScrollId);
                const scrollLeft = yield getScrollLeft(curTabScrollId);
                const activeTabWidth = yield getWidth(activeTabId);
                const activeTabOffsetLeft = (yield getLeft(activeTabId)) - containerOffsetLeft;
                const totalWidth = yield getWidth(curScrollContainerId);
                const centerMarkerPos = containerWidth / 2;
                if (!fullWidth) {
                    setOverflow(totalWidth > containerWidth);
                }
                if (scrollRef.current && activeTabRef.current) {
                    const distance = Math.floor(Math.max(activeTabOffsetLeft - centerMarkerPos + scrollLeft + activeTabWidth / 2, 0));
                    if (scrollLeft !== distance) {
                        scrollTo({
                            x: distance / screenPixelRatio,
                            y: 0,
                        });
                    }
                }
            }))();
        }, 50);
    });
    let content;
    if (dataSource && dataSource.length > 0) {
        content = dataSource.map((item, index) => {
            return (createElement(TabItem, Object.assign({ key: item.key || index, itemKey: item.key, renderContent: renderTab, ref: item.key === curActiveKey ? activeTabRef : null, prefix: prefix, size: size }, item)));
        });
    }
    else {
        content = Children.map(children, (child, index) => {
            return cloneElement(child, {
                key: `mt_tab_${index}`,
                itemKey: child.key || index,
                ref: `${child.key}` === `${curActiveKey}` ? activeTabRef : null,
                renderContent: child.renderContent || renderTab,
                prefix,
                size,
            });
        });
    }
    const getTool = () => {
        if (!isExcessMode) {
            return null;
        }
        let _children = (createElement(Fragment, null,
            createElement(Text, null, locale.more),
            createElement(Icon, { className: clses.toolIcon, name: "arrow-down", size: "xxs" })));
        if (isFunction(renderTool)) {
            const renderedToolEl = renderTool();
            if (renderedToolEl) {
                _children = renderedToolEl;
            }
            else {
                _children = null;
            }
        }
        return _children ? (createElement(View, { className: clses.tool, onClick: () => {
                setDrawerVisible(true);
                setInternalActiveKey(curActiveKey);
            } }, _children)) : null;
    };
    const handleChange = (v) => {
        if (!isControlled) {
            setActiveKey(v);
        }
        if (isFunction(onChange) && v !== curActiveKey) {
            onChange(v);
        }
    };
    const handleDrawerOk = () => {
        setDrawerVisible(false);
        handleChange(internalTabKey);
    };
    const handleDrawerCancel = () => {
        setDrawerVisible(false);
        setInternalActiveKey(curActiveKey);
    };
    const getChildren = (activeTabKey) => {
        let ret = null;
        Children.forEach(children, (child) => {
            if (ret) {
                return;
            }
            const _key = child.key;
            if (`${_key}` === `${activeTabKey}`) {
                ret = child.props.children;
            }
        });
        return ret;
    };
    return (createElement(TabContext.Provider, { value: {
            activeKey: curActiveKey,
            change: handleChange,
            shape,
            fullWidth,
            activeLineType,
        } },
        createElement(View, null,
            createElement(View, Object.assign({}, others, { className: clses.tab, ref: ref }),
                createElement(ScrollView, { ref: scrollRef, id: curTabScrollId, className: clses.container, contentContainerStyle: {
                        flex: props.renderTool ? null : 1,
                    }, horizontal: true, showsHorizontalScrollIndicator: false },
                    createElement(View, { id: curScrollContainerId, className: clses.scrollContainer }, content)),
                shape !== 'capsule' && createElement(View, { className: clses.divider }),
                getTool()),
            createElement(View, { className: clses.content, style: contentStyle }, getChildren(curActiveKey))),
        isExcessMode ? (createElement(BaseSelectDrawer, { visible: drawerVisible, onOk: handleDrawerOk, onCancel: handleDrawerCancel },
            createElement(ScrollView, { className: clses.drawer },
                createElement(Picker, { cascade: true, data: getTabData(props), value: [internalTabKey], onChange: (v) => {
                        if (isValidArray(v)) {
                            setInternalActiveKey(v[0]);
                        }
                    } })))) : null));
};
Tab.displayName = 'Tab';
export default forwardRef(Tab);
