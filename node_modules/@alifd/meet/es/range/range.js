import { __rest } from "tslib";
import classNames from 'classnames';
import { createElement, forwardRef, useEffect, useMemo, useState } from 'rax';
import { isFunction, isUndef } from '../utils';
import { useGuid } from '../utils/hooks';
import View from '../view';
import Thumb from './thumb';
import Track from './track';
import { getClosestThumbIndex, getNodeRect, getPrecision, getTouchPosition, noop, pauseEvent } from './utils';
var Mode;
(function (Mode) {
    Mode["Single"] = "single";
    Mode["Double"] = "double";
})(Mode || (Mode = {}));
function getInitialRatio(max, min, value, defaultValue) {
    let ratio = min;
    if (!isUndef(value)) {
        ratio = value;
    }
    else if (!isUndef(defaultValue)) {
        ratio = defaultValue;
    }
    if (!Array.isArray(ratio)) {
        ratio = [ratio];
    }
    return ratio
        .map((item) => {
        if (item > max) {
            return max;
        }
        if (item < min) {
            return min;
        }
        return item;
    })
        .reduce((prev, curr, index) => (Object.assign(Object.assign({}, prev), { [index]: (curr - min) / (max - min) })), {});
}
const Range = (props, ref) => {
    const { size = 'medium', min = 0, prefix = 'mt-', max = 100, mode = 'single', value, defaultValue, step = 1, disabled = false, marks = false, marksPosition = 'below', previewed = false, className, tooltipVisible, onChange = noop, onProcess = noop } = props, others = __rest(props, ["size", "min", "prefix", "max", "mode", "value", "defaultValue", "step", "disabled", "marks", "marksPosition", "previewed", "className", "tooltipVisible", "onChange", "onProcess"]);
    const [ratio, setRatio] = useState(getInitialRatio(max, min, value, defaultValue));
    const [active, setActive] = useState(null);
    const [dragging, setDragging] = useState(false);
    const [rangeWidth, setRangeWidth] = useState(0);
    const id = useGuid('range-');
    const thumbId1 = useGuid('range-thumb-');
    const thumbId2 = useGuid('range-thumb-');
    const isControlled = 'value' in props;
    const handles = mode === Mode.Double
        ? {
            0: thumbId1,
            1: thumbId2,
        }
        : {
            0: thumbId1,
        };
    function getRatioValue(val) {
        return parseFloat((val * (max - min) + min).toFixed(getPrecision(step)));
    }
    const points = useMemo(() => {
        let data = {};
        const dealPoints = () => {
            if (step) {
                for (let point = min; point <= max; point += step) {
                    const current = Number(point.toFixed(1));
                    data[current] = current;
                }
            }
        };
        if (marks instanceof Array) {
            marks.reduce((prev, current) => {
                prev[current] = current;
                return prev;
            }, data);
        }
        else if (marks instanceof Object) {
            data = Object.assign({}, marks);
        }
        dealPoints();
        return Object.keys(data)
            .map(parseFloat)
            .sort((a, b) => a - b);
    }, [marks, step, min, max]);
    function getClosestStep(val) {
        const diffs = points.map((point) => Math.abs(point - val - min));
        return points[diffs.indexOf(Math.min(...diffs))];
    }
    function getValue(newRatio) {
        const result = Object.keys(newRatio)
            .map((key) => getRatioValue(newRatio[key]))
            .sort((a, b) => a - b);
        if (result.length === 1) {
            return result[0];
        }
        return result;
    }
    function updatePositionByTouch(e, activeIndex) {
        return getNodeRect(id).then((rect) => {
            const position = getTouchPosition(e);
            const diff = position - rect.left;
            const offset = Math.max(Math.min(diff, rect.width), 0);
            const closestValue = getClosestStep((offset / rect.width) * (max - min));
            const newRatio = Object.assign({}, ratio);
            if (!isUndef(activeIndex)) {
                newRatio[activeIndex] = (closestValue - min) / (max - min);
            }
            if (!isControlled) {
                setRatio(newRatio);
            }
            return newRatio;
        });
    }
    function handleTouchStart(e) {
        if (disabled || previewed || dragging) {
            return;
        }
        const position = getTouchPosition(e);
        getClosestThumbIndex(position, handles).then((activeIndex) => {
            setDragging(true);
            setActive(activeIndex);
            updatePositionByTouch(e, activeIndex).then((newRatio) => {
                if (isFunction(onChange)) {
                    onChange(getValue(newRatio), e);
                }
            });
            pauseEvent(e);
        });
    }
    function handleTouchMove(e) {
        if (!dragging) {
            return;
        }
        updatePositionByTouch(e, active).then((newRatio) => {
            if (isFunction(onProcess)) {
                onProcess(getValue(newRatio), e);
            }
            if (isFunction(onChange)) {
                onChange(getValue(newRatio), e);
            }
        });
        pauseEvent(e);
    }
    function handleTouchEnd(e) {
        if (!dragging) {
            return;
        }
        setDragging(false);
        setActive(null);
        updatePositionByTouch(e, active).then((newRatio) => {
            if (isFunction(onChange)) {
                onChange(getValue(newRatio), e);
            }
        });
        pauseEvent(e);
    }
    function adjustRatio() {
        const data = {};
        Object.keys(ratio).forEach((key) => (data[key] = (getClosestStep(ratio[key] * (max - min)) - min) / (max - min)));
        setRatio(data);
    }
    useEffect(() => {
        adjustRatio();
        setTimeout(() => {
            getNodeRect(id).then((rect) => {
                setRangeWidth(rect.width);
            });
        }, 100);
    }, []);
    useEffect(() => {
        if (isControlled) {
            setRatio(getInitialRatio(max, min, value, defaultValue));
        }
    }, [value, defaultValue, max, min]);
    const ratioValue = Object.values(ratio).sort((a, b) => a - b);
    return (createElement(View, Object.assign({}, others, { id: id, withoutTouch: false, className: classNames(`${prefix}range`, className), onMouseDown: handleTouchStart, onMouseMove: handleTouchMove, onMouseUp: handleTouchEnd, onTouchStart: handleTouchStart, onTouchMove: handleTouchMove, onTouchEnd: handleTouchEnd }),
        createElement(Track, { prefix: prefix, size: size, min: min, max: max, marks: marks, marksPosition: marksPosition, disabled: disabled, ratio: ratioValue, rangeWidth: rangeWidth }),
        Object.keys(handles).map((key) => {
            const isActive = `${active}` === `${key}`;
            return (createElement(Thumb, { prefix: prefix, key: key, size: size, id: handles[key], disabled: disabled, isActive: isActive, tooltipVisible: tooltipVisible, offset: ratio[key] * rangeWidth, value: getRatioValue(ratio[key]) }));
        })));
};
Range.displayName = 'Range';
export default forwardRef(Range);
