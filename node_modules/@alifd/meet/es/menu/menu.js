import { createElement, forwardRef, useCallback, useMemo } from 'rax';
import classNames from 'classnames';
import Children from 'rax-children';
import View from '../view';
import Item from './item';
import MenuContext from './menu-context';
import SubMenu from './sub-menu';
import { getNotUndef, isValidArray } from '../utils';
import { useValue } from '../utils/hooks';
import { DEFAULT_INLINE_INDENT } from './constant';
const handleChildren = (children, prefixKey = '', depth = 1) => {
    return Children.map(children, (child, index) => {
        const keyPath = prefixKey + index.toString();
        const key = child.key || keyPath;
        child.props = Object.assign({}, child.props, { keyPath, depth, key, itemKey: key });
        if (child.props.children && child.props.children instanceof Array) {
            handleChildren(child.props.children, `${keyPath}-`, depth + 1);
        }
        return child;
    });
};
const handleDataSource = (items, prefixKey = '', depth = 1) => {
    return items.map((child, index) => {
        const keyPath = prefixKey + index.toString();
        const key = getNotUndef(child.key, child.value, keyPath);
        if (isValidArray(child.children)) {
            const subChild = handleDataSource(child.children, `${keyPath}-`, depth + 1);
            return createElement(SubMenu, Object.assign(Object.assign({}, child), { key,
                keyPath,
                depth }), subChild);
        }
        else {
            return createElement(Item, Object.assign(Object.assign({}, child), { key, itemKey: key, keyPath }), child.label);
        }
    });
};
const Menu = (props, ref) => {
    const { prefix = 'mt-', className, size = 'medium', selectMode, onItemClick = () => { }, onOpen = () => { }, inlineIndent = DEFAULT_INLINE_INDENT, onSelect = () => { }, dataSource, children, } = props;
    const [openKeys, setOpenKeys, isOpenControlled] = useValue(props, [], {
        valueName: 'openKeys',
        compare: (a, b) => a.join(',') === b.join(','),
    });
    const [selectedKeys, setSelectedKeys, isSelectedControlled] = useValue(props, [], {
        valueName: 'selectedKeys',
        compare: (a, b) => a.join(',') === b.join(','),
    });
    const handleOpen = useCallback(({ key, open }) => {
        let newOpenKeys = [];
        if (open) {
            newOpenKeys = openKeys.concat(key);
        }
        else {
            newOpenKeys = openKeys.filter((item) => item !== key);
        }
        if (isOpenControlled) {
            onOpen(newOpenKeys, { key, open });
        }
        else {
            setOpenKeys(newOpenKeys);
        }
    }, [openKeys, isOpenControlled, onOpen]);
    const handleClickItem = useCallback((key, item, event) => onItemClick(key, item, event), [
        onItemClick,
    ]);
    const handleSelect = useCallback((selected, item) => {
        let newSelectedKeys = [];
        const key = item.itemKey;
        const { keyPath } = item;
        if (selected) {
            if (selectMode === 'single') {
                newSelectedKeys = [key];
            }
            else if (selectMode === 'multiple') {
                newSelectedKeys = selectedKeys.concat(key);
            }
        }
        else {
            newSelectedKeys = selectedKeys.filter((i) => i !== key);
        }
        if (isSelectedControlled) {
            onSelect(newSelectedKeys, item, {
                select: selected,
                key,
                label: item.children,
                keyPath,
            });
        }
        else {
            setSelectedKeys(newSelectedKeys);
        }
    }, [selectMode, selectedKeys, isSelectedControlled, onSelect]);
    const context = useMemo(() => ({
        prefix,
        size,
        selectMode,
        inlineIndent,
        openKeys,
        selectedKeys,
        onOpen: handleOpen,
        onClickItem: handleClickItem,
        onSelect: handleSelect,
    }), [prefix, size, selectMode, inlineIndent, openKeys, selectedKeys, handleOpen, handleClickItem, handleSelect]);
    const newChildren = useMemo(() => (isValidArray(dataSource) ? handleDataSource(dataSource) : handleChildren(children)), [props.dataSource, children]);
    return (createElement(MenuContext.Provider, { value: context },
        createElement(View, { ref: ref, className: classNames(`${prefix}menu`, className, `${prefix}menu-size-${size}`) },
            newChildren,
            createElement(View, { className: `${prefix}menu-obstructive` }))));
};
Menu.displayName = 'Menu';
export default forwardRef(Menu);
