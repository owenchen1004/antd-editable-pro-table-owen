import Field from '@alifd/field';
import { useMemo, useState } from 'rax';
import cloneElement from 'rax-clone-element';
import isValidElement from 'rax-is-valid-element';
import FieldElement from './element';
function processErrorMessage(element) {
    if (element && isValidElement(element)) {
        return cloneElement(element, { key: 'error' });
    }
    else if (element && typeof element !== 'string') {
        element = element.message;
    }
    return element;
}
export default class MeetField extends Field {
    static useField(options) {
        return this.getUseField({ useState, useMemo })(options);
    }
    constructor(contextComp, options) {
        const newOptions = Object.assign({
            processErrorMessage,
        }, options);
        super(contextComp, newOptions);
        this.validate = this.validate.bind(this);
    }
    validatePromise(names, callback) {
        return new Promise((resolve, reject) => {
            super
                .validatePromise(names, callback)
                .then((result) => {
                if (this.afterValidateRerender) {
                    this.afterValidateRerender({
                        errorsGroup: this.getErrors(),
                        options: this.options,
                        instance: this.instance,
                    });
                }
                resolve(result);
            })
                .catch(reject);
        });
    }
    validate(names, callback) {
        return this.validatePromise(names, callback);
    }
}
export { FieldElement };
