export function getDataArray(data = [], value, cascade) {
    if (!cascade) {
        return data;
    }
    if (Array.isArray(data) && data.length === 0) {
        return data;
    }
    let array = [...data];
    const ret = [data];
    const values = [...value];
    if (values.length === 0 && data.length > 0) {
        values.push(data[0].value);
    }
    let i = 0;
    while (array.length > 0) {
        const { children = [] } = array.find((it) => it.value === values[i]) || array[0];
        if (children.length > 0) {
            ret.push(children);
        }
        array = children;
        i++;
    }
    return ret;
}
export function getDataArrayByIndex(data, indexList = [], cascade) {
    if (!cascade) {
        return data;
    }
    let i = 0;
    let array = [...data];
    const ret = [data];
    while (array && array.length > 0) {
        let index = indexList[i] || 0;
        if (index !== 0 && index >= array.length) {
            index = array.length - 1;
        }
        const children = array[index].children;
        if (children) {
            ret.push(children);
        }
        array = children;
        i++;
    }
    return ret;
}
export function getIndex(dataArray, value) {
    return dataArray.reduce((rs, arr, index) => {
        arr.forEach((obj, j) => {
            if (obj.value === value[index]) {
                rs = rs.concat(j);
            }
        });
        return rs;
    }, []);
}
export function formatNewIndexByLast(newIndex = [], lastIndex = []) {
    let isSame = true;
    if (!lastIndex.length) {
        return newIndex;
    }
    return newIndex.map((val, index) => {
        if (!isSame) {
            return 0;
        }
        else if (lastIndex[index] !== undefined && val === lastIndex[index]) {
            return val;
        }
        else {
            isSame = false;
            return val;
        }
    });
}
