import { __rest } from "tslib";
import { createElement, createRef, forwardRef, useEffect, useRef, } from 'rax';
import classNames from 'classnames';
import findDOMNode from 'rax-find-dom-node';
import Text from 'rax-text';
import { isIOS, nextTick, osVersion } from '../utils';
import { useForceUpdate } from '../utils/hooks';
import View from '../view';
const isIOS10 = isIOS && /^10./.test(osVersion);
const isPassiveSupported = () => {
    let passiveSupported = false;
    try {
        const options = Object.defineProperty({}, 'passive', {
            get: () => {
                passiveSupported = true;
            },
        });
        window.addEventListener('test', null, options);
    }
    catch (err) { }
    return passiveSupported;
};
const createScrollHandlers = (fromOptions) => {
    let options = fromOptions;
    let scrollY = -1;
    let lastY = 0;
    let startY = 0;
    let scrollDisabled = false;
    let isMoving = false;
    let cachedTransform = null;
    let isTransformRunning = false;
    const setTransform = (nodeStyle, value) => {
        cachedTransform = value;
        if (isTransformRunning) {
            return;
        }
        isTransformRunning = true;
        nextTick(() => {
            nodeStyle.transform = cachedTransform;
            nodeStyle.webkitTransform = cachedTransform;
            isTransformRunning = false;
        });
    };
    let cachedTransition = null;
    let isTransitionRunning = false;
    const setTransition = (nodeStyle, value) => {
        cachedTransition = value;
        if (isTransitionRunning) {
            return;
        }
        isTransitionRunning = true;
        nextTick(() => {
            nodeStyle.transition = cachedTransition;
            nodeStyle.webkitTransition = cachedTransition;
            isTransitionRunning = false;
        });
    };
    const scrollTo = (_x, y, time = 0.3) => {
        if (scrollY !== y) {
            scrollY = y;
            if (time) {
                setTransition(options.contentDOM.style, `cubic-bezier(0,0,0.2,1.15) ${time}s`);
            }
            setTransform(options.contentDOM.style, `translate3d(0,${-y}px,0)`);
            setTimeout(() => {
                options.scrollingComplete();
                if (options.contentDOM) {
                    setTransition(options.contentDOM.style, '');
                }
            }, +time * 1000);
        }
    };
    const Velocity = ((minInterval = 30, maxInterval = 100) => {
        let _time = 0;
        let _y = 0;
        let _velocity = 0;
        const recorder = {
            record: (y) => {
                const now = +new Date();
                _velocity = (y - _y) / (now - _time);
                if (now - _time >= minInterval) {
                    _velocity = now - _time <= maxInterval ? _velocity : 0;
                    _y = y;
                    _time = now;
                }
            },
            getVelocity: (y) => {
                if (y !== _y) {
                    recorder.record(y);
                }
                return _velocity;
            },
        };
        return recorder;
    })();
    const onFinish = () => {
        isMoving = false;
        let targetY = scrollY;
        const height = (options.items.length - 1) * options.itemHeight;
        let time = 0.3;
        const velocity = Velocity.getVelocity(targetY) * 4;
        if (velocity) {
            targetY = velocity * 40 + targetY;
            time = Math.abs(velocity) * 0.1;
        }
        if (targetY % options.itemHeight !== 0) {
            targetY = Math.round(targetY / options.itemHeight) * options.itemHeight;
        }
        if (targetY < 0) {
            targetY = 0;
        }
        else if (targetY > height) {
            targetY = height;
        }
        scrollTo(0, targetY, time < 0.3 ? 0.3 : time);
        options.onScrollChange();
    };
    const onStart = (y) => {
        if (scrollDisabled) {
            return;
        }
        isMoving = true;
        startY = y;
        lastY = scrollY;
    };
    const onMove = (y) => {
        if (scrollDisabled || !isMoving) {
            return;
        }
        scrollY = lastY - y + startY;
        Velocity.record(scrollY);
        options.onScrollChange();
        setTransform(options.contentDOM.style, `translate3d(0,${-scrollY}px,0)`);
    };
    return {
        setOptions: (x) => (options = x),
        touchstart: (evt) => onStart(evt.touches[0].pageY),
        mousedown: (evt) => onStart(evt.pageY),
        touchmove: (evt) => {
            evt.preventDefault();
            onMove(evt.touches[0].pageY);
        },
        mousemove: (evt) => {
            evt.preventDefault();
            onMove(evt.pageY);
        },
        touchend: () => onFinish(),
        touchcancel: () => onFinish(),
        mouseup: () => onFinish(),
        getValue: () => {
            return scrollY;
        },
        scrollTo,
        setDisabled: (disabled = false) => {
            scrollDisabled = disabled;
        },
    };
};
const PickerColumn = (props, ref) => {
    const { prefix = 'mt-', value, data = [], onChange = () => { }, onScrollChange } = props, others = __rest(props, ["prefix", "value", "data", "onChange", "onScrollChange"]);
    const forceUpdate = useForceUpdate();
    const scrollHandlers = useRef(null);
    const scrollRef = createRef();
    const contentRef = createRef();
    const itemRef = createRef();
    const maskRef = createRef();
    let itemHeight;
    let scrollValue;
    const selectByIndex = (index, height, zscrollTo) => {
        if (index < 0 || index >= data.length || !height) {
            return;
        }
        zscrollTo(index * height);
    };
    const select = (v, height, scrollTo) => {
        for (let i = 0; i < data.length; i++) {
            if (data[i].value === v) {
                selectByIndex(i, height, scrollTo);
                return;
            }
        }
        selectByIndex(0, height, scrollTo);
    };
    const computeChildIndex = (top, height, length) => {
        const index = Math.round(top / height);
        return Math.min(index, length - 1);
    };
    const doScrollingComplete = (top, height, doValueChange) => {
        const index = computeChildIndex(top, height, data.length);
        const child = data[index];
        if (child) {
            if (!child.disabled) {
                doValueChange(child.value);
            }
            else {
                nextTick(() => {
                    select(value, itemHeight, (t) => scrollHandlers.current.scrollTo(0, t, 0.4));
                });
            }
        }
        else if (console.warn) {
            console.warn('item not found', data, index);
        }
    };
    const fireValueChange = (sValue) => {
        if (sValue !== value) {
            onChange(sValue);
            nextTick(() => forceUpdate());
        }
    };
    const scrollToWithoutAnimation = (top) => {
        if (scrollHandlers.current) {
            scrollHandlers.current.scrollTo(0, top, 0);
        }
    };
    const handleScrollChange = () => {
        const top = scrollHandlers.current.getValue();
        if (top >= 0) {
            const index = computeChildIndex(top, itemHeight, data.length);
            if (scrollValue !== index) {
                scrollValue = index;
                const child = data[index];
                if (child && onScrollChange) {
                    onScrollChange(child.value);
                }
                else if (!child && console.warn) {
                    console.warn('child not found', data, index);
                }
            }
        }
    };
    const handleScrollComplete = () => {
        const top = scrollHandlers.current.getValue();
        if (top >= 0) {
            doScrollingComplete(top, itemHeight, fireValueChange);
        }
    };
    useEffect(() => {
        setTimeout(() => {
            const itemNode = findDOMNode(itemRef.current);
            const maskNode = findDOMNode(maskRef.current);
            const scrollNode = findDOMNode(scrollRef.current);
            const contentNode = findDOMNode(contentRef.current);
            if (!itemNode) {
                return undefined;
            }
            itemHeight = itemNode.getBoundingClientRect().height;
            maskNode.style.backgroundSize = `100% ${3 * itemHeight}px`;
            if (!scrollHandlers.current) {
                scrollHandlers.current = createScrollHandlers({
                    onScrollChange: handleScrollChange,
                    scrollingComplete: handleScrollComplete,
                    contentDOM: contentNode,
                    items: data,
                    itemHeight,
                });
                const passiveSupported = isPassiveSupported();
                const willPreventDefault = passiveSupported ? { passive: false } : false;
                const willNotPreventDefault = passiveSupported ? { passive: true } : false;
                Object.keys(scrollHandlers.current).forEach((key) => {
                    if (key.indexOf('touch') === 0 || key.indexOf('mouse') === 0) {
                        const pd = key.indexOf('move') >= 0 ? willPreventDefault : willNotPreventDefault;
                        scrollNode.addEventListener(key, scrollHandlers.current[key], pd);
                    }
                });
            }
            else {
                scrollHandlers.current.setOptions({
                    onScrollChange: handleScrollChange,
                    scrollingComplete: handleScrollComplete,
                    contentDOM: contentNode,
                    items: data,
                    itemHeight,
                });
            }
            select(value, itemHeight, scrollToWithoutAnimation);
            return () => {
                Object.keys(scrollHandlers).forEach((key) => {
                    if (key.indexOf('touch') === 0 || key.indexOf('mouse') === 0) {
                        scrollNode.removeEventListener(key, scrollHandlers[key]);
                    }
                });
            };
        }, 50);
    });
    const clsPrefix = `${prefix}picker`;
    return (createElement(View, Object.assign({}, others, { className: `${clsPrefix}-item`, ref: ref }),
        createElement(View, { className: classNames(`${clsPrefix}-col`, {
                [`${clsPrefix}-col--ios10`]: isIOS10,
            }), ref: scrollRef },
            createElement(View, { className: `${clsPrefix}-mask`, ref: maskRef }),
            createElement(View, { className: `${clsPrefix}-indicator` }),
            createElement(View, { className: `${clsPrefix}-content`, ref: contentRef }, data.map((item, index) => {
                return (createElement(View, { key: index, className: classNames(`${clsPrefix}-col-item`, {
                        [`${clsPrefix}-col-item--disabled`]: item.disabled,
                        [`${clsPrefix}-col-item--selected`]: !item.disabled && item.value === value,
                    }), ref: index === 0 ? itemRef : null },
                    createElement(Text, { className: `${clsPrefix}-col-item-text`, numberOfLines: 1 }, item.label)));
            })))));
};
export default forwardRef(PickerColumn);
