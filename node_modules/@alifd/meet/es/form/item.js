import classNames from 'classnames';
import { createContext, createElement, forwardRef, useContext, useEffect, useMemo, useState, } from 'rax';
import Children from 'rax-children';
import cloneElement from 'rax-clone-element';
import Text from 'rax-text';
import View from '../view';
import Icon from '../icon';
import List from '../list';
import { isString, isUndef } from '../utils';
import { useGuid } from '../utils/hooks';
import Context from './context';
import { getValidationRules } from './utils';
export const FormItemContext = createContext({
    isInsideForm: false,
    labelAlign: 'top',
    validateState: 'normal',
    labelTextAlign: 'left',
    contentAlign: 'left',
    hasFeedback: true,
    size: 'medium',
});
const FormItem = (props, ref) => {
    const { prefix = 'mt-', label, labelWidth: labelWidthProp, labelAlign: labelAlignProp, labelTextAlign: labelTextAlignProp, contentAlign: contentAlignProp, help: helpProp, extra, className, style, children, isPreview: isPreviewProp, renderPreview, validateState: validateStateProp, hasFeedback = false, embedded = false, previewClassName: previewClassNameProp, previewStyle = {}, size: sizeProp, valuePropName, required, requiredMessage, requiredTrigger, min, max, minmaxMessage, minmaxTrigger, minLength, maxLength, minmaxLengthMessage, minmaxLengthTrigger, length, lengthMessage, lengthTrigger, pattern, patternMessage, patternTrigger, format, formatMessage, formatTrigger, validator, validatorTrigger, } = props;
    const { labelAlign: contextLabelAlign, labelWidth: contextLabelWidth, labelTextAlign: contextLabelTextAlign, useLabelForErrorMessage, contentAlign: contextContentAlign, form, field, size: sizeContext, isPreview: contextIsPreview, } = useContext(Context);
    const itemId = useGuid('form-item-');
    const size = sizeProp || sizeContext;
    const valueNames = [];
    let validateName;
    if (label && useLabelForErrorMessage) {
        validateName = isString(label) ? label : label.toString();
    }
    else {
        validateName = valueNames.join(' ');
    }
    const [validateStateInner, setValidateState] = useState(validateStateProp || 'normal');
    const validateState = 'validateState' in props ? validateStateProp || 'normal' : validateStateInner;
    const [error, setError] = useState('');
    const rules = useMemo(() => getValidationRules(validateName, props), [
        required,
        requiredMessage,
        requiredTrigger,
        min,
        max,
        minmaxMessage,
        minmaxTrigger,
        minLength,
        maxLength,
        minmaxLengthMessage,
        minmaxLengthTrigger,
        length,
        lengthMessage,
        lengthTrigger,
        pattern,
        patternMessage,
        patternTrigger,
        format,
        formatMessage,
        formatTrigger,
        validator,
        validatorTrigger,
    ]);
    const clsPrefix = `${prefix}form-item`;
    const previewClassName = classNames(previewClassNameProp, `${clsPrefix}-input`, `${clsPrefix}-input--preview-${size}`);
    const isPreview = !isUndef(isPreviewProp) ? isPreviewProp : contextIsPreview;
    let labelAlign = labelAlignProp || contextLabelAlign;
    if (labelAlign === 'left') {
        labelAlign = 'inset';
    }
    const labelWidth = labelWidthProp || contextLabelWidth || 'auto';
    const contentAlign = contentAlignProp || contextContentAlign || 'left';
    const labelTextAlign = labelTextAlignProp || contextLabelTextAlign || 'left';
    let help = helpProp;
    if (!help && validateState === 'error') {
        help = error;
    }
    const hasError = validateState === 'error';
    const hasHelp = !!help;
    const isInset = labelAlign === 'inset';
    useEffect(() => {
        if (validateStateProp && validateStateProp !== validateState) {
            setValidateState(validateStateProp);
        }
    }, [validateState, validateStateProp]);
    const getValidateResult = () => {
        if (rules.length === 0) {
            if (validateState !== 'normal') {
                setValidateState('normal');
            }
            return;
        }
        if (!('validateState' in props) && field) {
            const errors = [];
            Object.values(field.getErrors(valueNames)).forEach((err) => {
                if (err && Array.isArray(err) && err.length > 0) {
                    err.forEach((it) => errors.push(it));
                }
            });
            if (errors.length > 0) {
                if (validateState !== 'error') {
                    setValidateState('error');
                }
                if (errors[0] !== error) {
                    setError(errors[0]);
                }
            }
            else if (validateState !== 'success' && validateState !== 'normal') {
                setValidateState('success');
            }
        }
    };
    useEffect(() => {
        if (form) {
            return form.onValidate(getValidateResult);
        }
    }, []);
    useEffect(() => getValidateResult());
    const newChildren = Children.map(children, (child, index) => {
        var _a;
        if (!field) {
            return child;
        }
        let valueName = valuePropName;
        if (!valueName) {
            if ((child === null || child === void 0 ? void 0 : child.type) && ((_a = child === null || child === void 0 ? void 0 : child.type) === null || _a === void 0 ? void 0 : _a.valueName)) {
                valueName = child.type.valueName;
            }
            else if ('checked' in child.props || 'defaultChecked' in child.props) {
                valueName = 'checked';
            }
            else {
                valueName = 'value';
            }
        }
        if ('name' in child.props) {
            const { name } = child.props;
            valueNames.push(name);
            if (form && form.mapNameToGuid) {
                form.mapNameToGuid[name] = itemId;
            }
            if (!('data-meta' in child.props)) {
                const { init } = field;
                return cloneElement(child, Object.assign(Object.assign(Object.assign({}, child.props), init(name, {
                    valueName,
                    rules,
                    props: Object.assign(Object.assign({}, child.props), { ref: child.ref }),
                }, child.props)), { labelAlign,
                    size, key: child.key || name || index }));
            }
        }
        return child;
    });
    let previewElement = null;
    if (isPreview && field && renderPreview !== false) {
        const values = Object.values(field.getValues(valueNames));
        previewElement = (createElement(View, { className: previewClassName, style: Object.assign(Object.assign({}, previewStyle), { textAlign: contentAlign }) }, renderPreview ? renderPreview(...values) : values.join(',')));
    }
    return (createElement(List.Item, { ref: ref, id: itemId, className: classNames(clsPrefix, {
            [`${clsPrefix}--inset`]: isInset,
            [`${clsPrefix}--error`]: hasError,
            [`${clsPrefix}--help`]: hasHelp,
        }, className), style: style },
        createElement(List.ItemContent, null,
            createElement(View, { className: classNames(`${clsPrefix}-container`, {
                    [`${clsPrefix}-container--inset`]: isInset,
                }) },
                !embedded && label ? (createElement(View, { className: classNames(`${clsPrefix}-label-container`, {
                        [`${clsPrefix}-label-container--${size}`]: !isInset,
                        [`${clsPrefix}-label-container--inset`]: isInset,
                        [`${clsPrefix}-label-container--right`]: isInset && labelTextAlign === 'right',
                    }), style: {
                        width: labelWidth,
                        flexShrink: 0,
                    } },
                    isInset && required && !isPreview ? (createElement(Icon, { name: "asterisk", className: classNames(`${clsPrefix}-required`, `${clsPrefix}-required--inset-${size}`, {
                            [`${clsPrefix}-required--inset`]: labelTextAlign !== 'right',
                        }) })) : null,
                    isString(label) ? (createElement(Text, { className: classNames(`${clsPrefix}-label`, `${clsPrefix}-label--${size}`, {
                            [`${clsPrefix}-label--inset`]: isInset,
                            [`${clsPrefix}-label--inset--${size}`]: isInset,
                            [`${clsPrefix}-label--error`]: hasError,
                        }) }, label)) : (label),
                    !isInset && required && !isPreview ? (createElement(Icon, { name: "asterisk", className: `${clsPrefix}-required ${clsPrefix}-required--${size}` })) : null)) : null,
                createElement(FormItemContext.Provider, { value: {
                        isInsideForm: true,
                        labelAlign,
                        labelTextAlign,
                        validateState,
                        hasFeedback,
                        contentAlign,
                        size,
                    } },
                    previewElement,
                    createElement(View, { className: classNames(`${clsPrefix}-input`, `${clsPrefix}-input--${contentAlign}`), style: {
                            display: previewElement ? 'none' : 'flex',
                        } }, newChildren))),
            createElement(View, { className: classNames(`${clsPrefix}-help`, `${clsPrefix}-help--${contentAlign}`, `${clsPrefix}-help--${hasError ? 'error' : 'help'}`) },
                help ? (createElement(View, { className: classNames(`${clsPrefix}-help-text`, `${clsPrefix}-help-text--${size}`) }, help)) : null,
                extra && (createElement(View, { className: classNames(`${clsPrefix}-help-extra`, `${clsPrefix}-help-text--${size}`) }, extra))))));
};
export default forwardRef(FormItem);
