import { __rest } from "tslib";
import classNames from 'classnames';
import { Component, createElement } from 'rax';
import Field from '../field';
import { isBoolean, makeChain, scrollToId } from '../utils';
import View from '../view';
import Context, { defaultContext } from './context';
import { removeFormAttrs } from './utils';
export default class Form extends Component {
    constructor(props) {
        super(props);
        this.mapNameToGuid = {};
        this.validateCallback = [];
        this.handleAfterValidate = this.handleAfterValidate.bind(this);
        if (props.field) {
            this.field = props.field;
            props.field.afterValidateRerender = props.field.afterValidateRerender
                ? makeChain(this.handleAfterValidate, props.field.afterValidateRerender)
                : this.handleAfterValidate;
            props.field.setOptions({
                onChange: makeChain(props.field.options.onChange, this.handleChange.bind(this)),
            });
        }
        else {
            const { autoUnmount = true, autoValidate = true, scrollToFirstError = false } = props;
            this.field = new Field(this, {
                autoUnmount,
                autoValidate,
                values: props.value || props.defaultValue || {},
                onChange: this.handleChange.bind(this),
                scrollToFirstError,
                afterValidateRerender: this.handleAfterValidate,
            });
        }
        if (props.saveField) {
            props.saveField(this.field);
        }
    }
    submit(...args) {
        if (args.length === 0) {
            return this.field.validatePromise();
        }
        let names;
        let callback = null;
        let skipValidate = false;
        switch (args.length) {
            case 1:
                if (Array.isArray(args[0])) {
                    names = args[0];
                }
                else if (typeof args[0] === 'function') {
                    callback = args[0];
                }
                break;
            case 2:
                if (isBoolean(args[1])) {
                    callback = args[0];
                    skipValidate = args[1];
                }
                else {
                    names = args[0];
                    callback = args[1];
                }
                break;
            case 3:
                names = args[0];
                callback = args[1];
                skipValidate = args[2];
                break;
            default: {
                console.error('调用 Form.submit 参数错误，期待参数 <names?: [], callback?: function>');
            }
        }
        const validateCb = (errors, values) => {
            const { onSubmit } = this.props;
            if (errors) {
                callback(null, errors, this.field);
                if (onSubmit) {
                    onSubmit(null, errors, this.field);
                }
            }
            else {
                callback(values, null, this.field);
                if (onSubmit) {
                    onSubmit(values, null, this.field);
                }
            }
        };
        const validateParams = names ? [names, validateCb] : [validateCb];
        if (skipValidate) {
            const { onSubmit } = this.props;
            callback(this.getValue(names), null, this.field);
            if (onSubmit) {
                onSubmit(this.getValue(names), null, this.field);
            }
            return;
        }
        return this.field.validateCallback(...validateParams);
    }
    reset(toDefault = true, names) {
        if (toDefault) {
            this.field.resetToDefault(names);
        }
        else {
            this.field.reset(names);
        }
    }
    getValue(names) {
        return this.field.getValues(names);
    }
    setValue(values) {
        this.field.setValues(values);
    }
    componentDidUpdate(prevProps) {
        if (this.props.field && this.props.field !== prevProps.field) {
            this.field = this.props.field;
            this.forceUpdate();
        }
        if (this.props.scrollToFirstError !== prevProps.scrollToFirstError) {
            this.field.setOptions({
                scrollToFirstError: !!this.props.scrollToFirstError,
            });
        }
        if ('value' in this.props) {
            const { value } = this.props;
            if (value === prevProps.value) {
                return;
            }
            if (value) {
                this.field.setValues(value);
            }
            else {
                this.field.resetToDefault();
            }
        }
    }
    handleChange(name, value) {
        const { onChange } = this.props;
        if (onChange) {
            onChange(this.field.getValues(), {
                name,
                value,
                field: this.field,
            });
        }
    }
    handleAfterValidate(data) {
        const { errorsGroup } = data;
        if (errorsGroup && this.props.scrollToFirstError) {
            let firstNodeId = null;
            for (const i in errorsGroup) {
                if (errorsGroup.hasOwnProperty(i) && typeof this.mapNameToGuid[i] !== 'undefined') {
                    firstNodeId = this.mapNameToGuid[i];
                    break;
                }
            }
            if (firstNodeId) {
                scrollToId(firstNodeId);
            }
        }
        this.validateCallback.forEach((it) => it.apply(this));
    }
    onValidate(cb) {
        if (!this.validateCallback.includes(cb)) {
            this.validateCallback.push(cb);
        }
        return () => {
            const index = this.validateCallback.indexOf(cb);
            if (index >= 0) {
                this.validateCallback.splice(index, 1);
            }
        };
    }
    render() {
        const _a = this.props, { prefix = 'mt-', children, className, onSubmit, labelAlign = defaultContext.labelAlign, labelWidth = defaultContext.labelWidth, labelTextAlign = defaultContext.labelTextAlign, contentAlign = defaultContext.contentAlign, isPreview = defaultContext.isPreview, useLabelForErrorMessage = defaultContext.useLabelForErrorMessage, size = defaultContext.size, onChange } = _a, others = __rest(_a, ["prefix", "children", "className", "onSubmit", "labelAlign", "labelWidth", "labelTextAlign", "contentAlign", "isPreview", "useLabelForErrorMessage", "size", "onChange"]);
        const field = this.field;
        const contextValue = {
            labelAlign,
            labelWidth,
            labelTextAlign,
            contentAlign,
            isPreview,
            useLabelForErrorMessage,
            size,
            form: this,
            field,
        };
        return (createElement(Context.Provider, { value: contextValue },
            createElement(View, Object.assign({}, removeFormAttrs(others), { className: classNames(`${prefix}form`, className) }), children)));
    }
}
