import { __awaiter, __rest } from "tslib";
import { createElement, forwardRef, Fragment, useEffect, useRef, useState } from 'rax';
import classNames from 'classnames';
import ScrollView from 'rax-scrollview';
import Text from 'rax-text';
import View from '../view';
import Icon from '../icon';
import BreadCrumb from '../bread-crumb';
import List from '../list';
import Picker from '../picker';
import SelectDrawer from '../select-drawer';
import { useLocale } from '../locale';
import { isFunction, isUndef, isValidArray, isStrictWechatMiniProgram } from '../utils';
import { find, getDataByValues, getFirstValue, getSiblings, getFullPathByValue } from '../utils/tree';
const getInitValue = (props) => {
    const { dataSource = [], defaultValue, value } = props;
    let ret = [];
    if ('value' in props) {
        if (isValidArray(value)) {
            ret = value;
        }
        else if (!Array.isArray(value) && value) {
            ret = getFullPathByValue(props.dataSource, props.value);
        }
    }
    else if (!isUndef(defaultValue)) {
        if (isValidArray(defaultValue)) {
            ret = defaultValue;
        }
        else if (!Array.isArray(defaultValue) && defaultValue) {
            ret = getFullPathByValue(dataSource, defaultValue);
        }
    }
    return ret;
};
const getInitInternalValue = (props) => {
    const r = getInitValue(props);
    const isNormalMode = props.mode !== 'mini';
    if (r.length === 0) {
        if (!isNormalMode) {
            return getFirstValue(props.dataSource);
        }
        else {
            return [];
        }
    }
    else {
        return r;
    }
};
const defaultRenderContent = (values = [], separator) => Array.isArray(values) ? values.map((val) => val.label).join(separator) : '';
const CascaderSelect = (props, ref) => {
    const { prefix = 'mt-', dataSource = [], separator = '/', mode = 'normal', value, defaultValue, className, hasClear, useSimpleValue = false, onChange, rootTipText = '', locale: localeProp, loadData, isPreview, renderPreview, size = 'medium', drawerClassName, previewClassName: previewClassNameProp, previewStyle, onSelect = () => { }, onClear = () => { }, onCancel, renderContent = defaultRenderContent } = props, others = __rest(props, ["prefix", "dataSource", "separator", "mode", "value", "defaultValue", "className", "hasClear", "useSimpleValue", "onChange", "rootTipText", "locale", "loadData", "isPreview", "renderPreview", "size", "drawerClassName", "previewClassName", "previewStyle", "onSelect", "onClear", "onCancel", "renderContent"]);
    const scrollRef = useRef(null);
    const clsPrefix = `${prefix}cascader-select`;
    const isControlled = 'value' in props;
    const isNormalMode = mode !== 'mini';
    const previewClassName = classNames(previewClassNameProp, `${prefix}form-item-input--preview-${size}`);
    const loadingIcon = createElement(Icon, { className: `${clsPrefix}-icon--loading`, name: "loading", size: "s" });
    const selectedIcon = createElement(Icon, { className: `${clsPrefix}-icon--selected`, name: "select", size: "s" });
    const [curVal, setVal] = useState(getInitValue(props));
    const [internalValue, setInternalVal] = useState(getInitInternalValue(props));
    const [loadingNode, setLoadingNode] = useState(null);
    const [drawerVisible, setDrawerVisible] = useState(false);
    const locale = localeProp ||
        useLocale('Cascader', props, {
            rootTipText: '首页',
        });
    const innerSelectedPath = getDataByValues(dataSource, internalValue);
    const handlePickerChange = (v) => setInternalVal(v);
    const handleOk = () => {
        if (isNormalMode) {
            if (isValidArray(internalValue)) {
                const lastVal = internalValue[internalValue.length - 1];
                const n = find(dataSource, (node) => node.value === lastVal);
                if (n && n.children) {
                    handleCancel('invalid-selection');
                    return;
                }
            }
            else {
                handleCancel('invalid-selection');
                return;
            }
        }
        if (!isControlled) {
            setVal(internalValue);
        }
        if (onChange) {
            const selectedPath = getDataByValues(dataSource, internalValue);
            const lastData = selectedPath[selectedPath.length - 1];
            onChange(useSimpleValue ? lastData.value || '' : internalValue, lastData, {
                selectedPath,
            });
        }
    };
    const handleCancel = (reason) => {
        setInternalVal(curVal);
        if (isFunction(onCancel)) {
            onCancel(reason);
        }
    };
    const handleListClick = (item, dpt) => __awaiter(void 0, void 0, void 0, function* () {
        const val = item.value;
        let newInternalVal = [...internalValue.slice(0, dpt), val];
        if (loadData && internalValue.indexOf(val) > -1) {
            newInternalVal = internalValue.slice(0, internalValue.indexOf(val) + 1);
        }
        setInternalVal(newInternalVal);
        if (loadData && !item.isLeaf) {
            setLoadingNode(val);
            yield loadData(item);
            setLoadingNode(null);
        }
        if (item.children && scrollRef.current) {
            scrollRef.current.scrollTo(0, 0);
        }
        if (onSelect) {
            onSelect(val, item);
        }
    });
    const handleBreadCrumbClick = (index = 0) => {
        setInternalVal(internalValue.slice(0, index));
        if (scrollRef.current) {
            scrollRef.current.scrollTo(0, 0);
        }
    };
    const handleClear = () => {
        if (!isControlled) {
            setVal([]);
            setInternalVal([]);
        }
        if (onClear) {
            onClear();
        }
        if (onChange) {
            onChange(useSimpleValue ? '' : [], {}, {
                selectedPath: [],
            });
        }
    };
    const handleVisibleChange = (visible) => setDrawerVisible(visible);
    useEffect(() => {
        setVal(getInitValue(props));
        setInternalVal(getInitInternalValue(props));
    }, [value]);
    useEffect(() => {
        if (!drawerVisible) {
            setVal(getInitValue(props));
            setInternalVal(getInitInternalValue(props));
        }
    }, [props.dataSource]);
    let nextList = [];
    if (isNormalMode) {
        if (isValidArray(internalValue)) {
            const lastVal = internalValue[internalValue.length - 1];
            const t = find(dataSource, (node) => node.value === lastVal);
            if (t && loadingNode === t.value) {
                nextList = [];
            }
            else if (t && isValidArray(t.children)) {
                nextList = t.children;
            }
        }
        else {
            nextList = dataSource;
        }
    }
    const renderPicker = () => isValidArray(dataSource) ? (createElement(Picker, { cascade: true, data: dataSource, value: internalValue, onChange: handlePickerChange })) : null;
    if (isPreview) {
        if (isFunction(renderPreview)) {
            return (createElement(View, { className: previewClassName, style: previewStyle }, renderPreview(innerSelectedPath)));
        }
        return (createElement(Text, { className: previewClassName, style: previewStyle }, innerSelectedPath.map((node) => node.label).join(separator)));
    }
    return (createElement(SelectDrawer, Object.assign({}, others, { ref: ref, hasClear: hasClear, className: classNames(clsPrefix, className), content: renderContent(getDataByValues(dataSource, curVal), separator), drawerClassName: classNames(`${clsPrefix}-container`, drawerClassName), onVisibleChange: handleVisibleChange, onOk: handleOk, onCancel: handleCancel, onClear: handleClear }),
        isNormalMode ? (createElement(Fragment, null,
            createElement(BreadCrumb, { className: classNames(`${clsPrefix}-nav`, {
                    [`${clsPrefix}-nav--wechat`]: isStrictWechatMiniProgram,
                }), onClick: handleBreadCrumbClick },
                createElement(BreadCrumb.Item, null, rootTipText || locale.rootTipText),
                isValidArray(innerSelectedPath)
                    ? innerSelectedPath.map((val) => createElement(BreadCrumb.Item, { key: val.value }, val.label))
                    : null),
            createElement(View, { className: `${clsPrefix}-gutter` }))) : null,
        !isNormalMode ? (renderPicker()) : (createElement(ScrollView, { showsVerticalScrollIndicator: true, showsHorizontalScrollIndicator: false, ref: scrollRef, className: `${clsPrefix}-scrollview` },
            createElement(View, { className: `${clsPrefix}-item-container` },
                isValidArray(internalValue)
                    ? internalValue.map((val, index) => {
                        const list = getSiblings(dataSource, val);
                        return isValidArray(list) ? (createElement(List, { className: `${clsPrefix}-list`, key: val }, list.map((item) => {
                            let icon = null;
                            const hasArrow = (loadData && !item.isLeaf) || (!loadData && item.children);
                            if (loadData && loadingNode === item.value) {
                                icon = loadingIcon;
                            }
                            else if ((loadData && item.value === val) || (!loadData && item.value === val)) {
                                icon = selectedIcon;
                            }
                            return (createElement(List.Item, { key: item.value, title: item.label, extra: icon, arrow: hasArrow && !icon ? 'right' : null, disabled: item.disabled, onClick: () => handleListClick(item, index) }));
                        }))) : null;
                    })
                    : null,
                isValidArray(nextList) ? (createElement(List, { className: `${clsPrefix}-list` }, nextList.map((item) => {
                    let icon = null;
                    const hasArrow = item.children || (loadData && !item.isLeaf);
                    if (loadData && item.isLeaf && item.value === loadingNode) {
                        icon = loadingIcon;
                    }
                    return (createElement(List.Item, { key: item.value, title: item.label, extra: icon, arrow: hasArrow && !icon ? 'right' : null, disabled: item.disabled, onClick: () => handleListClick(item, internalValue ? internalValue.length : 0) }));
                }))) : null)))));
};
CascaderSelect.displayName = 'CascaderSelect';
export default forwardRef(CascaderSelect);
