import { __awaiter, __rest } from "tslib";
import { createElement, forwardRef, useCallback, useEffect, useRef, useState, } from 'rax';
import classNames from 'classnames';
import View from '../view';
import { getWidth, isFunction } from '../utils';
const getEndPosition = ({ translateX, actualOffset, triggerOffset, leftCellWidth, rightCellWidth, }) => {
    if (Math.abs(actualOffset) < triggerOffset) {
        return 0;
    }
    if (actualOffset > 0 && translateX > 0) {
        return leftCellWidth;
    }
    else if (actualOffset < 0 && translateX < 0) {
        return -rightCellWidth;
    }
    return 0;
};
const SlideView = (props, ref) => {
    const { prefix = 'mt-', children, duration = 500, className, leftActions = [], rightActions = [], triggerOffset = 50, uid = 0, onOpen, onClose } = props, others = __rest(props, ["prefix", "children", "duration", "className", "leftActions", "rightActions", "triggerOffset", "uid", "onOpen", "onClose"]);
    const [translateX, setTranslateX] = useState(0);
    const [duringTransition, toggleTransition] = useState(false);
    const startTouchRecord = useRef(null);
    const prevTouchRecord = useRef(null);
    const rightWidthRecord = useRef(0);
    const leftWidthRecord = useRef(0);
    const openStatusRecored = useRef(false);
    const clsPrefix = `${prefix}slide-view`;
    const resetPosition = useCallback(() => {
        scroll(0);
    }, []);
    const handleTouchStart = useCallback((e) => {
        startTouchRecord.current = e.changedTouches[0];
        prevTouchRecord.current = e.changedTouches[0];
    }, []);
    const handleTouchMove = useCallback((e) => {
        if (!prevTouchRecord.current) {
            return;
        }
        const currentTouch = getCurrentTouch(Array.from(e.changedTouches));
        const offsetX = currentTouch.pageX - prevTouchRecord.current.pageX;
        const offsetY = currentTouch.pageY - prevTouchRecord.current.pageY;
        if (Math.abs(offsetX) < Math.abs(offsetY)) {
            return;
        }
        if (e.cancelable) {
            e.preventDefault();
        }
        prevTouchRecord.current = currentTouch;
        const nextTranslateX = translateX + offsetX;
        if (nextTranslateX > leftWidthRecord.current || -nextTranslateX > rightWidthRecord.current) {
            return;
        }
        if (openStatusRecored.current === false && prevTouchRecord.current.pageX !== startTouchRecord.current.pageX) {
            const direction = prevTouchRecord.current.pageX > startTouchRecord.current.pageX ? 'left' : 'right';
            openStatusRecored.current = true;
            if (isFunction(onOpen)) {
                onOpen(direction);
            }
        }
        setTranslateX(nextTranslateX);
    }, [translateX]);
    const handleTouchEnd = useCallback((e) => {
        if (!prevTouchRecord.current) {
            return;
        }
        const endTouch = getCurrentTouch(Array.from(e.changedTouches));
        const actualOffset = endTouch.pageX - startTouchRecord.current.pageX;
        const endPosition = getEndPosition({
            translateX,
            actualOffset,
            triggerOffset,
            leftCellWidth: leftWidthRecord.current,
            rightCellWidth: rightWidthRecord.current,
        });
        startTouchRecord.current = null;
        prevTouchRecord.current = null;
        scroll(endPosition);
        if (openStatusRecored.current === true && endPosition === 0) {
            openStatusRecored.current = false;
            if (isFunction(onClose)) {
                onClose();
            }
        }
    }, [translateX, duringTransition]);
    const scroll = useCallback((pos) => {
        toggleTransition(true);
        setTranslateX(pos);
        setTimeout(() => {
            toggleTransition(false);
        }, duration);
    }, [duration]);
    const getCurrentTouch = useCallback((touches) => {
        return touches.find(({ identifier }) => {
            return identifier === prevTouchRecord.current.identifier;
        });
    }, []);
    const handleClick = useCallback((cb) => __awaiter(void 0, void 0, void 0, function* () {
        let hideFlag = true;
        if (cb && typeof cb === 'function') {
            hideFlag = yield cb();
        }
        if (hideFlag === false) {
            return;
        }
        resetPosition();
    }), [duringTransition]);
    useEffect(() => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            leftWidthRecord.current = yield getWidth(`${prefix}cell-left-${uid}`);
            rightWidthRecord.current = yield getWidth(`${prefix}cell-right-${uid}`);
        }))();
    }, [uid, leftActions, rightActions]);
    return (createElement(View, Object.assign({}, others, { ref: ref, className: classNames(className, `${clsPrefix}`) }),
        createElement(View, { className: `${clsPrefix}-wrapper`, style: {
                transform: `translate3d(${translateX}px, 0, 0)`,
                transitionDuration: duringTransition ? `${(duration / 1000).toFixed(1)}s` : '0s',
            } },
            createElement(View, { className: `${clsPrefix}-cell ${clsPrefix}-cell--left`, id: `${prefix}cell-left-${uid}` }, leftActions.map((item, index) => {
                return (createElement(View, { className: `${clsPrefix}-button-item`, onClick: () => handleClick(item.onClick), key: index }, item.content));
            })),
            createElement(View, { className: `${clsPrefix}-children`, onClick: resetPosition, onTouchStart: handleTouchStart, onTouchMove: handleTouchMove, onTouchEnd: handleTouchEnd }, children),
            createElement(View, { className: `${clsPrefix}-cell ${clsPrefix}-cell--right`, id: `${prefix}cell-right-${uid}` }, rightActions.map((item, index) => {
                return (createElement(View, { className: `${clsPrefix}-button-item`, onClick: () => handleClick(item.onClick), key: index }, item.content));
            })))));
};
SlideView.displayName = 'SlideView';
export default forwardRef(SlideView);
