const { declare } = require('@babel/helper-plugin-utils');
// const core = require('@babel/core');

// const t = core.types;
const KEY = 'sandbox';
const whiteList = ['_styleSheet', KEY, '__create_condition__', '__classnames__', '_getStyle', '__create_list__'];
const blackList = ['Function', 'eval', '__proto__'];

module.exports = declare(() => {
  const getObject = (node) => {
    if (node.object && node.object.type === 'Identifier') return node.object.name;
    if (node.object && node.object.type === 'MemberExpression') return getObject(node.object);
    return '';
  }
  return {
    visitor: {
      JSXExpressionContainer(path, a) {
        const arr = a.filename.split('.');
        if (arr && arr.length > 0 && (arr[arr.length - 1] === 'xml' || arr[arr.length - 1] === 'rxml')) {
          path.traverse({
            // jsx 中表达式
            // eg: {xxx.aaa}, {xxx.aaa.bbb}, {xxx.aaa()}
            MemberExpression: (path) => {
              // 如果最前面的 object 是定义过的就不处理，主要是针对 x-for={item in xxx}, {item.xxx} 的时候 item 不需要处理
              if (path.scope.hasBinding(getObject(path.node))) {
                return;
              }
              // 已经处理过了的忽略
              if (whiteList.indexOf(getObject(path.node)) > -1) {
                return;
              }
              // 除了以上两种情况，都要加 key
              if (path && path.node && path.toString() && path.node.object && (path.node.object.type === 'Identifier' || path.node.object.type === 'MemberExpression')) {
                path.replaceWithSourceString(`${KEY}.${path.toString()}`);
              }
            },
            // jsx 中声明
            Identifier: (path) => {
              if (path && path.node && path.toString()) {
                if (whiteList.indexOf(path.node.name) > -1) return;
                if (blackList.indexOf(path.node.name) > -1) {
                  throw Error(`can not use ${path.node.object.name}`);
                }
                // 处理 x-for 套 x-for 或者 x-if 套 x-for 的情况，里层的 x-for 不会预处理成箭头函数，需要手动把变量定义在作用域里面
                // 就是处理所有的 x-for ，如果作用域内没有定义变量就手动定义一个
                // 匹配 item in data 里面的 item
                if (path.parentPath && path.parentPath.type === 'BinaryExpression' && path.key === 'left' && path.parentPath.parentPath
                  && path.parentPath.parentPath.node && path.parentPath.parentPath.node.type === 'JSXExpressionContainer' && path.parentPath.parentPath.parentPath && path.parentPath.parentPath.parentPath.node
                  && path.parentPath.parentPath.parentPath.node.name && path.parentPath.parentPath.parentPath.node.name.name === 'x-for') {
                  if (!path.scope.hasBinding(path.node.name)) {
                    path.scope.registerBinding('params', path);
                  }
                }
                // 匹配 (item, index) in data 里面的 item 和 index
                if (path.parentPath && path.parentPath.node && path.parentPath.node.type === 'SequenceExpression' && path.parentPath.key === 'left'
                  && path.parentPath.parentPath && path.parentPath.parentPath.node && path.parentPath.parentPath.node.type === 'BinaryExpression' && path.parentPath.parentPath.node.operator === 'in'
                  // 匹配 x-for={item in data}
                  && path.parentPath.parentPath.parentPath && path.parentPath.parentPath.parentPath.node && path.parentPath.parentPath.parentPath.node.type === 'JSXExpressionContainer'
                  && path.parentPath.parentPath.parentPath.parentPath && path.parentPath.parentPath.parentPath.parentPath.node && path.parentPath.parentPath.parentPath.parentPath.node.name && path.parentPath.parentPath.parentPath.parentPath.node.name.name === 'x-for') {
                    if (!path.scope.hasBinding(path.node.name)) {
                      path.scope.registerBinding('params', path);
                    }
                }
                // 如果已经声明的变量，不处理
                if (path.scope.hasBinding(path.node.name)) {
                  return;
                }
                // 分别处理 {aaa}, {aaa?bbb:ccc}, {aaa()}
                const allowParentType = ['ConditionalExpression', 'JSXExpressionContainer', 'CallExpression'];
                if (path.parentPath && path.parentPath.node && allowParentType.indexOf(path.parentPath.node.type) > -1) {
                  path.replaceWithSourceString(`${KEY}.${path.toString()}`);
                }
                // eg: x-for = {aaa in data}，处理 data
                if (path.parentPath && path.parentPath.node && path.parentPath.node.type === 'BinaryExpression' && path.parentPath.node.operator === 'in' && path.parentPath.node.right === path.node) {
                  path.replaceWithSourceString(`${KEY}.${path.toString()}`);
                }
              }
            },
            // 不允许定义变量
            VariableDeclaration: () => {
              throw Error('can not declaration custom variable');
            },
            Function: (path) => {
              // x-for 会预处理成箭头函数，这里特殊处理一下
              if (path && path.node && path.node.body && path.node.body.__listHandled) {
                return;
              }
              if (path && path.node && path.node.body && path.node.body.type !== 'BlockStatement') {
                return;
              }
              throw Error('can not declaration custom variable');
            }
          });
        }
      },
    },
  };
});
