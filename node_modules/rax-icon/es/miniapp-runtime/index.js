var _excluded = ["source", "fontFamily", "style"];

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { createElement, forwardRef } from 'rax';
import { isMiniApp, isWeChatMiniProgram, isByteDanceMicroApp, isBaiduSmartProgram, isKuaiShouMiniProgram } from 'universal-env';
import Text from 'rax-text';
import Image from 'rax-image';
import wrapDefaultProperties from '../utils/wrapDefaultProperties';
import { createIconSet as rawCreateIconSet } from '../createIconSet';
var fontCache = new Map();
var Icon = forwardRef(function (_ref, ref) {
  var _ref$source = _ref.source;
  _ref$source = _ref$source === void 0 ? {} : _ref$source;

  var uri = _ref$source.uri,
      codePoint = _ref$source.codePoint,
      fontFamily = _ref.fontFamily,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? {} : _ref$style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);

  if (uri && !codePoint && !fontFamily) {
    return createElement(Image, _extends({}, rest, {
      source: {
        uri: uri
      },
      style: style
    }));
  }

  if (!fontFamily) {
    return createElement(Text, _extends({}, rest, {
      ref: ref,
      style: style
    }), codePoint);
  }

  var fontFile = fontCache.get(fontFamily);

  if (!fontFile) {
    // In Miniapp, iconfont must be loaded every time when page changes
    var source = "url('" + uri + "')";

    if (isMiniApp) {
      if (typeof my.loadFontFace === 'function') {
        my.loadFontFace({
          family: fontFamily,
          source: source
        });
      } else {
        console.warn('Your container may not support my.loadFontFace! Please check it and use local fontfamily.');
      }
    } else if (isWeChatMiniProgram) {
      wx.loadFontFace({
        family: fontFamily,
        source: source
      });
    } else if (isByteDanceMicroApp) {
      tt.loadFont(uri);
    } else if (isBaiduSmartProgram || isKuaiShouMiniProgram) {
      console.warn('Current container does not support loading font face from uri.');
    }
  } else if (fontFile !== uri) {
    console.error("font-family " + fontFamily + " should be unique!");
    return null;
  }

  return createElement(Text, _extends({}, rest, {
    ref: ref,
    style: _extends({}, style, {
      fontFamily: fontFamily
    })
  }), codePoint);
});
export function createIconSet(glyphMap, fontFamily, fontFile) {
  if (glyphMap === void 0) {
    glyphMap = {};
  }

  return rawCreateIconSet(Icon, glyphMap, fontFamily, fontFile);
}
export default wrapDefaultProperties(Icon);