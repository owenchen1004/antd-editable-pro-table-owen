var _excluded = ["source", "fontFamily", "style"];

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { createElement, forwardRef } from 'rax';
import Text from 'rax-text';
import Image from 'rax-image';
import wrapDefaultProperties from '../utils/wrapDefaultProperties';
import { createIconSet as rawCreateIconSet } from '../createIconSet';
var fontCache = new Map();
var Icon = forwardRef(function (_ref, ref) {
  var _ref$source = _ref.source;
  _ref$source = _ref$source === void 0 ? {} : _ref$source;

  var uri = _ref$source.uri,
      codePoint = _ref$source.codePoint,
      fontFamily = _ref.fontFamily,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? {} : _ref$style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);

  if (uri && !codePoint && !fontFamily) {
    return createElement(Image, _extends({}, rest, {
      source: {
        uri: uri
      },
      style: style
    }));
  }

  if (!fontFamily) {
    return createElement(Text, _extends({}, rest, {
      ref: ref,
      style: style
    }), codePoint);
  }

  var fontFile = fontCache.get(fontFamily);

  if (!fontFile) {
    // In Web and Weex, this font not be loaded yet, load now
    // In Miniapp, iconfont must be loaded every time when page changes
    var source = "url('" + uri + "')";
    fontCache.set(fontFamily, uri);

    if (window.FontFace) {
      var iconfont = new window.FontFace(fontFamily, source);
      document.fonts.add(iconfont);
    } else {
      // Create stylesheet
      var _style = document.createElement('style');

      _style.type = 'text/css';

      _style.appendChild(document.createTextNode("@font-face {\n              src: " + source + ";\n              font-family: " + fontFamily + ";\n            }"));

      document.head.appendChild(_style);
    }
  } else if (fontFile !== uri) {
    console.error("font-family " + fontFamily + " should be unique!");
    return null;
  }

  return createElement(Text, _extends({}, rest, {
    ref: ref,
    style: _extends({}, style, {
      fontFamily: fontFamily
    })
  }), codePoint);
});
export function createIconSet(glyphMap, fontFamily, fontFile) {
  if (glyphMap === void 0) {
    glyphMap = {};
  }

  return rawCreateIconSet(Icon, glyphMap, fontFamily, fontFile);
}
export default wrapDefaultProperties(Icon);