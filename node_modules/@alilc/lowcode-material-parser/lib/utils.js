"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeEval = exports.isEvaluable = exports.isPrimitive = exports.loadFile = exports.resolvePkgJson = exports.syncTypeModules = exports.installPeerAndDevDeps = exports.installTypeScript = exports.installTypeDTS = exports.installModule = exports.install = exports.isNPMModuleInstalled = exports.isNPMInstalled = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = require("fs-extra");
const lodash_1 = require("lodash");
const safe_eval_1 = tslib_1.__importDefault(require("safe-eval"));
const path = tslib_1.__importStar(require("path"));
const cross_spawn_promise_1 = tslib_1.__importDefault(require("cross-spawn-promise"));
async function isNPMInstalled(args) {
    return fs_extra_1.pathExists(path.join(args.workDir, 'node_modules'));
}
exports.isNPMInstalled = isNPMInstalled;
async function isNPMModuleInstalled(args, name) {
    const modulePkgJsonPath = path.resolve(args.workDir, 'node_modules', name, 'package.json');
    return fs_extra_1.pathExists(modulePkgJsonPath);
}
exports.isNPMModuleInstalled = isNPMModuleInstalled;
async function install(args) {
    if (await isNPMInstalled(args))
        return;
    const { workDir, npmClient = 'tnpm' } = args;
    try {
        await cross_spawn_promise_1.default(npmClient, ['i'], { stdio: 'inherit', cwd: workDir });
    }
    catch (e) {
        // TODO
    }
}
exports.install = install;
async function installModule(args, name) {
    if (await isNPMModuleInstalled(args, name))
        return;
    const { workDir, npmClient = 'tnpm' } = args;
    try {
        await cross_spawn_promise_1.default(npmClient, ['i', name], { stdio: 'inherit', cwd: workDir });
    }
    catch (e) {
        // TODO
    }
}
exports.installModule = installModule;
function installTypeDTS(args) {
    return installModule(args, `@types/${args.dslType || 'react'}`);
}
exports.installTypeDTS = installTypeDTS;
async function installTypeScript(args) {
    if (await fs_extra_1.pathExists(path.join(args.workDir, 'node_modules', '.bin', 'tsc')))
        return;
    const { workDir, npmClient = 'tnpm' } = args;
    await cross_spawn_promise_1.default(npmClient, ['i', 'typescript'], { stdio: 'inherit', cwd: workDir });
}
exports.installTypeScript = installTypeScript;
async function installPeerAndDevDeps(args) {
    const { workDir, moduleDir, npmClient = 'tnpm' } = args;
    const modulePkgJsonPath = path.resolve(moduleDir, 'package.json');
    if (!(await fs_extra_1.pathExists(modulePkgJsonPath))) {
        return;
    }
    const pkgJsonPath = path.resolve(workDir, 'package.json');
    if (!(await fs_extra_1.pathExists(pkgJsonPath))) {
        return;
    }
    const modulePkgJson = await resolvePkgJson(modulePkgJsonPath);
    const pkgJson = await resolvePkgJson(pkgJsonPath);
    const { peerDependencies = {}, devDependencies = {} } = modulePkgJson;
    pkgJson.dependencies = pkgJson.dependencies || {};
    pkgJson.dependencies = {
        ...pkgJson.dependencies,
        ...peerDependencies,
        ...devDependencies,
    };
    await fs_extra_1.writeFile(pkgJsonPath, JSON.stringify(pkgJson, null, 2));
    await cross_spawn_promise_1.default(npmClient, ['i'], { stdio: 'inherit', cwd: workDir });
}
exports.installPeerAndDevDeps = installPeerAndDevDeps;
async function syncTypeModules(args) {
    const { workDir, moduleDir, npmClient = 'tnpm' } = args;
    const pkgJsonPath = path.resolve(moduleDir, 'package.json');
    if (!(await fs_extra_1.pathExists(pkgJsonPath))) {
        return;
    }
    await installModule(args, 'typesync');
    await cross_spawn_promise_1.default(npmClient.replace('m', 'x'), ['typesync'], { stdio: 'inherit', cwd: workDir });
}
exports.syncTypeModules = syncTypeModules;
async function resolvePkgJson(pkgJsonPath) {
    const content = await loadFile(pkgJsonPath);
    const json = JSON.parse(content);
    return json;
}
exports.resolvePkgJson = resolvePkgJson;
function loadFile(filePath) {
    const content = fs_extra_1.readFileSync(filePath);
    if (typeof content === 'string') {
        return content;
    }
    return content.toString();
}
exports.loadFile = loadFile;
function isPrimitive(val) {
    return !['object', 'function'].includes(typeof val) || val === null;
}
exports.isPrimitive = isPrimitive;
function isEvaluable(value) {
    if (isPrimitive(value))
        return true;
    if (Array.isArray(value)) {
        return value.every(isEvaluable);
    }
    else if (lodash_1.isPlainObject(value)) {
        return Object.keys(value).every((key) => isEvaluable(value[key]));
    }
    return false;
}
exports.isEvaluable = isEvaluable;
function safeEval(value) {
    if (typeof value === 'string')
        return safe_eval_1.default(value);
    return value;
}
exports.safeEval = safeEval;
//# sourceMappingURL=utils.js.map