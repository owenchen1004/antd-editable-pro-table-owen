"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPkgNameAndVersion = exports.createworkDir = exports.createFakePackage = void 0;
const tslib_1 = require("tslib");
const cross_spawn_promise_1 = tslib_1.__importDefault(require("cross-spawn-promise"));
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const short_uuid_1 = tslib_1.__importDefault(require("short-uuid"));
const core_1 = require("./core");
const log = core_1.debug.extend('localize');
/**
 * 创建组件包
 *
 * @private
 * @param {{
 *     pkgName: string;
 *     pkgVersion: string;
 *   }} params
 * @returns {Promise<void>}
 * @memberof OnlineAccesser
 */
async function createFakePackage(params) {
    // 创建临时组件包
    const { workDir } = params;
    const pkgJsonFilePath = path_1.join(workDir, 'package.json');
    await fs_extra_1.ensureFile(pkgJsonFilePath);
    await fs_extra_1.writeFile(pkgJsonFilePath, JSON.stringify({
        name: params.pkgName,
        version: params.pkgVersion || '0.0.0',
        dependencies: {
            [params.pkgName]: params.pkgVersion || 'latest',
            react: 'latest',
            'react-dom': 'latest',
            'parse-prop-types': '^0.3.0',
            typesync: 'latest',
        },
    }, null, 2));
    // 安装依赖
    const npmClient = params.npmClient || 'tnpm';
    await cross_spawn_promise_1.default(npmClient, ['i'], { stdio: 'inherit', cwd: workDir });
}
exports.createFakePackage = createFakePackage;
/**
 * 创建临时目录
 *
 * @private
 * @returns {Promise<string>} 返回临时文件夹路径
 * @memberof LocalGenerator
 */
async function createworkDir(tempDir) {
    const workDirName = short_uuid_1.default.generate();
    const workDir = path_1.resolve(tempDir || '../../node_modules/.temp/', workDirName);
    await fs_extra_1.ensureDir(workDir);
    log('create temp dir successfully', workDir);
    return workDir;
}
exports.createworkDir = createworkDir;
/**
 * 分离物料组件名称和版本号
 *
 * @private
 * @param {string} pkgNameWithVersion
 * @returns {{ [key: string]: any }}
 * @memberof OnlineAccesser
 */
function getPkgNameAndVersion(pkgNameWithVersion) {
    const matches = pkgNameWithVersion.match(/(@[^/]+)$/);
    if (!matches) {
        return {
            name: pkgNameWithVersion,
        };
    }
    const name = pkgNameWithVersion.replace(matches[0], '');
    return {
        version: matches[0].slice(1),
        name,
    };
}
exports.getPkgNameAndVersion = getPkgNameAndVersion;
// 将问题转化为本地物料化场景
async function localize(options) {
    var _a;
    // 创建临时目录
    const workDir = await createworkDir(options.tempDir);
    await fs_extra_1.ensureDir(workDir);
    let { name, version = 'latest' } = options;
    if (!name) {
        const pkgNameAndVersion = getPkgNameAndVersion(options.entry);
        name = pkgNameAndVersion.name;
        version = pkgNameAndVersion.version;
    }
    // 创建组件包
    await createFakePackage({
        pkgName: name,
        pkgVersion: version,
        workDir,
        npmClient: options.npmClient,
    });
    const result = {
        workDir,
        moduleDir: path_1.join(workDir, 'node_modules', name),
        entry: undefined,
    };
    if ((_a = options) === null || _a === void 0 ? void 0 : _a.name) {
        result.entry = options.entry;
    }
    return result;
}
exports.default = localize;
//# sourceMappingURL=localize.js.map