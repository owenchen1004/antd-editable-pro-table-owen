"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ast_types_1 = require("ast-types");
const lodash_1 = require("lodash");
const checkIsIIFE_1 = tslib_1.__importDefault(require("./checkIsIIFE"));
const resolveHOC_1 = tslib_1.__importDefault(require("./resolveHOC"));
const resolveIIFE_1 = tslib_1.__importDefault(require("./resolveIIFE"));
const resolveImport_1 = tslib_1.__importDefault(require("./resolveImport"));
const resolveTranspiledClass_1 = tslib_1.__importDefault(require("./resolveTranspiledClass"));
const isStaticMethod_1 = tslib_1.__importDefault(require("./isStaticMethod"));
const findAssignedMethods_1 = tslib_1.__importDefault(require("./findAssignedMethods"));
const resolveExportDeclaration_1 = tslib_1.__importDefault(require("./resolveExportDeclaration"));
const makeProxy_1 = tslib_1.__importDefault(require("../utils/makeProxy"));
const cache_1 = require("../utils/cache");
const getName_1 = tslib_1.__importDefault(require("../utils/getName"));
const getRoot_1 = tslib_1.__importDefault(require("../utils/getRoot"));
const expressionTo = require('react-docgen/dist/utils/expressionTo');
const { isExportsOrModuleAssignment, isReactComponentClass, isReactCreateClassCall, isReactForwardRefCall, isStatelessComponent, normalizeClassDefinition, resolveToValue, getMemberValuePath, } = require('react-docgen').utils;
function ignore() {
    return false;
}
function isComponentDefinition(path) {
    return (isReactCreateClassCall(path) ||
        isReactComponentClass(path) ||
        isStatelessComponent(path) ||
        isReactForwardRefCall(path));
}
function resolveDefinition(definition) {
    if (isReactCreateClassCall(definition)) {
        // return argument
        const resolvedPath = resolveToValue(definition.get('arguments', 0));
        if (ast_types_1.namedTypes.ObjectExpression.check(resolvedPath.node)) {
            return resolvedPath;
        }
    }
    else if (isReactComponentClass(definition)) {
        normalizeClassDefinition(definition);
        return definition;
    }
    else if (isStatelessComponent(definition) || isReactForwardRefCall(definition)) {
        return definition;
    }
    return null;
}
function getDefinition(definition, cache = {}) {
    const { __meta: exportMeta = {} } = definition;
    if (checkIsIIFE_1.default(definition)) {
        definition = resolveToValue(resolveIIFE_1.default(definition));
        if (!isComponentDefinition(definition)) {
            definition = resolveTranspiledClass_1.default(definition);
        }
    }
    else {
        definition = resolveToValue(resolveHOC_1.default(definition));
        if (isComponentDefinition(definition)) {
            definition = makeProxy_1.default(definition, {
                __meta: exportMeta,
            });
            return definition;
        }
        if (checkIsIIFE_1.default(definition)) {
            definition = resolveToValue(resolveIIFE_1.default(definition));
            if (!isComponentDefinition(definition)) {
                definition = resolveTranspiledClass_1.default(definition);
            }
        }
        else if (ast_types_1.namedTypes.SequenceExpression.check(definition.node)) {
            const classNameNode = definition.parent.get('id').node;
            const localNames = [];
            let { node } = definition.get('expressions', 0);
            while (ast_types_1.namedTypes.AssignmentExpression.check(node)) {
                // @ts-ignore
                const { name } = node.left;
                if (name) {
                    localNames.push(name);
                }
                node = node.right;
            }
            definition.get('expressions').each((x) => {
                if (!x.name)
                    return;
                if (ast_types_1.namedTypes.AssignmentExpression.check(x.node) && ast_types_1.namedTypes.MemberExpression.check(x.node.left)) {
                    const objectName = x.node.left.object.name;
                    if (localNames.includes(objectName)) {
                        x.get('left', 'object').replace(classNameNode);
                    }
                }
            });
            definition = getDefinition(resolveToValue(definition.get('expressions').get(0)), cache);
        }
        else {
            return resolveImport_1.default(definition, (ast, sourcePath, importMeta, mode) => {
                let result;
                if (cache_1.has('ast-export', ast.__path)) {
                    result = cache_1.get('ast-export', ast.__path);
                }
                else {
                    result = findAllExportedComponentDefinition(ast);
                    cache_1.set('ast-export', ast.__path, result);
                }
                const exportList = [];
                const importList = [];
                result.forEach((def) => {
                    const { __meta: meta = {} } = def;
                    let { exportName } = meta;
                    for (const item of importMeta) {
                        if (exportName === item.importedName) {
                            exportName = item.localName;
                            break;
                        }
                    }
                    if (exportName) {
                        importList.push(makeProxy_1.default(def, { __meta: { exportName } }));
                    }
                    const nextMeta = {
                        exportName,
                    };
                    if (exportName === exportMeta.localName) {
                        nextMeta.exportName = exportMeta.exportName;
                    }
                    else if (mode === 'import') {
                        // } else {
                        return;
                    }
                    if (exportMeta.subName) {
                        nextMeta.subName = exportMeta.subName;
                    }
                    else if (meta.subName) {
                        nextMeta.subName = meta.subName;
                    }
                    exportList.push(makeProxy_1.default(def, { __meta: nextMeta }));
                });
                cache[sourcePath] = importList;
                // result = result.filter((x) => !x.__shouldDelete);
                return exportList;
            });
        }
    }
    if (definition && (!definition.__meta || Object.keys(definition.__meta).length === 0)) {
        definition.__meta = exportMeta;
    }
    return definition;
}
/**
 * Extract all flow types for the methods of a react component. Doesn't
 * return any react specific lifecycle methods.
 */
function getSubComponents(path, scope, cache) {
    // Extract all methods from the class or object.
    let methodPaths = [];
    if (isReactComponentClass(path)) {
        methodPaths = path.get('body', 'body').filter(isStaticMethod_1.default);
        methodPaths = [...methodPaths, ...findAssignedMethods_1.default(scope || path.scope, path.get('id'))];
    }
    else if (ast_types_1.namedTypes.ObjectExpression.check(path.node)) {
        methodPaths = path.get('properties').filter(isStaticMethod_1.default);
        methodPaths = [...methodPaths, ...findAssignedMethods_1.default(scope || path.scope, path.get('id'))];
        // Add the statics object properties.
        const statics = getMemberValuePath(path, 'statics');
        if (statics) {
            statics.get('properties').each((p) => {
                if (isStaticMethod_1.default(p)) {
                    p.node.static = true;
                    methodPaths.push(p);
                }
            });
        }
    }
    else if (ast_types_1.namedTypes.VariableDeclarator.check(path.parent.node) &&
        path.parent.node.init === path.node &&
        ast_types_1.namedTypes.Identifier.check(path.parent.node.id)) {
        methodPaths = findAssignedMethods_1.default(scope || path.parent.scope, path.parent.get('id'));
    }
    else if (ast_types_1.namedTypes.AssignmentExpression.check(path.parent.node) &&
        path.parent.node.right === path.node &&
        ast_types_1.namedTypes.Identifier.check(path.parent.node.left)) {
        methodPaths = findAssignedMethods_1.default(scope || path.parent.scope, path.parent.get('left'));
    }
    else if (ast_types_1.namedTypes.FunctionDeclaration.check(path.node)) {
        methodPaths = findAssignedMethods_1.default(scope || path.parent.scope, path.get('id'));
    }
    else if (ast_types_1.namedTypes.ArrowFunctionExpression.check(path.node)) {
        methodPaths = findAssignedMethods_1.default(scope || path.parent.scope, path.parent.get('id'));
    }
    return (methodPaths
        .map((x) => {
        if (ast_types_1.namedTypes.ClassProperty.check(x.node)) {
            return {
                value: x.get('value'),
                subName: x.node.key.name,
                localName: getName_1.default(x.get('value')),
            };
        }
        return {
            value: x,
            subName: x.node.left.property.name,
            localName: getName_1.default(x.get('right')),
        };
    })
        .map(({ subName, localName, value }) => ({
        subName,
        localName,
        value: resolveToValue(value),
    }))
        .map(({ subName, localName, value }) => {
        let def = getDefinition(makeProxy_1.default(value, {
            __meta: {
                localName,
                subName,
                exportName: path.__meta && path.__meta.exportName,
            },
        }), cache);
        if (!Array.isArray(def)) {
            def = [def];
        }
        return {
            subName,
            localName,
            value: def.flatMap((x) => x).filter((x) => isComponentDefinition(x)),
        };
    })
        .map(({ subName, localName, value }) => {
        return value.map((x) => ({
            subName,
            localName,
            value: x,
        }));
    })
        // @ts-ignore
        .flatMap((x) => x)
        .map(({ subName, value }) => {
        const __meta = {
            subName,
            exportName: path.__meta && path.__meta.exportName,
        };
        return makeProxy_1.default(value, { __meta });
    }));
}
/**
 * Given an AST, this function tries to find the exported component definition.
 *
 * The component definition is either the ObjectExpression passed to
 * `React.createClass` or a `class` definition extending `React.Component` or
 * having a `render()` method.
 *
 * If a definition is part of the following statements, it is considered to be
 * exported:
 *
 * modules.exports = Definition;
 * exports.foo = Definition;
 * export default Definition;
 * export var Definition = ...;
 */
function findAllExportedComponentDefinition(ast) {
    const components = [];
    const cache = {};
    let programScope;
    function exportDeclaration(path) {
        const definitions = resolveExportDeclaration_1.default(path)
            .reduce((acc, definition) => {
            if (isComponentDefinition(definition)) {
                acc.push(definition);
            }
            else {
                definition = getDefinition(definition, cache);
                if (!Array.isArray(definition)) {
                    definition = [definition];
                }
                definition.forEach((def) => {
                    if (isComponentDefinition(def)) {
                        acc.push(def);
                    }
                });
            }
            return acc;
        }, [])
            .map((definition) => {
            const { __meta: meta } = definition;
            const def = resolveDefinition(definition);
            return makeProxy_1.default(def, { __meta: meta });
        });
        if (definitions.length === 0) {
            return false;
        }
        definitions.forEach((definition) => {
            if (definition && components.indexOf(definition) === -1) {
                components.push(definition);
            }
        });
        return false;
    }
    ast_types_1.visit(ast, {
        visitProgram(path) {
            programScope = path.scope;
            return this.traverse(path);
        },
        visitFunctionDeclaration: ignore,
        visitFunctionExpression: ignore,
        visitClassDeclaration: ignore,
        visitClassExpression: ignore,
        visitIfStatement: ignore,
        visitWithStatement: ignore,
        visitSwitchStatement: ignore,
        visitWhileStatement: ignore,
        visitDoWhileStatement: ignore,
        visitForStatement: ignore,
        visitForInStatement: ignore,
        visitForOfStatement: ignore,
        visitImportDeclaration: ignore,
        visitExportNamedDeclaration: exportDeclaration,
        visitExportDefaultDeclaration: exportDeclaration,
        visitExportAllDeclaration(path) {
            components.push(...resolveImport_1.default(path, findAllExportedComponentDefinition));
            return false;
        },
        visitAssignmentExpression(path) {
            // Ignore anything that is not `exports.X = ...;` or
            // `module.exports = ...;`
            if (!isExportsOrModuleAssignment(path)) {
                return false;
            }
            const arr = expressionTo.Array(path.get('left'));
            const meta = {
                exportName: arr[1] === 'exports' ? 'default' : arr[1],
            };
            // Resolve the value of the right hand side. It should resolve to a call
            // expression, something like React.createClass
            path = resolveToValue(path.get('right'));
            if (!isComponentDefinition(path)) {
                path = getDefinition(path, cache);
            }
            if (!Array.isArray(path)) {
                path = [path];
            }
            const definitions = path.map(resolveDefinition);
            definitions.forEach((definition) => {
                if (definition && components.indexOf(definition) === -1) {
                    // if (definition.__meta) {
                    definition = makeProxy_1.default(definition, {
                        __meta: meta,
                    });
                    // }
                    components.push(definition);
                }
            });
            return false;
        },
    });
    const result = components.reduce((acc, item) => {
        let subModuleDefinitions = [];
        subModuleDefinitions = getSubComponents(item, programScope, cache);
        return [...acc, item, ...subModuleDefinitions];
    }, []);
    const res = lodash_1.uniqBy(result, (x) => {
        var _a, _b;
        return `${(_b = (_a = getRoot_1.default(x)) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.__path}/${x.__meta.exportName}/${x.__meta.subName}`;
    });
    return res;
}
exports.default = findAllExportedComponentDefinition;
//# sourceMappingURL=index.js.map