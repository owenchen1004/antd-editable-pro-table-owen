"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveToImport = exports.isRequireLike = exports.isImportLike = void 0;
const tslib_1 = require("tslib");
const ast_types_1 = require("ast-types");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const getRoot_1 = tslib_1.__importDefault(require("../utils/getRoot"));
const { resolveToModule, resolveToValue, match } = require('react-docgen').utils;
function isImportLike(path) {
    const { node } = path;
    return (ast_types_1.namedTypes.ImportDeclaration.check(node) ||
        ast_types_1.namedTypes.ExportAllDeclaration.check(node) ||
        ast_types_1.namedTypes.ExportNamedDeclaration.check(node));
}
exports.isImportLike = isImportLike;
function isRequireLike(path) {
    var _a;
    if (ast_types_1.namedTypes.CallExpression.check(path.node) &&
        ast_types_1.namedTypes.Identifier.check(path.get('callee').node) &&
        path.get('callee').node.name === 'require' &&
        ast_types_1.namedTypes.Literal.check((_a = path.get('arguments', 0)) === null || _a === void 0 ? void 0 : _a.node)) {
        return true;
    }
    return false;
}
exports.isRequireLike = isRequireLike;
function resolveToImport(initialPath) {
    const pathBuffer = [initialPath];
    while (pathBuffer.length) {
        let path = pathBuffer.shift();
        const node = path.node;
        switch (node.type) {
            case 'VariableDeclarator':
                if (node.init) {
                    pathBuffer.unshift(path.get('init'));
                }
                break;
            case 'CallExpression': {
                if (match(node.callee, { type: 'Identifier', name: 'require' })) {
                    return path;
                }
                const paths = [path.get('callee')];
                const argumentsPath = path.get('arguments');
                for (let index = 0; index < argumentsPath.value.length; index++) {
                    paths.push(argumentsPath.get(index));
                }
                pathBuffer.unshift(...paths);
            }
            // eslint-disable-next-line no-fallthrough
            case 'Identifier':
            case 'JSXIdentifier': {
                const valuePath = resolveToValue(path);
                if (valuePath !== path) {
                    pathBuffer.unshift(valuePath);
                }
                break;
            }
            case 'ImportDeclaration':
                return path;
            case 'MemberExpression':
                while (path && ast_types_1.namedTypes.MemberExpression.check(path.node)) {
                    path = path.get('object');
                }
                if (path) {
                    pathBuffer.unshift(path);
                }
        }
    }
    return null;
}
exports.resolveToImport = resolveToImport;
function getPath(path, name) {
    const root = getRoot_1.default(path).node;
    if (!root)
        return;
    let { __path } = root;
    __path = path_1.default.dirname(__path);
    // is directory
    if (fs_1.default.existsSync(path_1.default.resolve(__path, name))) {
        name += '/index';
    }
    const suffix = suffixes.find((suf) => {
        return fs_1.default.existsSync(path_1.default.resolve(__path, name + suf));
    });
    if (!suffix)
        return;
    return path_1.default.resolve(__path, name + suffix);
}
const buildParser = require('react-docgen/dist/babelParser').default;
const suffixes = ['.js', '.jsx', '.ts', '.tsx'];
const cache = {};
function resolveImport(path, callback) {
    let name;
    let mode = 'import';
    let importPath;
    if (path.name === 'local') {
        name = path.parentPath.parentPath.parentPath.node.source.value;
        importPath = path;
    }
    else {
        importPath = resolveToImport(path);
        if (!importPath) {
            return path;
        }
        if (isImportLike(importPath)) {
            name = importPath.node.source.value;
        }
        else if (isRequireLike(importPath)) {
            const moduleName = resolveToModule(importPath);
            if (typeof moduleName === 'string') {
                mode = 'require';
                name = moduleName;
            }
        }
        else {
            return path;
        }
    }
    if (name) {
        const __path = getPath(path, name);
        if (!__path)
            return path;
        let ast;
        if (!cache[__path]) {
            const fileContent = fs_1.default.readFileSync(__path, 'utf8');
            const parser = buildParser({ filename: __path });
            ast = parser.parse(fileContent);
            ast.__src = fileContent;
            ast.__path = __path;
            cache[__path] = ast;
        }
        else {
            ast = cache[__path];
        }
        const importMeta = [];
        if (mode === 'import') {
            if (ast_types_1.namedTypes.ImportDeclaration.check(importPath.node)) {
                // @ts-ignore
                const specifiers = importPath.get('specifiers');
                specifiers.each((spec) => {
                    const { node } = spec;
                    importMeta.push({
                        localName: node.local.name,
                        importedName: node.imported ? node.imported.name : 'default',
                    });
                });
            }
        }
        else {
            const idPath = importPath.parentPath.get('id');
            if (ast_types_1.namedTypes.Identifier.check(idPath.node)) {
                importMeta.push({
                    localName: 'default',
                    importedName: idPath.node.name,
                });
            }
            else if (ast_types_1.namedTypes.ObjectPattern.check(path.node)) {
                path.get('properties').each((propertyPath) => {
                    const keyPath = propertyPath.get('key');
                    const valuePath = propertyPath.get('value');
                    if (ast_types_1.namedTypes.Identifier.check(keyPath.node) && ast_types_1.namedTypes.Identifier.check(valuePath.node)) {
                        importMeta.push({
                            localName: keyPath.node.name,
                            importedName: valuePath.node.name,
                        });
                    }
                });
            }
        }
        return callback(ast, __path, importMeta, mode);
    }
    return path;
}
exports.default = resolveImport;
//# sourceMappingURL=resolveImport.js.map