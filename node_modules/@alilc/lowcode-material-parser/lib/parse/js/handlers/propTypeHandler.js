"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.childContextTypeHandler = exports.contextTypeHandler = exports.propTypeHandler = void 0;
const tslib_1 = require("tslib");
const ast_types_1 = require("ast-types");
const getRoot_1 = tslib_1.__importDefault(require("../utils/getRoot"));
const getComposedPath_1 = tslib_1.__importDefault(require("../utils/getComposedPath"));
const buildParser = require('react-docgen/dist/babelParser').default;
const { resolveToValue, isExportsOrModuleAssignment, getPropType, getPropertyName, getMemberValuePath, isReactModuleName, printValue, resolveToModule, } = require('react-docgen').utils;
const expressionTo = require('react-docgen/dist/utils/expressionTo');
const isRequiredPropType = require('react-docgen/dist/utils/isRequiredPropType')
    .default;
function isPropTypesExpression(path) {
    const moduleName = resolveToModule(path);
    if (moduleName) {
        return isReactModuleName(moduleName) || moduleName === 'ReactPropTypes';
    }
    return false;
}
function amendPropTypes(getDescriptor, path, documentation, propName) {
    if (!ast_types_1.namedTypes.ObjectExpression.check(path.node)) {
        const propTypesPath = getComposedPath_1.default(documentation, propName, path);
        if (!propTypesPath) {
            return;
        }
        else {
            path.replace(propTypesPath.node);
        }
    }
    path.get('properties').each((propertyPath) => {
        switch (propertyPath.node.type) {
            // @ts-ignore
            case ast_types_1.namedTypes.Property.name: {
                const propName = getPropertyName(propertyPath);
                if (!propName)
                    return;
                const propDescriptor = getDescriptor(propName);
                const valuePath = propertyPath.get('value');
                const type = getPropType(valuePath);
                if (type) {
                    propDescriptor.type = type;
                    propDescriptor.required =
                        type.name !== 'custom' && isRequiredPropType(valuePath);
                }
                break;
            }
            // @ts-ignore
            case ast_types_1.namedTypes.SpreadElement.name: {
                const resolvedValuePath = resolveToValue(propertyPath.get('argument'));
                switch (resolvedValuePath.node.type) {
                    // @ts-ignore
                    case ast_types_1.namedTypes.ObjectExpression.name: // normal object literal
                        amendPropTypes(getDescriptor, resolvedValuePath, documentation, propName);
                        break;
                }
                break;
            }
        }
    });
}
function getDefinePropertyValuePath(nodePath, propName) {
    const program = getRoot_1.default(nodePath);
    let resultPath = nodePath;
    if (!nodePath.node.id)
        return;
    const componentName = nodePath.node.id.name;
    ast_types_1.visit(program, {
        visitCallExpression(path) {
            const args = path.get('arguments');
            const argsNodeList = args.value;
            if (argsNodeList.length === 3 &&
                ast_types_1.namedTypes.Identifier.check(argsNodeList[0]) &&
                argsNodeList[0].name === componentName &&
                ast_types_1.namedTypes.Literal.check(argsNodeList[1]) &&
                argsNodeList[1].value === propName) {
                resultPath = args.get(2);
            }
            return false;
        },
    });
    return resultPath;
}
function getPropTypeHandler(propName) {
    return function (documentation, path) {
        let propTypesPath = getMemberValuePath(path, propName);
        if (!propTypesPath) {
            propTypesPath = getDefinePropertyValuePath(path, propName);
            if (!propTypesPath) {
                return;
            }
        }
        propTypesPath = resolveToValue(propTypesPath);
        if (!propTypesPath) {
            return;
        }
        let getDescriptor;
        switch (propName) {
            case 'childContextTypes':
                getDescriptor = documentation.getChildContextDescriptor;
                break;
            case 'contextTypes':
                getDescriptor = documentation.getContextDescriptor;
                break;
            default:
                getDescriptor = documentation.getPropDescriptor;
        }
        amendPropTypes(getDescriptor.bind(documentation), propTypesPath, documentation, propName);
    };
}
exports.propTypeHandler = getPropTypeHandler('propTypes');
exports.contextTypeHandler = getPropTypeHandler('contextTypes');
exports.childContextTypeHandler = getPropTypeHandler('childContextTypes');
//# sourceMappingURL=propTypeHandler.js.map