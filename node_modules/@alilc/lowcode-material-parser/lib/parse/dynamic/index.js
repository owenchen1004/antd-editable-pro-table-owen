"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
// import * as path from 'path';
// @ts-ignore
const parse_prop_types_1 = tslib_1.__importDefault(require("parse-prop-types"));
const prop_types_1 = tslib_1.__importDefault(require("prop-types"));
const transform_1 = require("../transform");
const requireInSandbox_1 = tslib_1.__importDefault(require("./requireInSandbox"));
const reservedKeys = [
    'propTypes',
    'defaultProps',
    'name',
    'arguments',
    'caller',
    'length',
    'contextTypes',
    'displayName',
    '__esModule',
    'version',
];
function getKeys(com) {
    const keys = Object.keys(com).filter(x => {
        return !reservedKeys.includes(x) && !x.startsWith('_');
    });
    return keys;
}
function isComponent(obj) {
    return (typeof obj === 'function' &&
        (Object.prototype.hasOwnProperty.call(obj, 'propTypes') ||
            Object.prototype.hasOwnProperty.call(obj, 'defaultProps')));
}
function default_1(filePath) {
    // const { filePath } = arg;
    // const modulePath = path.resolve(workDir, 'node_modules', 'parse-prop-types');
    // const parsePropTypes = require(modulePath).default;
    if (!filePath)
        return [];
    const Com = requireInSandbox_1.default(filePath, prop_types_1.default);
    const components = [];
    let index = 0;
    if (Com.__esModule) {
        const keys = getKeys(Com);
        keys.forEach(k => {
            if (isComponent(Com[k])) {
                components.push({
                    component: Com[k],
                    meta: {
                        exportName: k,
                    },
                });
            }
        });
    }
    else if (isComponent(Com)) {
        components.push({
            component: Com,
            meta: {
                exportName: 'default',
            },
        });
    }
    // dps
    while (index < components.length) {
        const item = components[index++];
        const keys = getKeys(item.component);
        const subs = keys
            .filter(k => isComponent(item.component[k]))
            .map(k => ({
            component: item.component[k],
            meta: {
                ...item.meta,
                subName: k,
            },
        }));
        if (subs.length) {
            components.splice(index, 0, ...subs);
        }
    }
    const result = components.reduce((acc, { meta, component }) => {
        const componentInfo = parse_prop_types_1.default(component);
        if (!lodash_1.isEmpty(componentInfo)) {
            const props = Object.keys(componentInfo).reduce((acc2, name) => {
                try {
                    const item = transform_1.transformItem(name, componentInfo[name]);
                    acc2.push(item);
                }
                catch (e) {
                    // TODO
                }
                return acc2;
            }, []);
            return [
                ...acc,
                {
                    meta,
                    props,
                    componentName: meta.subName || meta.exportName || component.displayName,
                },
            ];
        }
        return acc;
    }, []);
    return result;
}
exports.default = default_1;
//# sourceMappingURL=index.js.map