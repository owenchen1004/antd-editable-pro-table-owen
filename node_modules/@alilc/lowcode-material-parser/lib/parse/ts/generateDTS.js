"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const fs_extra_1 = require("fs-extra");
const utils_1 = require("../../utils");
const core_1 = require("../../core");
const log = core_1.debug.extend('parse:ts:generate_dts');
/**
 * Generate alias dts file by removing some needless interfaces.
 * Replace original file at present, which will cause type pollution, looking for better solution
 * @param {string} workDir - the dir containing the module to be parsed
 * @returns {string} - the path of generated xxx.d.ts
 */
function generateDTS({ workDir, dslType = 'react', }) {
    const typeDir = path.join(workDir, 'node_modules', `@types/${dslType}`);
    const typePath = path.join(typeDir, 'index.d.ts');
    const fileContent = utils_1.loadFile(typePath);
    // const materialParserTypeDir = path.join(workDir, `node_modules/material-parser-types/${type}`);
    // ensureDirSync(materialParserTypeDir);
    const materialParserTypeDir = typeDir;
    const newTypePath = path.join(materialParserTypeDir, 'index.d.ts');
    // if (!pathExistsSync(newTypePath)) {
    // copySync(
    //   path.join(typeDir, 'global.d.ts'),
    //   path.join(materialParserTypeDir, 'global.d.ts'),
    // );
    let newContent = fileContent.replace(/(?<=interface HTMLAttributes[^e]+)(extends[^}]+)/, `{
    style?: CSSProperties;
    className?: string;
  `);
    newContent = newContent.replace(/(?<=interface IntrinsicElements {)([^}]+)/, '');
    newContent = newContent.replace(/type LibraryManagedAttributes[^;]+;/, '');
    fs_extra_1.writeFileSync(newTypePath, newContent);
    log('generate dts', newTypePath);
    // } else {
    //   log('found dts', newTypePath);
    // }
    return {
        originalTypePath: typePath,
        newTypePath,
    };
}
exports.default = generateDTS;
//# sourceMappingURL=generateDTS.js.map