"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const react_docgen_typescript_1 = require("react-docgen-typescript");
const typescript_1 = tslib_1.__importStar(require("typescript"));
const lodash_1 = require("lodash");
const fs_extra_1 = require("fs-extra");
const find_config_1 = tslib_1.__importDefault(require("find-config"));
const core_1 = require("../../core");
const transform_1 = require("../transform");
const generateDTS_1 = tslib_1.__importDefault(require("./generateDTS"));
const log = core_1.debug.extend('parse:ts');
function getNextParentIds(parentIds, type) {
    var _a;
    // @ts-ignore
    const id = (_a = type === null || type === void 0 ? void 0 : type.symbol) === null || _a === void 0 ? void 0 : _a.id;
    if (id) {
        return [...parentIds, id];
    }
    return parentIds;
}
function getSymbolName(symbol) {
    // @ts-ignore
    const prefix = (symbol === null || symbol === void 0 ? void 0 : symbol.parent) && getSymbolName(symbol.parent);
    const name = symbol.getName();
    if (prefix && prefix.length <= 20) {
        return `${prefix}.${name}`;
    }
    return name;
}
function getFunctionParams(parameters = [], checker, parentIds, type) {
    return parameters.map((node) => {
        const typeObject = checker.getTypeOfSymbolAtLocation(node.symbol, node.symbol.valueDeclaration);
        const v = getDocgenTypeHelper(checker, typeObject, false, getNextParentIds(parentIds, type));
        const name = node.symbol.escapedName;
        return {
            name,
            propType: v,
        };
    });
}
function getFunctionReturns(node, checker, parentIds, type) {
    if (!node)
        return {};
    const propType = getDocgenTypeHelper(checker, node.type, false, getNextParentIds(parentIds, type));
    return {
        propType,
    };
}
const blacklistNames = [
    'prototype',
    'getDerivedStateFromProps',
    'propTypes',
    'defaultProps',
    'contextTypes',
    'displayName',
    'contextType',
    'Provider',
    'Consumer',
];
const blacklistPatterns = [
    /^HTML/,
    /^React\./,
    /^Object$/,
    /^Date$/,
    /^Promise$/,
    /^XML/,
    /^Function$/,
];
// function hasTooManyTypes(type) {
//   return type?.types?.length >= 20;
// }
function isComplexType(type) {
    let isAliasSymbol = false;
    let symbol = type === null || type === void 0 ? void 0 : type.symbol;
    if (!symbol) {
        symbol = type === null || type === void 0 ? void 0 : type.aliasSymbol;
        isAliasSymbol = true;
    }
    if (!symbol)
        return false;
    if (isAliasSymbol) {
        return false;
    }
    const name = getSymbolName(symbol);
    if (blacklistPatterns.some((patt) => patt.test(name))) {
        return true;
    }
    return false;
}
function getDocgenTypeHelper(checker, type, skipRequired = false, parentIds = [], isRequired = false) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    function isTuple(_type) {
        // @ts-ignore use internal methods
        return checker.isArrayLikeType(_type) && !checker.isArrayType(_type);
    }
    let required;
    if (isRequired !== undefined) {
        required = isRequired;
    }
    else {
        required = !(type.flags & typescript_1.SymbolFlags.Optional) || isRequired;
    }
    function makeResult(typeInfo) {
        if (skipRequired) {
            return {
                raw: checker.typeToString(type),
                ...typeInfo,
            };
        }
        else {
            return {
                required,
                raw: checker.typeToString(type),
                ...typeInfo,
            };
        }
    }
    function getShapeFromArray(symbolArr, _type) {
        const shape = symbolArr.map((prop) => {
            var _a;
            const propType = checker.getTypeOfSymbolAtLocation(prop, 
            // @ts-ignore
            prop.valueDeclaration || (prop.declarations && prop.declarations[0]) || {});
            return {
                key: prop.getName(),
                value: getDocgenTypeHelper(checker, propType, false, 
                // @ts-ignore
                getNextParentIds(parentIds, _type), 
                // @ts-ignore
                !((_a = prop === null || prop === void 0 ? void 0 : prop.valueDeclaration) === null || _a === void 0 ? void 0 : _a.questionToken)),
            };
        });
        // @ts-ignore use internal methods
        if (checker.isArrayLikeType(_type)) {
            return shape;
        }
        if (_type.getStringIndexType()) {
            // @ts-ignore use internal methods
            if (!_type.stringIndexInfo) {
                return shape;
            }
            shape.push({
                key: {
                    name: 'string',
                },
                value: getDocgenTypeHelper(checker, 
                // @ts-ignore use internal methods
                _type.stringIndexInfo.type, false, getNextParentIds(parentIds, _type)),
            });
        }
        else if (_type.getNumberIndexType()) {
            // @ts-ignore use internal methods
            if (!_type.numberIndexInfo) {
                return shape;
            }
            shape.push({
                key: {
                    name: 'number',
                },
                value: getDocgenTypeHelper(checker, 
                // @ts-ignore use internal methods
                _type.numberIndexInfo.type, false, getNextParentIds(parentIds, _type)),
            });
        }
        return shape;
    }
    function getShape(_type) {
        const { symbol } = _type;
        if (symbol && symbol.members) {
            // @ts-ignore
            const props = Array.from(symbol.members.values());
            // if (props.length >= 20) {
            //   throw new Error('too many props');
            // }
            return getShapeFromArray(props.filter((prop) => prop.getName() !== '__index'), _type);
        }
        else {
            // @ts-ignore
            const args = _type.resolvedTypeArguments || [];
            const props = checker.getPropertiesOfType(_type);
            // if (props.length >= 20) {
            //   throw new Error('too many props');
            // }
            const shape = getShapeFromArray(props.slice(0, args.length), _type);
            return shape;
        }
    }
    // @ts-ignore
    if ((type === null || type === void 0 ? void 0 : type.kind) === typescript_1.SyntaxKind.VoidExpression) {
        return makeResult({
            name: 'void',
            raw: 'void',
        });
    }
    const pattern = /^__global\.(.+)$/;
    // @ts-ignore
    if (parentIds.includes((_a = type === null || type === void 0 ? void 0 : type.symbol) === null || _a === void 0 ? void 0 : _a.id)) {
        return makeResult({
            name: 'object',
        });
    }
    if (type.symbol) {
        const symbolName = getSymbolName(type.symbol);
        if (symbolName) {
            const matches = pattern.exec(symbolName);
            if (matches) {
                return makeResult({
                    name: matches[1],
                });
            }
        }
    }
    if (type.flags & typescript_1.TypeFlags.Number) {
        return makeResult({
            name: 'number',
        });
    }
    else if (type.flags & typescript_1.TypeFlags.String) {
        return makeResult({
            name: 'string',
        });
    }
    else if (type.flags & typescript_1.TypeFlags.NumberLiteral) {
        return makeResult({
            name: 'literal',
            // @ts-ignore
            value: type.value,
        });
    }
    else if (type.flags & typescript_1.TypeFlags.Literal) {
        return makeResult({
            name: 'literal',
            value: checker.typeToString(type),
        });
    }
    else if (((_b = type.symbol) === null || _b === void 0 ? void 0 : _b.flags) & typescript_1.SymbolFlags.Enum) {
        return makeResult({
            name: 'union',
            // @ts-ignore
            value: type.types.map((t) => t.value),
        });
        // @ts-ignore
    }
    else if (type.flags & typescript_1.TypeFlags.DisjointDomains) {
        return makeResult({
            name: checker.typeToString(type),
        });
    }
    else if (type.flags & typescript_1.TypeFlags.Any) {
        return makeResult({
            name: 'any',
        });
    }
    else if (type.flags & typescript_1.TypeFlags.Union && !isComplexType(type)) {
        return makeResult({
            name: 'union',
            // @ts-ignore
            value: type.types.map((t) => getDocgenTypeHelper(checker, t, true, getNextParentIds(parentIds, type))),
        });
    }
    else if (isComplexType(type)) {
        return makeResult({
            name: getSymbolName((type === null || type === void 0 ? void 0 : type.symbol) || (type === null || type === void 0 ? void 0 : type.aliasSymbol)),
        });
    }
    else if (type.flags & (typescript_1.TypeFlags.Object | typescript_1.TypeFlags.Intersection)) {
        if (isTuple(type)) {
            try {
                const props = getShape(type);
                return makeResult({
                    name: 'tuple',
                    value: props.map((p) => p.value),
                });
            }
            catch (e) {
                return makeResult({
                    name: 'object',
                });
            }
            // @ts-ignore
        }
        else if (checker.isArrayType(type)) {
            return makeResult({
                name: 'Array',
                // @ts-ignore
                elements: [
                    getDocgenTypeHelper(checker, type.typeArguments[0], false, getNextParentIds(parentIds, type)),
                ],
            });
            // @ts-ignore
        }
        else if ((_e = (_d = (_c = type === null || type === void 0 ? void 0 : type.symbol) === null || _c === void 0 ? void 0 : _c.valueDeclaration) === null || _d === void 0 ? void 0 : _d.parameters) === null || _e === void 0 ? void 0 : _e.length) {
            return makeResult({
                name: 'func',
                params: getFunctionParams((_g = (_f = 
                // @ts-ignore
                type === null || 
                // @ts-ignore
                type === void 0 ? void 0 : 
                // @ts-ignore
                type.symbol) === null || _f === void 0 ? void 0 : _f.valueDeclaration) === null || _g === void 0 ? void 0 : _g.parameters, checker, parentIds, type),
                returns: getFunctionReturns(checker.typeToTypeNode(type, (_h = type === null || type === void 0 ? void 0 : type.symbol) === null || _h === void 0 ? void 0 : _h.valueDeclaration), checker, parentIds, type),
            });
        }
        else if ((_p = (_o = (_m = (_l = (_k = (_j = 
        // @ts-ignore
        type === null || 
        // @ts-ignore
        type === void 0 ? void 0 : 
        // @ts-ignore
        type.members) === null || _j === void 0 ? void 0 : _j.get('__call')) === null || _k === void 0 ? void 0 : _k.declarations[0]) === null || _l === void 0 ? void 0 : _l.symbol) === null || _m === void 0 ? void 0 : _m.declarations[0]) === null || _o === void 0 ? void 0 : _o.parameters) === null || _p === void 0 ? void 0 : _p.length) {
            return makeResult({
                name: 'func',
                params: getFunctionParams((_u = (_t = (_s = (_r = (_q = 
                // @ts-ignore
                type === null || 
                // @ts-ignore
                type === void 0 ? void 0 : 
                // @ts-ignore
                type.members) === null || _q === void 0 ? void 0 : _q.get('__call')) === null || _r === void 0 ? void 0 : _r.declarations[0]) === null || _s === void 0 ? void 0 : _s.symbol) === null || _t === void 0 ? void 0 : _t.declarations[0]) === null || _u === void 0 ? void 0 : _u.parameters, checker, parentIds, type),
            });
        }
        else {
            try {
                const props = getShape(type);
                return makeResult({
                    name: 'signature',
                    type: {
                        signature: {
                            properties: props,
                        },
                    },
                });
            }
            catch (e) {
                return makeResult({
                    name: 'object',
                });
            }
        }
    }
    else {
        return makeResult({
            name: 'object',
        });
    }
}
class MyParser extends react_docgen_typescript_1.Parser {
    getDocgenType(propType) {
        var _a, _b;
        const parentIds = [];
        // @ts-ignore
        const parentId = (_b = (_a = propType === null || propType === void 0 ? void 0 : propType.symbol) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.id;
        if (parentId) {
            parentIds.push(parentId);
        }
        // @ts-ignore
        const result = getDocgenTypeHelper(this.checker, propType, true, parentIds);
        return result;
    }
    // override the builtin method, to avoid the false positive
    extractPropsFromTypeIfStatelessComponent(type) {
        const callSignatures = type.getCallSignatures();
        if (callSignatures.length) {
            // Could be a stateless component.  Is a function, so the props object we're interested
            // in is the (only) parameter.
            for (const sig of callSignatures) {
                const params = sig.getParameters();
                if (params.length === 0) {
                    continue;
                }
                // @ts-ignore
                const returnSymbol = this.checker.getReturnTypeOfSignature(sig);
                if (!returnSymbol)
                    continue;
                const symbol = returnSymbol === null || returnSymbol === void 0 ? void 0 : returnSymbol.symbol;
                if (!symbol)
                    continue;
                // @ts-ignore
                const typeString = this.checker.symbolToString(symbol);
                if (typeString.startsWith('ReactElement') ||
                    typeString.startsWith('Element') ||
                    typeString.startsWith('RaxElement')) {
                    const propsParam = params[0];
                    if (propsParam) {
                        return propsParam;
                    }
                }
            }
        }
        return null;
    }
}
const getCompilerOptions = (reactTypePath, originalReactTypePath) => {
    const options = {
        jsx: typescript_1.default.JsxEmit.React,
        module: typescript_1.default.ModuleKind.CommonJS,
        target: typescript_1.default.ScriptTarget.Latest,
        allowSyntheticDefaultImports: true,
    };
    // if (reactTypePath) {
    //   options.paths = {
    //     react: [reactTypePath],
    //   };
    //   options.exclude = [path.dirname(originalReactTypePath)];
    //   options.types = [];
    //   options.skipLibCheck = true;
    // }
    return options;
};
function getComponentName(exportName, displayName) {
    if (displayName) {
        const firstCharCode = displayName.charCodeAt(0);
        if (firstCharCode >= 65 && firstCharCode <= 90) {
            return displayName || exportName;
        }
    }
    return exportName;
}
const defaultTsConfigPath = path.resolve(__dirname, './tsconfig.json');
function parseTS(filePath, args) {
    if (!filePath)
        return [];
    let basePath = args.moduleDir || args.workDir || path.dirname(filePath);
    let tsConfigPath = find_config_1.default('tsconfig.json', { cwd: basePath }); // path.resolve(basePath, 'tsconfig.json')
    if (!tsConfigPath ||
        !fs_extra_1.existsSync(tsConfigPath) ||
        (args.accesser === 'online' && tsConfigPath === 'tsconfig.json')) {
        tsConfigPath = defaultTsConfigPath;
    }
    else {
        basePath = path.dirname(tsConfigPath);
    }
    log('ts config path is', tsConfigPath);
    const { config, error } = typescript_1.default.readConfigFile(tsConfigPath, (filename) => fs_extra_1.readFileSync(filename, 'utf8'));
    if (error !== undefined) {
        const errorText = `Cannot load custom tsconfig.json from provided path: ${tsConfigPath}, with error code: ${error.code}, message: ${error.messageText}`;
        throw new Error(errorText);
    }
    const { options, errors } = typescript_1.default.parseJsonConfigFileContent(config, typescript_1.default.sys, basePath, {}, tsConfigPath);
    if (errors && errors.length) {
        throw errors[0];
    }
    log('ts config is', options);
    // const filePaths = Array.isArray(filePathOrPaths) ? filePathOrPaths : [filePathOrPaths];
    generateDTS_1.default(args);
    const program = typescript_1.default.createProgram([filePath], options);
    const parser = new MyParser(program, {});
    const checker = program.getTypeChecker();
    const result = [filePath]
        .map((fPath) => program.getSourceFile(fPath))
        .filter((sourceFile) => typeof sourceFile !== 'undefined')
        .reduce((docs, sourceFile) => {
        const moduleSymbol = checker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol) {
            return docs;
        }
        const exportSymbols = checker.getExportsOfModule(moduleSymbol);
        for (let index = 0; index < exportSymbols.length; index++) {
            const sym = exportSymbols[index];
            const name = sym.getName();
            if (blacklistNames.includes(name)) {
                continue;
            }
            // polyfill valueDeclaration
            sym.valueDeclaration =
                sym.valueDeclaration || (Array.isArray(sym.declarations) && sym.declarations[0]);
            if (!sym.valueDeclaration) {
                continue;
            }
            const info = parser.getComponentInfo(sym, sourceFile);
            if (info === null) {
                continue;
            }
            const exportName = sym.meta && sym.meta.exportName;
            const meta = {
                subName: exportName ? name : '',
                exportName: exportName || name,
            };
            if (docs.find((x) => lodash_1.isEqual(x.meta, meta))) {
                continue;
            }
            docs.push({
                ...info,
                meta,
            });
            // find sub components
            if (!!sym.declarations && sym.declarations.length === 0) {
                continue;
            }
            const type = checker.getTypeOfSymbolAtLocation(sym, sym.valueDeclaration || sym.declarations[0]);
            Array.prototype.push.apply(exportSymbols, type.getProperties().map((x) => {
                x.meta = { exportName: name };
                return x;
            }));
        }
        return docs;
    }, []);
    const coms = result.reduce((res, info) => {
        var _a;
        if (!info || !info.props || lodash_1.isEmpty(info.props))
            return res;
        const props = Object.keys(info.props).reduce((acc, name) => {
            // omit aria related properties temporarily
            if (name.startsWith('aria-')) {
                return acc;
            }
            try {
                const item = transform_1.transformItem(name, info.props[name]);
                acc.push(item);
            }
            catch (e) {
                log(e);
            }
            return acc;
        }, []);
        const exportName = (_a = info === null || info === void 0 ? void 0 : info.meta) === null || _a === void 0 ? void 0 : _a.exportName;
        res.push({
            componentName: getComponentName(exportName, info.displayName),
            props,
            meta: info.meta || {},
        });
        return res;
    }, []);
    return coms;
}
exports.default = parseTS;
//# sourceMappingURL=index.js.map